#ifndef PE_FRACTION_
#define PE_FRACTION_

#include "pe_base"
#include "pe_int128"
#include "pe_mod"
#include "pe_nt"
#include "pe_type_traits"

template <typename T>
struct Fraction {
  Fraction(T u = 0, T v = 1) : a_(u), b_(v) {
    T d = gcd(abs(a_), abs(b_));
    if (d > 1) a_ /= d, b_ /= d;
    if (b_ < 0) b_ = -b_, a_ = -a_;
  }
  int operator<(const Fraction& o) const { return a_ * o.b_ < b_ * o.a_; }
  int operator<=(const Fraction& o) const { return a_ * o.b_ <= b_ * o.a_; }
  int operator>(const Fraction& o) const { return a_ * o.b_ > b_ * o.a_; }
  int operator>=(const Fraction& o) const { return a_ * o.b_ >= b_ * o.a_; }
  int operator==(const Fraction& o) const { return a_ * o.b_ == b_ * o.a_; }
  int operator!=(const Fraction& o) const { return a_ * o.b_ != b_ * o.a_; }
  Fraction operator+(const Fraction& o) const {
    return Fraction(a_ * o.b_ + o.a_ * b_, b_ * o.b_);
  }
  Fraction operator-(const Fraction& o) const {
    return Fraction(a_ * o.b_ - o.a_ * b_, b_ * o.b_);
  }
  Fraction operator*(const Fraction& o) const {
    return Fraction(a_ * o.a_, b_ * o.b_);
  }
  Fraction operator/(const Fraction& o) const {
    return Fraction(a_ * o.b_, b_ * o.a_);
  }
  double toDouble() { return 1. * a_ / b_; }
  long double toLongDouble() { return static_cast<long double>(1.) * a_ / b_; }
  T a_, b_;
};

template <typename T>
Fraction<T> operator+(const Fraction<T>& f) {
  return f;
}

template <typename T>
Fraction<T> operator-(const Fraction<T>& f) {
  return Fraction<T>(-f.a_, f.b_);
}

template <typename T>
ostream& operator<<(ostream& o, const Fraction<T>& f) {
  return o << f.a_ << "/" << f.b_;
}
#endif
