#ifndef PE_RANGE_
#define PE_RANGE_

#include "pe_type_traits"
#include "pe_mod"

// range utility
namespace ru {
SL int64 id(int64 a) { return a; }

SL int64 mul(int64 a, int64 b) { return a * b; }

SL int64 add(int64 a, int64 b) { return a + b; }

template <int64 M>
SL int64 mul_mod(int64 a, int64 b) {
  return ::mul_mod_ex(a, b, M);
}

template <int64 M>
SL int64 add_mod(int64 a, int64 b) {
  return ::add_mod(a, b, M);
}

SL std::function<int64(int64, int64)> mul_mod(int64 mod) {
  return [=](int64 a, int64 b) { return ::mul_mod_ex(a, b, mod); };
}

SL std::function<int64(int64, int64)> add_mod(int64 mod) {
  return [=](int64 a, int64 b) { return ::add_mod(a, b, mod); };
}

SL std::function<int64(int64, int64)> add_f(
    const std::function<int64(int64)>& f) {
  return [=](int64 a, int64 b) -> int64 { return add(a, f(b)); };
}

SL std::function<int64(int64, int64)> mul_f(
    const std::function<int64(int64)>& f) {
  return [=](int64 a, int64 b) -> int64 { return mul(a, f(b)); };
}

SL std::function<int64(int64, int64)> add_mod_f(
    const std::function<int64(int64)>& f, int64 mod) {
  return [=](int64 a, int64 b) -> int64 {
    return ::add_mod(a % mod, f(b) % mod, mod);
  };
}

SL std::function<int64(int64, int64)> mul_mod_f(
    const std::function<int64(int64)>& f, int64 mod) {
  return [=](int64 a, int64 b) -> int64 {
    return ::mul_mod_ex(a % mod, f(b) % mod, mod);
  };
}

SL void imul(int64& a, int64 b) { a *= b; }

SL void iadd(int64& a, int64 b) { a += b; }

template <int64 M>
SL void imul_mod(int64& a, int64 b) {
  a = ::mul_mod_ex(a, b, M);
}

template <int64 M>
SL void iadd_mod(int64& a, int64 b) {
  a = ::add_mod(a, b, M);
}

SL std::function<void(int64&, int64)> imul_mod(int64 mod) {
  return [=](int64& a, int64 b) { a = ::mul_mod_ex(a, b, mod); };
}

SL std::function<void(int64&, int64)> iadd_mod(int64 mod) {
  return [=](int64& a, int64 b) { a = ::add_mod(a, b, mod); };
}

SL std::function<void(int64&, int64)> iadd_f(
    const std::function<int64(int64)>& f) {
  return [=](int64& a, int64 b) { imul(a, f(b)); };
}

SL std::function<void(int64&, int64)> imul_mod_f(
    const std::function<int64(int64)>& f, int64 mod) {
  return [=](int64& a, int64 b) { a = ::mul_mod_ex(a % mod, f(b) % mod, mod); };
}

SL std::function<void(int64&, int64)> iadd_mod_f(
    const std::function<int64(int64)>& f, int64 mod) {
  return [=](int64& a, int64 b) { a = ::add_mod(a % mod, f(b) % mod, mod); };
}

template <typename T>
struct Reducer {
  using VT = typename T::VT;
  VT init_value() { return 0; }
  void accumulate(VT& v, VT a) {}
  void combine(VT& v, VT a) {}
};

template <typename T, typename U>
SL T id_map(U a) {
  return a;
}

template <typename T = int64, typename U = T>
struct Add {
  using VT = T;
  using IT = U;

  Add(const std::function<VT(IT)>& mapper = id_map<VT, IT>) : mapper_(mapper) {}

  VT init_value() const { return 0; }

  void accumulate(VT& v, const IT& a) const { v += mapper_(a); }

  void combine(VT& v, VT a) const { v += a; }

  std::function<VT(IT)> mapper_;
};

template <typename T = int64, typename U = T>
struct AddMod {
  using VT = T;
  using IT = U;

  AddMod(VT mod, const std::function<VT(IT)>& mapper = id_map<VT, IT>)
      : mod_(mod), mapper_(mapper) {}

  VT init_value() const { return 0; }

  void accumulate(VT& v, const IT& a) const {
    v = ::add_mod<VT>(v, mapper_(a) % mod_, mod_);
  }

  void combine(VT& v, VT a) const { v = ::add_mod<VT>(v, a, mod_); }

  const VT mod_;
  std::function<VT(IT)> mapper_;
};

template <typename T = int64, typename U = T>
struct Mul {
  using VT = T;
  using IT = U;

  Mul(const std::function<VT(IT)>& mapper = id_map<VT, IT>) : mapper_(mapper) {}

  VT init_value() const { return 1; }

  void accumulate(VT& v, const IT& a) const { v *= mapper_(a); }

  void combine(VT& v, VT a) const { v *= a; }

  std::function<VT(IT)> mapper_;
};

template <typename T = int64, typename U = T>
struct MulMod {
  using VT = T;
  using IT = U;

  MulMod(VT mod, const std::function<VT(IT)>& mapper = id_map<VT, IT>)
      : mod_(mod), mapper_(mapper) {}

  VT init_value() const { return 1; }

  void accumulate(VT& v, const IT& a) const {
    v = ::mul_mod_ex<VT>(v, mapper_(a) % mod_, mod_);
  }

  void combine(VT& v, VT a) const { v = ::mul_mod_ex<VT>(v, a, mod_); }

  const VT mod_;
  std::function<VT(IT)> mapper_;
};
}  // namespace ru

template <typename IT>
struct Range;

template <typename IT>
struct FilterRange;

template <typename IT, typename ET>
struct MappedRange;

template <typename ET>
struct VectorRange;

template <typename IT, typename DERIVED, typename IIT>
struct RangeBase {
  RangeBase(IT b, IT e) : b_(b), e_(e) {}
  RangeBase() = default;

  using self_type = RangeBase<IT, DERIVED, IIT>;
  using reference = typename IIT::reference;
  using rvalue_reference =
      typename add_rvalue_reference<const typename IIT::value_type>::type;
  using value_type = typename std::remove_cv<typename IIT::value_type>::type;

  FilterRange<IIT> filter(
      std::function<int(const typename IIT::value_type&)> filter) const {
    return FilterRange<IIT>{static_cast<const DERIVED&>(*this).begin(),
                            static_cast<const DERIVED&>(*this).end(), filter};
  }

  VectorRange<value_type> pfilter(
      std::function<int(const typename IIT::value_type&)> filter,
      const int thread_number = 8) const {
    auto data = toVector();
    const int size = sz(data);
    if (size == 0) {
      return vector<value_type>{};
    }

    vector<vector<value_type>> tmp(thread_number);
    vector<value_type> vec;
#if ENABLE_OPENMP
#pragma omp parallel for schedule(dynamic) num_threads(thread_number)
    for (int i = 0; i < size; ++i) {
      if (filter(data[i])) {
        const auto tid = ::tid();
        tmp[tid].push_back(std::move(data[i]));
      }
    }
    for (int i = 0; i < thread_number; ++i) {
      for (auto& iter : tmp[i]) {
        vec.push_back(std::move(iter));
      }
    }
#else
    for (int i = 0; i < size; ++i) {
      vec.push_back(std::move(data[i]));
    }
#endif
    return VectorRange<value_type>(std::move(vec));
  }

  // Recommendation:
  // 1. Use the template version and specify the result type (VT).
  // 2. Sepecify the return type of accumulator.
  // 3. If the accumulator and the combiner are the same, specify the return
  // type of combiner.

  // Name convention
  // i: inplace reduce
  // p: parallel reduce

  // Reducer versions.
  template <typename T>
  auto reduce(const T& reducer) const -> typename T::VT {
    using VT = typename T::VT;
    VT ret = reducer.init_value();
    auto now = static_cast<const DERIVED&>(*this).begin();
    auto x = static_cast<const DERIVED&>(*this).end();
    while (now != x) {
      reducer.accumulate(ret, std::move(*now++));
    }
    return ret;
  }

  template <typename T>
  auto preduce(const T& reducer, const int thread_number = 8) const ->
      typename T::VT {
#if ENABLE_OPENMP
    using VT = typename T::VT;
    auto data = toVector();
    const int size = sz(data);
    if (size == 0) {
      return reducer.init_value();
    }

    vector<VT> tmp(thread_number, reducer.init_value());
#pragma omp parallel for schedule(dynamic) num_threads(thread_number)
    for (int i = 0; i < size; ++i) {
      const auto tid = ::tid();
      reducer.accumulate(tmp[tid], std::move(data[i]));
    }

    VT ret = tmp[0];
    for (int i = 1; i < thread_number; ++i) {
      reducer.combine(ret, std::move(tmp[i]));
    }
    return ret;
#else
    return reduce(reducer);
#endif
  }

  // Sequential reduce
  // Template return value
  template <typename VT = value_type>
  VT reduce(
      const VT& v,
      const std::function<VT(const VT&, rvalue_reference)>& accumulator) const {
    VT ret = v;
    auto now = static_cast<const DERIVED&>(*this).begin();
    auto x = static_cast<const DERIVED&>(*this).end();
    while (now != x) {
      ret = accumulator(ret, std::move(*now++));
    }
    return ret;
  }

  template <typename VT = value_type>
  VT ireduce(
      const VT& v,
      const std::function<void(VT&, rvalue_reference)>& accumulator) const {
    VT ret = v;
    auto now = static_cast<const DERIVED&>(*this).begin();
    auto x = static_cast<const DERIVED&>(*this).end();
    while (now != x) {
      accumulator(ret, std::move(*now++));
    }
    return ret;
  }

  // Non-template return value
  value_type reduce(
      const value_type& v,
      const std::function<value_type(const value_type&, rvalue_reference)>&
          accumulator) const {
    value_type ret = v;
    auto now = static_cast<const DERIVED&>(*this).begin();
    auto x = static_cast<const DERIVED&>(*this).end();
    while (now != x) {
      ret = accumulator(ret, std::move(*now++));
    }
    return ret;
  }

  value_type ireduce(const value_type& v,
                     const std::function<void(value_type&, rvalue_reference)>&
                         accumulator) const {
    value_type ret = v;
    auto now = static_cast<const DERIVED&>(*this).begin();
    auto x = static_cast<const DERIVED&>(*this).end();
    while (now != x) {
      accumulator(ret, std::move(*now++));
    }
    return ret;
  }

  // Parallel reduce
  // Template return value, accumulator + combiner
  template <typename VT>
  VT preduce(const VT& v,
             const std::function<VT(const VT&, rvalue_reference)>& accumulator,
             const std::function<VT(const VT&, const VT&)>& combiner,
             const int thread_number = 8) const {
#if ENABLE_OPENMP
    auto data = toVector();
    const int size = sz(data);
    if (size == 0) {
      return v;
    }

    vector<VT> tmp(thread_number, v);
#pragma omp parallel for schedule(dynamic) num_threads(thread_number)
    for (int i = 0; i < size; ++i) {
      const auto tid = ::tid();
      tmp[tid] = accumulator(tmp[tid], std::move(data[i]));
    }

    VT ret = tmp[0];
    for (int i = 1; i < thread_number; ++i) {
      ret = combiner(ret, std::move(tmp[i]));
    }
    return ret;
#else
    return reduce(v, accumulator);
#endif
  }

  template <typename VT>
  VT pireduce(const VT& v,
              const std::function<void(VT&, rvalue_reference)>& accumulator,
              const std::function<void(VT&, const VT&)>& combiner,
              const int thread_number = 8) const {
#if ENABLE_OPENMP
    auto data = toVector();
    const int size = sz(data);
    if (size == 0) {
      return v;
    }

    vector<VT> tmp(thread_number, v);
#pragma omp parallel for schedule(dynamic) num_threads(thread_number)
    for (int i = 0; i < size; ++i) {
      const auto tid = ::tid();
      accumulator(tmp[tid], std::move(data[i]));
    }

    VT ret = tmp[0];
    for (int i = 1; i < thread_number; ++i) {
      combiner(ret, std::move(tmp[i]));
    }
    return ret;
#else
    return ireduce(v, accumulator);
#endif
  }

  // Non-template return value, accumulator + combiner
  value_type preduce(
      const value_type& v,
      const std::function<value_type(const value_type&, rvalue_reference)>&
          accumulator,
      const std::function<value_type(const value_type&, rvalue_reference)>&
          combiner,
      const int thread_number = 8) const {
#if ENABLE_OPENMP
    auto data = toVector();
    const int size = sz(data);
    if (size == 0) {
      return v;
    }

    vector<value_type> tmp(thread_number, v);
#pragma omp parallel for schedule(dynamic) num_threads(thread_number)
    for (int i = 0; i < size; ++i) {
      const auto tid = ::tid();
      tmp[tid] = accumulator(tmp[tid], std::move(data[i]));
    }

    value_type ret = tmp[0];
    for (int i = 1; i < thread_number; ++i) {
      ret = combiner(ret, std::move(tmp[i]));
    }
    return ret;
#else
    return reduce(v, accumulator);
#endif
  }

  value_type pireduce(
      const value_type& v,
      const std::function<void(value_type&, rvalue_reference)>& accumulator,
      const std::function<void(value_type&, rvalue_reference)>& combiner,
      const int thread_number = 8) const {
#if ENABLE_OPENMP
    auto data = toVector();
    const int size = sz(data);
    if (size == 0) {
      return v;
    }

    vector<value_type> tmp(thread_number, v);
#pragma omp parallel for schedule(dynamic) num_threads(thread_number)
    for (int i = 0; i < size; ++i) {
      const auto tid = ::tid();
      accumulator(tmp[tid], std::move(data[i]));
    }

    value_type ret = tmp[0];
    for (int i = 1; i < thread_number; ++i) {
      combiner(ret, std::move(tmp[i]));
    }
    return ret;
#else
    return ireduce(v, accumulator);
#endif
  }

#if PE_HAS_CPP14
  // Template return value, combiner
  template <typename VT>
  VT preduce(const VT& v,
             const std::function<VT(const VT&, const VT&)>& combiner,
             const int thread_number = 8) const {
    return preduce<VT>(v, combiner, combiner, thread_number);
  }

  value_type preduce(
      const value_type& v,
      const std::function<value_type(const value_type&, const value_type&)>&
          combiner,
      const int thread_number = 8) const {
    return preduce(v, combiner, combiner, thread_number);
  }

  // Non-template return value, combiner
  template <typename VT>
  VT pireduce(const VT& v, const std::function<void(VT&, const VT&)>& combiner,
              const int thread_number = 8) const {
    return pireduce<VT>(v, combiner, combiner, thread_number);
  }

  value_type pireduce(
      const value_type& v,
      const std::function<void(value_type&, const value_type&)>& combiner,
      const int thread_number = 8) const {
    return pireduce(v, combiner, combiner, thread_number);
  }
#endif

  template <typename TT>
  MappedRange<IIT, TT> map(
      std::function<TT(const typename IIT::value_type&)> mapper) const {
    return MappedRange<IIT, TT>{static_cast<const DERIVED&>(*this).begin(),
                                static_cast<const DERIVED&>(*this).end(),
                                mapper};
  }

  template <typename TT>
  VectorRange<TT> pmap(
      std::function<TT(const typename IIT::value_type&)> mapper,
      const int thread_number = 8) const {
    auto data = toVector();
    const int size = sz(data);
    if (size == 0) {
      return vector<TT>{};
    }

    vector<TT> vec(size);
#if ENABLE_OPENMP
#pragma omp parallel for schedule(dynamic) num_threads(thread_number)
#endif
    for (int i = 0; i < size; ++i) {
      vec[i] = mapper(std::move(data[i]));
    }

    return VectorRange<TT>(std::move(vec));
  }

  template <typename T>
  self_type& forEach(const T& action) {
    auto now = static_cast<const DERIVED&>(*this).begin();
    auto x = static_cast<const DERIVED&>(*this).end();
    while (now != x) {
      action(std::move(*now++));
    }
    return *this;
  }

  template <typename T>
  self_type& pforEach(const T& action, const int thread_number = 8) {
#if ENABLE_OPENMP
    auto data = toVector();
    const int size = sz(data);
    if (size == 0) {
      return *this;
    }

#pragma omp parallel for schedule(dynamic) num_threads(thread_number)
    for (int i = 0; i < size; ++i) {
      action(std::move(data[i]));
    }

    return *this;
#else
    return pforEach(action);
#endif
  }

  std::vector<value_type> toVector() const {
    std::vector<value_type> ret;
    auto now = static_cast<const DERIVED&>(*this).begin();
    auto x = static_cast<const DERIVED&>(*this).end();
    while (now != x) {
      ret.emplace_back(*now++);
    }
    return ret;
  }

  std::set<value_type> toSet() const {
    std::set<value_type> ret;
    auto now = static_cast<const DERIVED&>(*this).begin();
    auto x = static_cast<const DERIVED&>(*this).end();
    while (now != x) {
      ret.insert(*now++);
    }
    return ret;
  }

  IT b_;
  IT e_;
};

template <typename T>
struct NumberIter {
  using reference = const T;
  using value_type = T;

  T operator*() const { return i_; }

  int operator==(const NumberIter& o) const { return i_ == o.i_; }

  int operator!=(const NumberIter& o) const { return !(this->operator==(o)); }

  NumberIter& operator++() {
    ++i_;
    return *this;
  }

  NumberIter operator++(int) { return NumberIter{i_++}; }

  NumberIter& operator--() {
    --i_;
    return *this;
  }

  NumberIter operator--(int) { return NumberIter{i_--}; }

  T i_;
};

template <typename T>
struct NumberRange : public RangeBase<T, NumberRange<T>, NumberIter<T>> {
  using iterator = NumberIter<T>;
  using const_iterator = NumberIter<T>;
  using value_type = T;

  using base = RangeBase<T, NumberRange<T>, NumberIter<T>>;

  NumberRange(T b, T e) : base(b, e) {}

  NumberIter<T> begin() const { return NumberIter<T>{base::b_}; }
  NumberIter<T> end() const { return NumberIter<T>{base::e_}; }
};

template <typename T>
struct NumberIterD {
  using reference = const T;
  using value_type = T;

  T operator*() const { return i_; }

  int operator==(const NumberIterD& o) const { return i_ == o.i_; }

  int operator!=(const NumberIterD& o) const { return !(this->operator==(o)); }

  NumberIterD& operator++() {
    i_ += delta_;
    return *this;
  }

  NumberIterD operator++(int) {
    T x = i_;
    i_ += delta_;
    return NumberIterD{x};
  }

  NumberIterD& operator--() {
    i_ -= delta_;
    return *this;
  }

  NumberIterD operator--(int) {
    T x = i_;
    i_ -= delta_;
    return NumberIterD{x};
  }

  T i_;
  T e_;
  T delta_;
};

template <typename T>
struct NumberRangeD : public RangeBase<T, NumberRangeD<T>, NumberIter<T>> {
  using iterator = NumberIterD<T>;
  using const_iterator = NumberIterD<T>;
  using value_type = T;

  using base = RangeBase<T, NumberRangeD<T>, NumberIter<T>>;

  NumberRangeD(T b, T n, T delta_) : base(b, n), n_(n), delta_(delta_) {
    T d = abs(delta_);
    T r = abs(n - b);
    T s = r / d;
    base::e_ = b + s * delta_;
    if (r % d) {
      base::e_ += delta_;
    }
  }

  NumberIterD<T> begin() const {
    return NumberIterD<T>{base::b_, base::e_, delta_};
  }
  NumberIterD<T> end() const {
    return NumberIterD<T>{base::e_, base::e_, delta_};
  }

  T delta_;
  T n_;
};

template <typename T>
SL REQUIRES(is_native_integer<T>::value) RETURN(NumberRange<int64>)
    range(T s, T e) {
  PE_ASSERT(s <= e);
  return NumberRange<int64>{s, e};
}

template <typename T>
SL REQUIRES(is_native_integer<T>::value) RETURN(NumberRangeD<int64>)
    range(T s, T e, T delta_) {
  if (s < e) {
    PE_ASSERT(delta_ > 0);
  } else if (s > e) {
    PE_ASSERT(delta_ < 0);
  }
  return NumberRangeD<int64>{s, e, delta_};
}

template <typename IT>
struct RangeIter {
  using reference = typename IT::reference;
  using value_type = typename IT::value_type;

  reference operator*() { return *iter_; }

  int operator==(const RangeIter& o) const { return iter_ == o.iter_; }

  int operator!=(const RangeIter& o) const { return !(this->operator==(o)); }

  RangeIter& operator++() {
    ++iter_;
    return *this;
  }

  RangeIter operator++(int) { return RangeIter{iter_++}; }

  RangeIter& operator--() {
    --iter_;
    return *this;
  }

  RangeIter operator--(int) { return RangeIter{iter_--}; }

  IT iter_;
};

template <typename IT>
struct Range : public RangeBase<IT, Range<IT>, RangeIter<IT>> {
  using iterator = RangeIter<IT>;
  using const_iterator = RangeIter<IT>;
  using value_type = typename iterator::value_type;

  using base = RangeBase<IT, Range<IT>, RangeIter<IT>>;

  Range(IT b, IT e) : base(b, e) {}

  RangeIter<IT> begin() const { return RangeIter<IT>{base::b_}; }
  RangeIter<IT> end() const { return RangeIter<IT>{base::e_}; }
};

template <typename ET>
struct VectorRange
    : public RangeBase<typename vector<ET>::iterator, VectorRange<ET>,
                       RangeIter<typename vector<ET>::iterator>> {
  using IT = typename vector<ET>::iterator;
  using iterator = RangeIter<IT>;
  using const_iterator = RangeIter<IT>;
  using value_type = typename iterator::value_type;

  using base = RangeBase<IT, VectorRange<ET>, RangeIter<IT>>;

  VectorRange(const vector<ET>& vec) : vec_(vec) {
    base::b_ = vec_.begin();
    base::e_ = vec_.end();
  }

  VectorRange(vector<ET>&& vec) : vec_(std::move(vec)) {
    base::b_ = vec_.begin();
    base::e_ = vec_.end();
  }

  RangeIter<IT> begin() const { return RangeIter<IT>{base::b_}; }
  RangeIter<IT> end() const { return RangeIter<IT>{base::e_}; }

  vector<ET> vec_;
};

template <typename CT>
SL auto range(CT& v) -> Range<typename CT::iterator> {
  return Range<typename CT::iterator>{v.begin(), v.end()};
}

template <typename CT>
SL auto range(const CT& v) -> Range<typename CT::const_iterator> {
  return Range<typename CT::const_iterator>{v.begin(), v.end()};
}

template <typename T>
SL REQUIRES(!is_native_integer<T>::value) RETURN(Range<T>) range(T s, T e) {
  return Range<T>{s, e};
}

template <typename IT>
struct ArrayRangeIter {
  using reference = IT&;
  using value_type = IT;

  reference operator*() { return *iter_; }

  int operator==(const ArrayRangeIter& o) const { return iter_ == o.iter_; }

  int operator!=(const ArrayRangeIter& o) const {
    return !(this->operator==(o));
  }

  ArrayRangeIter& operator++() {
    ++iter_;
    return *this;
  }

  ArrayRangeIter operator++(int) { return ArrayRangeIter{iter_++}; }

  ArrayRangeIter& operator--() {
    --iter_;
    return *this;
  }

  ArrayRangeIter operator--(int) { return ArrayRangeIter{iter_--}; }

  IT* iter_;
};

template <typename IT>
struct ArrayRange : public RangeBase<IT*, ArrayRange<IT>, ArrayRangeIter<IT>> {
  using iterator = ArrayRangeIter<IT>;
  using const_iterator = ArrayRangeIter<IT>;
  using value_type = typename iterator::value_type;

  using base = RangeBase<IT*, ArrayRange<IT>, ArrayRangeIter<IT>>;

  ArrayRange(IT* b, IT* e) : base(b, e) {}

  ArrayRangeIter<IT> begin() const { return ArrayRangeIter<IT>{base::b_}; }
  ArrayRangeIter<IT> end() const { return ArrayRangeIter<IT>{base::e_}; }
};

template <typename T>
SL ArrayRange<T> range(T* s, T* e) {
  PE_ASSERT(s <= e);
  return ArrayRange<T>{s, e};
}

template <typename T>
SL ArrayRange<const T> range(const T* s, const T* e) {
  PE_ASSERT(s <= e);
  return ArrayRange<const T>{s, e};
}

template <typename T, int N>
SL ArrayRange<T> range(T (&a)[N]) {
  return ArrayRange<T>{a, a + N};
}

// IT: iterator type of source
// TT: type of the mapped result
template <typename IT, typename TT>
struct MappedRangeIter {
  using reference = TT;
  using value_type = TT;
  using src_type = typename IT::value_type;

  reference operator*() { return mapper(*iter_); }

  int operator==(const MappedRangeIter& o) const { return iter_ == o.iter_; }

  int operator!=(const MappedRangeIter& o) const {
    return !(this->operator==(o));
  }

  MappedRangeIter& operator++() {
    ++iter_;
    return *this;
  }

  MappedRangeIter operator++(int) { return MappedRangeIter{iter_++, mapper}; }

  MappedRangeIter& operator--() {
    --iter_;
    return *this;
  }

  MappedRangeIter operator--(int) { return MappedRangeIter{iter_--, mapper}; }

  IT iter_;
  const std::function<TT(const src_type& v)>& mapper;
};

template <typename IT, typename TT>
struct MappedRange
    : public RangeBase<IT, MappedRange<IT, TT>, MappedRangeIter<IT, TT>> {
  using iterator = MappedRangeIter<IT, TT>;
  using const_iterator = MappedRangeIter<IT, TT>;
  using value_type = typename iterator::value_type;

  using base = RangeBase<IT, MappedRange<IT, TT>, MappedRangeIter<IT, TT>>;

  MappedRange(IT b, IT e,
              const std::function<TT(
                  const typename MappedRangeIter<IT, TT>::src_type&)>& mapper)
      : base(b, e), mapper(mapper) {}

  MappedRangeIter<IT, TT> begin() const {
    return MappedRangeIter<IT, TT>{base::b_, mapper};
  }
  MappedRangeIter<IT, TT> end() const {
    return MappedRangeIter<IT, TT>{base::e_, mapper};
  }

  const std::function<TT(const typename MappedRangeIter<IT, TT>::src_type&)>
      mapper;
};

template <typename IT>
struct FilterRangeIter {
  using reference = typename IT::reference;
  using value_type = typename IT::value_type;

  reference operator*() { return *iter_; }

  int operator==(const FilterRangeIter& o) const { return iter_ == o.iter_; }

  int operator!=(const FilterRangeIter& o) const {
    return !(this->operator==(o));
  }

  FilterRangeIter& operator++() {
    while (iter_ != e_) {
      ++iter_;
      if (iter_ == e_) break;
      if (filter(*iter_)) break;
    }
    return *this;
  }

  FilterRangeIter operator++(int) {
    IT x = iter_;
    this->operator++();
    return FilterRangeIter{x, e_, filter};
  }

  IT iter_;
  IT e_;
  const std::function<int(const typename IT::value_type&)>& filter;
};

template <typename IT>
struct FilterRange
    : public RangeBase<IT, FilterRange<IT>, FilterRangeIter<IT>> {
  using iterator = FilterRangeIter<IT>;
  using const_iterator = FilterRangeIter<IT>;
  using value_type = typename FilterRangeIter<IT>::value_type;

  using base = RangeBase<IT, FilterRange<IT>, FilterRangeIter<IT>>;

  FilterRange(
      IT b, IT e,
      const std::function<int(const typename IT::value_type&)>& filterImpl)
      : base(b, e), filter_impl_(filterImpl) {}

  FilterRangeIter<IT> begin() const {
    auto now = base::b_;
    while (now != base::e_ && !filter_impl_(*now)) ++now;
    return FilterRangeIter<IT>{now, base::e_, filter_impl_};
  }

  FilterRangeIter<IT> end() const {
    return FilterRangeIter<IT>{base::e_, base::e_, filter_impl_};
  }

  const std::function<int(const typename IT::value_type&)> filter_impl_;
};

// irange support. i = index.
template <typename IT>
struct ContainerIterI {
  struct ContainerItemI {
    const int64 i;
    typename IT::reference v;
  };

  using reference = ContainerItemI;

  ContainerItemI operator*() { return ContainerItemI{idx_, *iter_}; }

  int operator==(const ContainerIterI& o) const { return iter_ == o.iter_; }

  int operator!=(const ContainerIterI& o) const {
    return !(this->operator==(o));
  }

  ContainerIterI& operator++() {
    ++idx_;
    ++iter_;
    return *this;
  }

  ContainerIterI operator++(int) { return ContainerIterI{iter_++, idx_++}; }

  ContainerIterI& operator--() {
    --idx_;
    --iter_;
    return *this;
  }

  ContainerIterI operator--(int) { return ContainerIterI{iter_--, idx_--}; }

  IT iter_;
  int64 idx_;
};

template <typename IT>
struct ContainerRangeI {
  using iterator = ContainerIterI<IT>;
  using const_iterator = ContainerIterI<IT>;

  ContainerIterI<IT> begin() const { return ContainerIterI<IT>{b_, 0}; }
  ContainerIterI<IT> end() const { return ContainerIterI<IT>{e_, 0}; }

  IT b_;
  IT e_;
};

template <typename T>
struct ArrayIterI {
  struct ContainerItemI {
    const int64 i;
    T& v;
  };

  using reference = ContainerItemI;

  ContainerItemI operator*() { return ContainerItemI{idx_, start_[idx_]}; }

  int operator==(const ArrayIterI& o) const {
    return idx_ == o.idx_ && start_ == o.start_;
  }

  int operator!=(const ArrayIterI& o) const { return !(this->operator==(o)); }

  ArrayIterI& operator++() {
    ++idx_;
    return *this;
  }

  ArrayIterI operator++(int) { return ArrayIterI{start_, idx_++}; }

  ArrayIterI& operator--() {
    --idx_;
    return *this;
  }

  ArrayIterI operator--(int) { return ArrayIterI{start_, idx_--}; }

  T* start_;
  int64 idx_;
};

template <typename T>
struct ArrayRangeI {
  using iterator = ArrayIterI<T>;
  using const_iterator = ArrayIterI<T>;

  ArrayIterI<T> begin() const { return ArrayIterI<T>{start_, 0}; }
  ArrayIterI<T> end() const { return ArrayIterI<T>{start_, cnt_}; }

  T* start_;
  int64 cnt_;
};

template <typename T>
SL ArrayRangeI<T> irange(vector<T>& v) {
  return ArrayRangeI<T>{&v[0], sz(v)};
}

template <typename T>
SL ArrayRangeI<const T> irange(const vector<T>& v) {
  return ArrayRangeI<const T>{&v[0], sz(v)};
}

template <typename T>
SL ArrayRangeI<T> irange(T* s, T* e) {
  PE_ASSERT(s <= e);
  return ArrayRangeI<T>{s, e - s};
}

template <typename T>
SL ArrayRangeI<const T> irange(const T* s, const T* e) {
  PE_ASSERT(s <= e);
  return ArrayRangeI<const T>{s, e - s};
}

template <typename T, int N>
SL ArrayRangeI<T> irange(T (&a)[N]) {
  return ArrayRangeI<T>{a, N};
}

template <typename CT>
SL auto irange(CT& v) -> ContainerRangeI<typename CT::iterator> {
  return ContainerRangeI<typename CT::iterator>{v.begin(), v.end()};
}

template <typename CT>
SL auto irange(const CT& v) -> ContainerRangeI<typename CT::const_iterator> {
  return ContainerRangeI<typename CT::const_iterator>{v.begin(), v.end()};
}

SL vector<pair<int64, int64>> make_segment(int64 s, int64 e, int64 b) {
  if (s > e) {
    return vector<pair<int64, int64>>();
  }
  int64 cnt = (e - s + 1 + b - 1) / b;
  vector<pair<int64, int64>> ret(cnt);
  int64 x = 0, y = s - 1;
  for (int64 i = 0; i < cnt; ++i) {
    x = y + 1;
    y += b;
    if (y > e) y = e;
    ret[i].first = x;
    ret[i].second = y;
  }
  return ret;
}
#endif