#ifndef PE_MOD_
#define PE_MOD_

#include "pe_base"
#include "pe_int128"
#include "pe_type_traits"

// Modular arithmetic
template <typename T, typename M>
SL REQUIRES((is_native_integer<T>::value && is_native_integer<M>::value &&
             std::is_signed<T>::value && std::is_signed<M>::value))
    RETURN_T(IntPromotionT(T, M)) regulate_mod(T a, M mod) {
  PE_ASSERT(mod >= 1);
  if (a >= 0) {
    return a >= mod ? a % mod : a;
  } else {
    auto tmp = a % mod;
    if (tmp < 0) tmp += mod;
    return tmp;
  }
}

template <typename T, typename M>
SL REQUIRES((is_native_integer<T>::value && is_native_integer<M>::value &&
             std::is_signed<T>::value && std::is_unsigned<M>::value))
    RETURN_T(IntPromotionT(T, M)) regulate_mod(T a, M mod) {
  PE_ASSERT(mod >= 1);
  if (a >= 0) {
    return a >= mod ? a % mod : a;
  } else {
    auto t = -a;
    if (t >= mod) t %= mod;
    return t == 0 ? 0 : mod - t;
  }
}

template <typename T, typename M>
SL REQUIRES((is_native_integer<T>::value && is_native_integer<M>::value &&
             std::is_unsigned<T>::value)) RETURN_T(IntPromotionT(T, M))
    regulate_mod(T a, M mod) {
  PE_ASSERT(mod >= 1);
  using ResultType = typename BiggerIntegralN<T, M>::type;
  ResultType b = a, m = mod;
  if (b >= m) b %= m;
  return b;
}

template <typename T>
SL REQUIRES((is_native_integer<T>::value)) RETURN(T) regulate_mod(T a, T mod) {
  return regulate_mod<T, T>(a, mod);
}

template <typename T, typename M>
SL REQUIRES((is_native_integer<T>::value && is_native_integer<M>::value))
    RETURN_T(IntPromotionT(T, M)) add_mod_impl(T a, T b, M mod) {
  using ResultType = typename BiggerIntegralN<T, M>::type;
#if 0
  auto t0 = a;
  t0 += b;
  ResultType t1 = t0, m = mod;
  if (t1 >= m) t1 -= m;
  return t1;
#else
  ResultType a0 = a, b0 = b, m0 = mod;
  a0 += b0;
  if (a0 >= m0) a0 -= m0;
  return a0;
#endif
}

template <typename T1, typename T2, typename M>
SL REQUIRES((is_native_integer<T1>::value && is_native_integer<T2>::value &&
             is_native_integer<M>::value)) RETURN_T(IntPromotionT(T1, T2, M))
    add_mod(T1 a, T2 b, M mod) {
  using T = typename BiggerIntegralN<T1, T2>::type;
  return add_mod_impl<T, M>(a, b, mod);
}

template <typename T, typename M>
SL REQUIRES((is_native_integer<T>::value && is_native_integer<M>::value))
    RETURN(IntPromotion(T, M)) sub_mod_impl(T a, T b, M mod) {
  return a >= b ? a - b : mod - b + a;
}

template <typename M, typename T>
SL T sum_mod(M /*mod*/, T a) {
  return a;
}

template <typename M, typename TH, typename... TT>
SL IntPromotion(TH, TT...) sum_mod(M mod, TH a, TT... b) {
  return add_mod(a, sum_mod(mod, b...), mod);
}

template <typename M, typename T>
SL REQUIRES(is_native_integer<T>::value) RETURN(T)
    sum_mod(M mod, std::initializer_list<T> init) {
  T ret = 0;
  for (auto& v : init) {
    ret = add_mod(ret, v, mod);
  }
  return ret;
}

template <typename T1, typename T2, typename M>
SL REQUIRES((is_native_integer<T1>::value && is_native_integer<T2>::value &&
             is_native_integer<M>::value)) RETURN_T(IntPromotionT(T1, T2, M))
    sub_mod(T1 a, T2 b, M mod) {
  using T = typename BiggerIntegralN<T1, T2>::type;
  return sub_mod_impl<T, M>(a, b, mod);
}

template <typename T, typename M>
SL REQUIRES((is_native_integer<T>::value && is_native_integer<M>::value))
    RETURN_T(IntPromotionT(T, M)) mul_mod_impl(T a, T b, M mod) {
  return a * b % mod;
}

template <typename T1, typename T2, typename M>
SL REQUIRES((is_native_integer<T1>::value && is_native_integer<T2>::value &&
             is_native_integer<M>::value))
    RETURN_T(IntPromotionT(T1, T2, int64, M)) mul_mod(T1 a, T2 b, M mod) {
  using T = typename BiggerIntegralN<T1, T2>::type;
  using atLeastInt64T = typename AtLeastInt64<T>::type;
  return mul_mod_impl<atLeastInt64T, M>(a, b, mod);
}

template <typename M, typename T>
SL T prod_mod(M /*mod*/, T a) {
  return a;
}

template <typename M, typename TH, typename... TT>
SL IntPromotion(TH, TT...) prod_mod(M mod, TH a, TT... b) {
  return mul_mod(a, prod_mod(mod, b...), mod);
}

template <typename M, typename T>
SL REQUIRES(is_native_integer<T>::value) RETURN(T)
    prod_mod(M mod, std::initializer_list<T> init) {
  T ret = 1;
  if (mod == 1) {
    return 0;
  }
  for (auto& v : init) {
    ret = mul_mod(ret, v, mod);
  }
  return ret;
}

#if PE_HAS_INT128
SL uint64 mod128_64(uint128 a, uint64 b) {
#if defined(COMPILER_GNU) && PE_X86_64
  // Note: if a / b > uint64_max, an exception is thrown.
  uint64 q, r;
  __asm__("divq\t%4"
          : "=a"(q), "=d"(r)
          : "0"(uint64(a)), "1"(uint64(a >> 64)), "rm"(b));
  return r;
#else
  return a % b;
#endif
}
#endif

#if defined(COMPILER_GNU) && PE_X86_64
template <typename T>
SL REQUIRES((is_native_integer<T>::value && is_unsigned<T>::value))
    RETURN(uint64) mul_mod_ex_dis(uint64 a, uint64 b, uint64 mod) {
  if (mod >> 32) {
    uint64 q, r;
    __asm__(
        "movq %2,%%rax\n\t"
        "mulq %3\n\t"
        "divq %4\n\t"
        : "=a"(q), "=d"(r)
        : "0"(uint64(a)), "1"(uint64(b)), "rm"(uint64(mod)));
    return r;
  } else {
    uint32 q, r;
    __asm__(
        "movl %2,%%eax\n\t"
        "mull %3\n\t"
        "divl %4\n\t"
        : "=a"(q), "=d"(r)
        : "0"(uint32(a)), "1"(uint32(b)), "rm"(uint32(mod)));
    return r;
  }
}

template <typename T>
SL REQUIRES((is_native_integer<T>::value && is_signed<T>::value)) RETURN(int64)
    mul_mod_ex_dis(int64 a, int64 b, int64 mod) {
  if (static_cast<uint64>(mod) >> 31) {
    int64 q, r;
    __asm__(
        "movq %2,%%rax\n\t"
        "imulq %3\n\t"
        "idivq %4\n\t"
        : "=a"(q), "=d"(r)
        : "0"(a), "1"(b), "rm"(mod));
    return r;
  } else {
    int32 q, r;
    __asm__(
        "movl %2,%%eax\n\t"
        "imull %3\n\t"
        "idivl %4\n\t"
        : "=a"(q), "=d"(r)
        : "0"(int32(a)), "1"(int32(b)), "rm"(int32(mod)));
    return r;
  }
}
#endif

SL void mul_mod_ex_slow_warning_once() {
  static atomic_int WARNING_ONCE_FLAG{0};
  if (WARNING_ONCE_FLAG.exchange(1) == 0) {
    fprintf(stderr, "mul_mod_ex may be very slow.\n");
  }
}

#if defined(COMPILER_MSVC) && PLATFORM_WIN && PE_X86_64

extern "C" {
typedef uint64 (*MulModFunctionPointerType)(uint64, uint64, uint64);
}

#if 0
.CODE

MulModShellCode PROC
	mov rax, rcx
	mul rdx
    div r8
	mov rax, rdx
    ret
MulModShellCode ENDP

END
#endif
const char __MulModShellCode[] =
    "\x48\x8b\xc1\x48\xf7\xe2\x49\xf7\xf0\x48\x8b\xc2\xc3";
int __MakeMulModShellCodeExecutable() {
  DWORD dwOld = 0;
  VirtualProtect((void*)__MulModShellCode, sizeof(__MulModShellCode),
                 PAGE_EXECUTE_READWRITE, &dwOld);
  return 0;
}
const static int __init_code_data_once = __MakeMulModShellCodeExecutable();
#endif

template <typename T1, typename T2, typename M>
SL REQUIRES((is_native_integer<T1>::value && is_native_integer<T2>::value &&
             is_native_integer<M>::value))
    RETURN_T(IntPromotionT(T1, T2, int64, M)) mul_mod_ex(T1 a, T2 b, M mod) {
  using T = typename BiggerIntegralN<T1, T2>::type;
  using atLeastInt64T = typename AtLeastInt64<T>::type;
  using ResultType = typename BiggerIntegralN<atLeastInt64T, T>::type;

#if defined(COMPILER_GNU) && PE_X86_64
  // We have a disassembly version
  return (ResultType)mul_mod_ex_dis<ResultType>(a, b, mod);
#else
  if (mod <= PE_SOI63) {
    return mul_mod_impl<atLeastInt64T, M>(a, b, mod);
  }
#if PE_HAS_INT128
  return (ResultType)mul_mod_impl<int128, M>(a, b, mod);
#else

  // The openmp has issue about long double on windows.
  // Seems caused by thread library.
  // https://sourceforge.net/p/mingw-w64/bugs/678/
#if defined(COMPILER_GNU) && PLATFORM_WIN && ENABLE_OPENMP
  constexpr bool GNU_ON_WINDOWS_WITH_OPENMP = true;
#else
  constexpr bool GNU_ON_WINDOWS_WITH_OPENMP = false;
#endif
  constexpr bool CAN_USE_LONG_DOUBLE =
      sizeof(long double) > sizeof(double) && !GNU_ON_WINDOWS_WITH_OPENMP;

  if (CAN_USE_LONG_DOUBLE) {
    const int64 x = a, y = b, m = mod;
    int64 r = (x * y - (int64)(((long double)x * y) / m) * m);
    if (r >= m) r -= r / m * m;
    if (r < 0) r += m;
    return r;
  }

#if defined(COMPILER_MSVC) && PLATFORM_WIN && PE_X86_64
  return (ResultType)((MulModFunctionPointerType)(
      unsigned char*)__MulModShellCode)((uint64)a, (uint64)b, (uint64)mod);
#endif

  mul_mod_ex_slow_warning_once();
// 3 other implementations
#if 0
  // Mpz based implementation
  // GMP_LIMB_BITS == 64 and GMP_NAIL_BITS == 0
  mpz_t A;
  mpz_init2(A, 64);
  mpz_t B;
  mpz_init2(B, 64);
  A[0]._mp_size = 1;
  A[0]._mp_d[0] = a;

  B[0]._mp_size = 1;
  B[0]._mp_d[0] = b;

  mpz_t M;
  mpz_init2(M, 64);
  M[0]._mp_size = 1;
  M[0]._mp_d[0] = mod;

  mpz_mul(A, A, B);
  mpz_mod(A, A, M);

  auto ret = A[0]._mp_d[0];
  mpz_clear(A);
  mpz_clear(B);
  mpz_clear(M);
  return ret;
#elif 1
  const uint64 ua = static_cast<uint64>(a);
  const uint64 ub = static_cast<uint64>(b);
  const uint64 umod = static_cast<uint64>(mod);
  if (ua == 0 || ub == 0) {
    return 0;
  }
  if (ua <= ub) {
    uint64 ret = 0;
    int used = pe_clzll(ua);
    const int d = pe_clzll(ub);
    const uint64 mask = (1ULL << d) - 1;
    while (used < 64) {
      const int now = min(64 - used, d);
      const uint64 t0 = (ua >> (64 - used - now)) & mask;
      const uint64 t1 = t0 * ub % umod;
      ret = (ret << now) % umod;
      ret += t1;
      if (ret >= umod) ret -= umod;
      used += now;
    }
    return ret;
  } else {
    uint64 ret = 0;
    int used = pe_clzll(ub);
    const int d = pe_clzll(ua);
    const uint64 mask = (1ULL << d) - 1;
    while (used < 64) {
      const int now = min(64 - used, d);
      const uint64 t0 = (ub >> (64 - used - now)) & mask;
      const uint64 t1 = t0 * ua % umod;
      ret = (ret << now) % umod;
      ret += t1;
      if (ret >= umod) ret -= umod;
      used += now;
    }
    return ret;
  }
#elif 0
  atLeastInt64T ret = 0;
  atLeastInt64T flag = b;
  for (atLeastInt64T d = 1; d <= (atLeastInt64T)a; d <<= 1) {
    if (d & a) {
      ret = (ret + flag) % mod;
    }
    flag = (flag << 1) % mod;
  }
  return (ResultType)ret;
#endif

#endif

#endif
}

template <typename M, typename T>
SL T prod_mod_ex(M /*mod*/, T a) {
  return a;
}

template <typename M, typename TH, typename... TT>
SL IntPromotion(TH, TT...) prod_mod_ex(M mod, TH a, TT... b) {
  return mul_mod_ex(a, prod_mod_ex(mod, b...), mod);
}

template <typename M, typename T>
SL REQUIRES(is_native_integer<T>::value) RETURN(T)
    prod_mod_ex(M mod, std::initializer_list<T> init) {
  T ret = 1;
  if (mod == 1) {
    return 0;
  }
  for (auto& v : init) {
    ret = mul_mod_ex(ret, v, mod);
  }
  return ret;
}

template <typename T1, typename T2, typename M>
SL REQUIRES((is_native_integer<T1>::value && is_native_integer<T2>::value &&
             is_native_integer<M>::value)) RETURN_T(IntPromotionT(T1, M))
    power_mod_impl(T1 x, T2 n, M mod) {
  if (mod == 1) return 0;
  using ResultType = typename BiggerIntegralN<T1, M>::type;

  ResultType ret = 1;
  auto y = regulate_mod(x, mod);
  for (; n; n >>= 1) {
    if (n & 1) ret = mul_mod(ret, y, mod);
    y = mul_mod(y, y, mod);
  }
  return ret;
}

template <typename T1, typename T2, typename M>
SL REQUIRES((is_native_integer<T1>::value && is_native_integer<T2>::value &&
             is_native_integer<M>::value)) RETURN_T(IntPromotionT(T1, int64, M))
    power_mod(T1 x, T2 n, M mod) {
  using atLeastInt64T1 = typename AtLeastInt64<T1>::type;
  return power_mod_impl<atLeastInt64T1, T2, M>(x, n, mod);
}

template <typename T1, typename T2, typename M>
SL REQUIRES((is_native_integer<T1>::value && is_native_integer<T2>::value &&
             is_native_integer<M>::value)) RETURN_T(IntPromotionT(T1, M))
    power_mod_ex_impl(T1 x, T2 n, M mod) {
  if (mod == 1) return 0;
  using ResultType = typename BiggerIntegralN<T1, M>::type;

  ResultType ret = 1;
  auto y = regulate_mod(x, mod);
  for (; n; n >>= 1) {
    if (n & 1) ret = mul_mod_ex(ret, y, mod);
    y = mul_mod_ex(y, y, mod);
  }
  return ret;
}

template <typename T1, typename T2, typename M>
SL REQUIRES((is_native_integer<T1>::value && is_native_integer<T2>::value &&
             is_native_integer<M>::value)) RETURN_T(IntPromotionT(T1, int64, M))
    power_mod_ex(T1 x, T2 n, M mod) {
  using atLeastInt64T1 = typename AtLeastInt64<T1>::type;
  return power_mod_ex_impl<atLeastInt64T1, T2, M>(x, n, mod);
}

template <typename T, typename M>
SL REQUIRES((is_native_integer<T>::value && is_native_integer<M>::value))
    RETURN_T(IntPromotionT(T, M))
        frac_mod_impl(const std::vector<T>& a, std::vector<T> b, M mod) {
  using ResultType = typename BiggerIntegralN<T, M>::type;
  ResultType ret = 1;
  const int size = b.size();
  int remain = size;
  for (auto iter : a) {
    for (int i = 0; iter > 1 && remain > 0 && i < size; ++i) {
      if (b[i] == 1) continue;
      while (b[i] != 1 && iter != 1) {
        ResultType d = gcd(iter, b[i]);
        if (d == 1) {
          break;
        }
        iter /= d;
        b[i] /= d;
      }
      if (b[i] == 1) {
        --remain;
      }
    }
    ret = mul_mod(ret, iter % mod, mod);
  }
  return ret;
}

template <typename T1, typename T2 = T1, typename M>
SL REQUIRES((is_native_integer<T1>::value && is_native_integer<T2>::value &&
             is_native_integer<M>::value))
    RETURN_T(IntPromotionT(T1, T2, int64, M))
        frac_mod(const std::vector<T1>& a, const std::vector<T2>& b, M mod) {
  using T = typename BiggerIntegralN<T1, T2>::type;
  using atLeastInt64T = typename AtLeastInt64<T>::type;
  return frac_mod_impl<atLeastInt64T, M>(
      vector<atLeastInt64T>(a.begin(), a.end()),
      vector<atLeastInt64T>(b.begin(), b.end()), mod);
}

// Sum of 1 + 2 + 3 + ... + n
SL int64 ap_sum_mod(int64 n, int64 mod) {
  if (n == 0) return 0;
  if (n < 0) return regulate_mod(-ap_sum_mod(-n, mod), mod);
  return n & 1 ? mul_mod_ex(((n + 1) >> 1) % mod, n, mod)
               : mul_mod_ex((n >> 1) % mod, (n + 1) % mod, mod);
}

// Sum of arithmetic progression
// a <= a, a + delta, a + 2 delta, ..., a + maxk detla <= b for delta >= 0 or
// a >= a, a + delta, a + 2 delta, ..., a + maxk delta >= b for delta < 0
SL int64 ap_sum_mod(int64 a, int64 b, int64 mod, int64 delta = 1) {
  if (delta == 0) {
    PE_ASSERT(a == b);
    return a;
  }
  if (delta > 0 && a > b) return 0;
  if (delta < 0 && a < b) return 0;
  const int64 maxk = (b - a) / delta;
  PE_ASSERT(maxk >= 0);
  const int64 t0 = mul_mod_ex((maxk + 1) % mod, regulate_mod(a, mod), mod);
  // delta, 2 delta, maxk delta
  const int64 t1 =
      mul_mod_ex(regulate_mod(delta, mod), ap_sum_mod(maxk, mod), mod);
  return add_mod(t0, t1, mod);
}

// Sum of 1^2 + 2^2 + 3^2 + ... + n^2
// Assume no overflow for 2 * n + 1
SL int64 square_sum_mod(int64 n, int64 mod) {
  if (n <= 0) return 0;
  // n*(n + 1)*(2 n + 1)/6
  int64 a = n, b = n + 1, c = 2 * n + 1;
  switch (n % 6) {
    case 0:
      a /= 6;
      break;
    case 1:
      b >>= 1, c /= 3;
      break;
    case 2:
      a >>= 1, b /= 3;
      break;
    case 3:
      a /= 3, b >>= 1;
      break;
    case 4:
      a >>= 1, c /= 3;
      break;
    case 5:
      b /= 6;
      break;
  }
  return mul_mod_ex(a % mod, mul_mod_ex(b % mod, c % mod, mod), mod);
}

// Sum of 1^3 + 2^3 + 3^3 + ... + n^3
SL int64 cube_sum_mod(int64 n, int64 mod) {
  if (n <= 0) return 0;
  // (n*(n + 1)/2)^2
  const int64 a = ap_sum_mod(n, mod);
  return mul_mod_ex(a, a, mod);
}

// Sum of 1^4 + 2^4 + 3^4 + ... + n^4
// Assume no overflow for 2 * n
SL int64 quad_sum_mod(int64 n, int64 mod) {
  if (n <= 0) return 0;
  // (3*n*(n + 1) - 1)*(2*n + 1)*(n + 1)*n/30
  // Handle (2*n + 1)*(n + 1)*n/6
  int64 a = n, b = n + 1, c = 2 * n + 1;
  switch (n % 6) {
    case 0:
      a /= 6;
      break;
    case 1:
      b >>= 1, c /= 3;
      break;
    case 2:
      a >>= 1, b /= 3;
      break;
    case 3:
      a /= 3, b >>= 1;
      break;
    case 4:
      a >>= 1, c /= 3;
      break;
    case 5:
      b /= 6;
      break;
  }
  int done = 0;
  if (!done && a % 5 == 0) a /= 5, done = 1;
  if (!done && b % 5 == 0) b /= 5, done = 1;
  if (!done && c % 5 == 0) c /= 5, done = 1;
  const int64 d = mul_mod_ex(a % mod, mul_mod_ex(b % mod, c % mod, mod), mod);
  if (done) {
    const int64 t0 = mul_mod_ex(n % mod, (n + 1) % mod, mod);
    const int64 t1 = sub_mod(mul_mod_ex(3LL, t0, mod), 1, mod);
    return mul_mod_ex(d, t1, mod);
  }
  // Handle (3*n*n + 3*n - 1)/5
  switch (n % 5) {
    // 3*n*n + 3*n - 1 =
    // 3*(n - 1)*(n - 1) + 5*n + 4*(n - 1)
    // (n - 1)*(3*(n - 1) + 4) + 5*n
    // (n - 1)*(3 n + 1) + 5*n
    case 1: {
      const int64 t0 = add_mod(mul_mod_ex(3LL, n, mod), 1, mod);
      const int64 t1 =
          add_mod(mul_mod_ex((n - 1) / 5 % mod, t0, mod), n % mod, mod);
      return mul_mod_ex(d, t1, mod);
    }
    // 3*n*n + 3*n - 1 =
    // 3*(n - 3)*(n - 3) + 7*(3*n - 4)
    // 3*(n - 3)*(n - 3) + 7*(3*(n - 3) + 5)
    // 3*(n - 3)*(n - 3) + 7*3*(n - 3) + 35
    // 3*(n - 3)*(n + 4) + 35
    case 3: {
      const int64 t0 = mul_mod_ex(
          3LL, mul_mod_ex((n - 3) / 5 % mod, (n + 4) % mod, mod), mod);
      const int64 t1 = add_mod(t0, 7, mod);
      return mul_mod_ex(d, t1, mod);
    }
    default:
      PE_ASSERT(0);
  }
  return 0;
}

// Sum of 1^5 + 2^5 + 3^5 + ... + n^5
// Assume no overflow for 2 * n
SL int64 pent_sum_mod(int64 n, int64 mod) {
  if (n <= 0) return 0;
  // n^2*(n + 1)^2*(2*n^2 + 2*n - 1)/12
  // Handle (n (n + 1))^2/4
  int64 a = n, b = n, c = n + 1, d = n + 1;
  if (n % 2 == 0) {
    a >>= 1, b >>= 1;
  } else {
    c >>= 1, d >>= 1;
  }
  int done = 0;
  if (!done && a % 3 == 0) a /= 3, done = 1;
  if (!done && c % 3 == 0) c /= 3, done = 1;
  const int64 e = mul_mod_ex(mul_mod_ex(a % mod, b % mod, mod),
                             mul_mod_ex(c % mod, d % mod, mod), mod);
  if (done) {
    const int64 t0 = add_mod(n, n, mod);
    const int64 t1 = mul_mod_ex(t0, n, mod);
    const int64 t2 = sub_mod(add_mod(t0, t1, mod), 1, mod);
    return mul_mod_ex(e, t2, mod);
  }
  // Handle (2*n^2 + 2*n - 1)/3
  // We have n%3 = 1
  // 2*n^2 + 2*n - 1 = 2*(n-1)^2 + 6n - 3
  const int64 t0 = mul_mod_ex((n - 1) / 3 % mod, (n - 1) % mod, mod);
  const int64 t1 = add_mod(add_mod(t0, t0, mod), (2 * n - 1) % mod, mod);
  return mul_mod_ex(e, t1, mod);
}

// Sum of 1^6 + 2^6 + 3^6 + ... + n^6
// Assume no overflow for 2 * n
SL int64 hexa_sum_mod(int64 n, int64 mod) {
  if (n <= 0) return 0;
  // n*(1 + n)*(1 + 2*n)*(1 - 3*n + 6*n^3 + 3*n^4)/42
  // Handle n*(1 + n)*(1 + 2*n)/6
  // n*(n + 1)*(2*n + 1)/6
  int64 a = n, b = n + 1, c = 2 * n + 1;
  switch (n % 6) {
    case 0:
      a /= 6;
      break;
    case 1:
      b >>= 1, c /= 3;
      break;
    case 2:
      a >>= 1, b /= 3;
      break;
    case 3:
      a /= 3, b >>= 1;
      break;
    case 4:
      a >>= 1, c /= 3;
      break;
    case 5:
      b /= 6;
      break;
  }
  int done = 0;
  if (!done && a % 7 == 0) a /= 7, done = 1;
  if (!done && b % 7 == 0) b /= 7, done = 1;
  if (!done && c % 7 == 0) c /= 7, done = 1;
  const int64 d = mul_mod_ex(a % mod, mul_mod_ex(b % mod, c % mod, mod), mod);
  if (done) {
    const int64 n1 = n % mod;
    const int64 n2 = mul_mod_ex(n1, n1, mod);
    const int64 n3 = mul_mod_ex(n1, n2, mod);
    const int64 n4 = mul_mod_ex(n2, n2, mod);
    const int64 t0 = sub_mod(add_mod(n4, 2 * n3 % mod, mod), n1, mod);
    const int64 t1 = add_mod(mul_mod_ex(3, t0, mod), 1, mod);
    return mul_mod_ex(d, t1, mod);
  }
  // Handle (1 - 3*n + 6*n^3 + 3*n^4)/7
  const int64 n1 = n % mod;
  const int64 n2 = mul_mod_ex(n1, n1, mod);
  const int64 n3 = mul_mod_ex(n1, n2, mod);
  switch (n % 7) {
    // 3*(2 + 3*n + 3*n^2 + n^3)*(n - 1) + 7
    case 1: {
      const int64 t0 = add_mod(2LL, mul_mod_ex(3LL, n1, mod), mod);
      const int64 t1 = add_mod(mul_mod_ex(3LL, n2, mod), n3, mod);
      const int64 t2 = mul_mod_ex(mul_mod_ex(3LL, add_mod(t0, t1, mod), mod),
                                  (n - 1) / 7 % mod, mod);
      const int64 t3 = add_mod(t2, 1, mod);
      return mul_mod_ex(d, t3, mod);
    }
    // 3*(15 + 8*n + 4*n^2 + n^3)*(n - 2) + 91
    case 2: {
      const int64 t0 = add_mod(15LL, mul_mod_ex(8LL, n1, mod), mod);
      const int64 t1 = add_mod(mul_mod_ex(4LL, n2, mod), n3, mod);
      const int64 t2 = mul_mod_ex(mul_mod_ex(3LL, add_mod(t0, t1, mod), mod),
                                  (n - 2) / 7 % mod, mod);
      const int64 t3 = add_mod(t2, 13LL, mod);
      return mul_mod_ex(d, t3, mod);
    }
    // 3*(-10 + 3 n - n^2 + n^3)*(n + 3) + 91
    case 4: {
      const int64 t0 = sub_mod(mul_mod_ex(3LL, n1, mod), 10LL, mod);
      const int64 t1 = sub_mod(n3, n2, mod);
      const int64 t2 = mul_mod_ex(mul_mod_ex(3LL, add_mod(t0, t1, mod), mod),
                                  (n + 3) / 7 % mod, mod);
      const int64 t3 = add_mod(t2, 13LL, mod);
      return mul_mod_ex(d, t3, mod);
    }
    // 3*(-1 + n^3)*(n + 2) + 7
    case 5: {
      const int64 t0 = mul_mod_ex(3LL, sub_mod(n3, 1LL, mod), mod);
      const int64 t1 = mul_mod_ex(t0, (n + 2) / 7 % mod, mod);
      const int64 t2 = add_mod(t1, 1LL, mod);
      return mul_mod_ex(d, t2, mod);
    }
    default:
      PE_ASSERT(0);
  }
  return 0;
}

// Sum of 1^7 + 2^7 + 3^7 + ... + n^7
// Assume no overflow for 2 * n
SL int64 hept_sum_mod(int64 n, int64 mod) {
  if (n <= 0) return 0;
  // n^2 * (1 + n)^2 * (2 - 4 n - n^2 + 6 n^3 + 3 n^4)/24
  // Handle (n (n + 1))^2/4
  int64 a = n, b = n, c = n + 1, d = n + 1;
  if (n % 2 == 0) {
    a >>= 1, b >>= 1;
  } else {
    c >>= 1, d >>= 1;
  }
  int done3 = 0;
  if (!done3 && a % 3 == 0) a /= 3, done3 = 1;
  if (!done3 && c % 3 == 0) c /= 3, done3 = 1;
  // Handle (2 - 4 n - n^2 + 6 n^3 + 3 n^4)/6
  // Expand[1/6 (2 - 4 n - n^2 + 6 n^3 + 3 n^4) /. {n -> 6 k + f}]
  // 1/3 - (2 f)/3 - f^2/6 + f^3 + f^4/2 - 4 k - 2 f k + 18 f^2 k +
  // 12 f^3 k - 6 k^2 + 108 f k^2 + 108 f^2 k^2 + 216 k^3 + 432 f k^3 +
  // 648 k^4
  const int64 k = n / 6;
  const int64 k1 = k % mod;
  const int64 k2 = mul_mod_ex(k1, k1, mod);
  const int64 k3 = mul_mod_ex(k2, k1, mod);
  const int64 k4 = mul_mod_ex(k2, k2, mod);
  const int64 f1 = n % 6;
  const int64 f2 = f1 * f1;
  const int64 f3 = f2 * f1;
  const int64 f4 = f2 * f2;
  int64 t0 = sub_mod(0LL, mul_mod_ex(4LL, k1, mod), mod);
  t0 = sub_mod(t0, mul_mod_ex(2LL, mul_mod_ex(f1, k1, mod), mod), mod);
  t0 = add_mod(t0, mul_mod_ex(18LL, mul_mod_ex(f2, k1, mod), mod), mod);
  t0 = add_mod(t0, mul_mod_ex(12LL, mul_mod_ex(f3, k1, mod), mod), mod);
  t0 = sub_mod(t0, mul_mod_ex(6LL, k2, mod), mod);
  t0 = add_mod(t0, mul_mod_ex(108LL, mul_mod_ex(f1, k2, mod), mod), mod);
  t0 = add_mod(t0, mul_mod_ex(108LL, mul_mod_ex(f2, k2, mod), mod), mod);
  t0 = add_mod(t0, mul_mod_ex(216LL, k3, mod), mod);
  t0 = add_mod(t0, mul_mod_ex(432LL, mul_mod_ex(f1, k3, mod), mod), mod);
  t0 = add_mod(t0, mul_mod_ex(648LL, k4, mod), mod);
  if (done3) {
    t0 = mul_mod_ex(3LL, t0, mod);
  }
  const int64 t1 = (3 * f4 + 6 * f3 - f2 - 4 * f1 + 2) / (done3 ? 2 : 6) % mod;
  const int64 t2 = mul_mod_ex(mul_mod_ex(a % mod, b % mod, mod),
                              mul_mod_ex(c % mod, d % mod, mod), mod);
  return mul_mod_ex(add_mod(t0, t1, mod), t2, mod);
}

#define p1_sum_mod ap_sum_mod
#define p2_sum_mod square_sum_mod
#define p3_sum_mod cube_sum_mod
#define p4_sum_mod quad_sum_mod
#define p5_sum_mod pent_sum_mod
#define p6_sum_mod hexa_sum_mod
#define p7_sum_mod hept_sum_mod

#if 0
// Sum of geometric progression
// (x^a+x^(a+1)+x^(a+2)+...+x^b) % mod
// a >= 0
// zeroPzero: 0^0
// if b < a: return 0
SL int64 gp_sum_mod(int64 x, int64 a, int64 b, int64 mod, int64 zeroPzero = 1) {
  if (mod == 1) return 0;
  if (b < a) return 0;
  x %= mod;
  if (a > 0 || x > 0) {
    if (x == 0) return 0;
    if (x == 1) return (b - a + 1) % mod;
    // (x^(b+1)-x^a) / (x - 1)
    const int64 u = power_mod_ex(x, b + 1, mod);
    const int64 v = power_mod_ex(x, a, mod);
    const int64 w = sub_mod(u, v, mod);
    const int64 t = inv_of(sub_mod(x, 1, mod), mod);
    return mul_mod_ex(w, t, mod);
  }
  // a == 0 and x == 0
  return zeroPzero % mod;
}

SL int64 gp_sum_mod_ivx1(int64 x, int64 invXSub1, int64 a, int64 b, int64 mod,
                         int64 zeroPzero = 1) {
  if (mod == 1) return 0;
  if (b < a) return 0;
  x %= mod;
  if (a > 0 || x > 0) {
    if (x == 0) return 0;
    if (x == 1) return (b - a + 1) % mod;
    // (x^(b+1)-x^a) / (x - 1)
    const int64 u = power_mod_ex(x, b + 1, mod);
    const int64 v = power_mod_ex(x, a, mod);
    const int64 w = sub_mod(u, v, mod);
    return mul_mod_ex(w, invXSub1, mod);
  }
  // a == 0 and x == 0
  return zeroPzero % mod;
}

// Sum of geometric progression
// (x^a+x^(a+1)+x^(a+2)+...+x^b) % mod
// a >= 0
// zeroPzero: 0^0
// if b < a: return 0
SL int64 gp_sum_mod(int64 x, int64 a, int64 b, int64 mod,
                    int64 zero_p_zero = 1) {
  if (mod == 1 || b < a) return 0;
  if (b < a) return 0;
  x %= mod;
  // |x 0|^(b-a) x^a
  // |x 1|       x^a
  int64 data[3][2][2] = {0};
  auto* m = data[0];
  auto* r = data[1];
  auto* t = data[2];
  m[0][0] = x;
  m[1][0] = x;
  m[1][1] = 1;
  r[0][0] = a == 0 && x == 0 ? zero_p_zero : power_mod_ex(x, a, mod);
  r[1][0] = r[0][0];
  for (int64 n = b - a; n > 0; n >>= 1) {
    if (n & 1) {
      for (int i = 0; i < 2; ++i) {
        int64 s = 0;
        for (int k = 0; k < 2; ++k) {
          s = add_mod(s, mul_mod_ex(m[i][k], r[k][0], mod), mod);
        }
        t[i][0] = s;
      }
      swap(t, r);
    }
    if (n > 1) {
      for (int i = 0; i < 2; ++i)
        for (int j = 0; j < 2; ++j) {
          int64 s = 0;
          for (int k = 0; k < 2; ++k) {
            s = add_mod(s, mul_mod_ex(m[i][k], m[k][j], mod), mod);
          }
          t[i][j] = s;
        }
      swap(t, m);
    }
  }
  return r[1][0];
}
#endif

// Sum of geometric progression
// (x^a+x^(a+1)+x^(a+2)+...+x^b) % mod
// a >= 0
// zero_p_zero: 0^0
// if b < a: return 0
SL int64 gp_sum_mod(int64 x, int64 a, int64 b, int64 mod,
                    int64 zero_p_zero = 1) {
  if (mod == 1 || b < a) return 0;
  if (b < a) return 0;
  x %= mod;
  // |x 0|^(b-a) x^a
  // |x 1|       x^a
  int64 u = x;
  int64 v1 = a == 0 && x == 0 ? zero_p_zero : power_mod_ex(x, a, mod);
  int64 v2 = v1;
  for (int64 n = b - a; n > 0; n >>= 1) {
    if (n & 1) {
      v1 = mul_mod_ex(u, v1, mod);
      v2 = add_mod(v1, v2, mod);
    }
    if (n > 1) {
      u = mul_mod_ex(u, u, mod);
    }
  }
  return v2;
}

struct init_direct_t {};
static const init_direct_t __init_direct{};
struct fake_int128 {};
int64 DEFAULT_MOD = 1;

// Mod context implementations
// The modulo is a global variable
struct DefaultMod {
  using mod_type = int64;
  static int64 mod() { return ::DEFAULT_MOD; }
  static void set(int64 v) { ::DEFAULT_MOD = v; }
};

// The modulo is a compiling time constant
template <typename M, M mod_value = 0>
struct CCMod {
  using mod_type = M;
  constexpr static int64 mod() { return mod_value; }
};

template <int64 mod_value>
using CCMod64 = CCMod<int64, mod_value>;

// The modulo is a thread local variable.
template <typename T>
struct TLMod {
  using mod_type = T;
  static T mod() { return mod_value; }
  static void set(T v) { mod_value = v; }
  static thread_local T mod_value;
};

template <typename T>
thread_local T TLMod<T>::mod_value = 1;

using TLMod64 = TLMod<int64>;

// The modulo is a field.
template <typename T>
struct MemMod {
  using mod_type = T;
  MemMod(T mod_value = ::DEFAULT_MOD) : mod_value(mod_value) {}
  T mod() const { return mod_value; }
  T mod_value;
};

using MemMod64 = MemMod<int64>;

// Arithmetic policy implementations
template <typename S, typename B>
struct APSB {
  using ints = S;
  using intb = B;
  static ints add(ints a, ints b, ints mod) {
    intb c = (intb)a + b;
    if (c >= mod) c -= mod;
    return static_cast<ints>(c);
  }
  static ints sub(ints a, ints b, ints mod) {
    intb c = (intb)a - b;
    if (c < 0) c += mod;
    return static_cast<ints>(c);
  }
  static ints mul(ints a, ints b, ints mod) {
    intb c = (intb)a * b % mod;
    return static_cast<ints>(c);
  }
  static void fix_value(ints& v, ints mod) {
    // Do nothing
  }
};

template <typename S>
struct APSB<S, S> {
  using ints = S;
  using intb = S;
  static ints add(ints a, ints b, ints mod) {
    a += b;
    if (a >= mod) a -= mod;
    return a;
  }
  static ints sub(ints a, ints b, ints mod) {
    a -= b;
    if (a < 0) a += mod;
    return a;
  }
  static ints mul(ints a, ints b, ints mod) {
    a = a * b % mod;
    return a;
  }
  static void fix_value(ints& v, ints mod) {
    // Do nothing
  }
};

template <typename S>
struct APSB<S, fake_int128> {
  using ints = S;
  using intb = fake_int128;
  static ints add(ints a, ints b, ints mod) {
    a += b;
    if (a >= mod) a -= mod;
    return a;
  }
  static ints sub(ints a, ints b, ints mod) {
    a -= b;
    if (a < 0) a += mod;
    return a;
  }
  static ints mul(ints a, ints b, ints mod) { return mul_mod_ex(a, b, mod); }
  static void fix_value(ints& v, ints mod) {
    // Do nothing
  }
};

template <typename S>
struct APSBL {
  using ints = S;
  using intb = fake_int128;
  static ints add(ints a, ints b, ints /*mod*/) { return a + b; }
  static ints sub(ints a, ints b, ints /*mod*/) { return a - b; }
  static ints mul(ints a, ints b, ints /*mod*/) { return a * b; }
  static void fix_value(ints& v, ints mod) { v = regulate_mod(v, mod); }
};

// Forward declarations related to NModNumber;
template <typename MC, typename AP>
struct NModNumber;

// MC = mod context
// AP = arithmetic policy
// Use MC::mod() to get the modulo.
template <typename MC,
          typename AP = APSB<typename MC::mod_type, typename MC::mod_type>>
struct NModNumber {
  friend NModNumber operator+(const NModNumber& x, const NModNumber& y) {
    return NModNumber(AP::add(x.value_, y.value_, MC::mod()), __init_direct);
  }

  template <typename T>
  friend REQUIRES((is_native_integer<T>::value)) RETURN(NModNumber) operator+(
      const NModNumber& x, T y) {
    return x + NModNumber(y);
  }

  template <typename T>
  friend REQUIRES((is_native_integer<T>::value)) RETURN(NModNumber) operator+(
      T x, const NModNumber& y) {
    return NModNumber(x) + y;
  }

  friend NModNumber operator-(const NModNumber& x, const NModNumber& y) {
    return NModNumber(AP::sub(x.value_, y.value_, MC::mod()), __init_direct);
  }

  friend NModNumber operator*(const NModNumber& x, const NModNumber& y) {
    return NModNumber(AP::mul(x.value_, y.value_, MC::mod()), __init_direct);
  }

  friend ostream& operator<<(ostream& o, const NModNumber& m) {
    return o << m.value_;
  }

  using ints = typename AP::ints;

  NModNumber(ints value = 0) {
    const ints M = MC::mod();
    if (value >= 0) {
      value_ = value >= M ? value % M : value;
    } else {
      value_ = value <= -M ? value % M + M : value + M;
    }
  }

  NModNumber(ints value, init_direct_t) : value_(value) {}

  static constexpr ints mod() { return MC::mod(); }

  NModNumber& operator+=(const NModNumber& y) {
    value_ = AP::add(value_, y.value_, MC::mod());
    return *this;
  }

  NModNumber& operator++() {
    value_ = AP::add(value_, 1, MC::mod());
    return *this;
  }

  NModNumber operator++(int) {
    NModNumber t(value_, __init_direct);
    ++*this;
    return t;
  }

  NModNumber& operator-=(const NModNumber& y) {
    value_ = AP::sub(value_, y.value_, MC::mod());
    return *this;
  }

  NModNumber& operator--() {
    value_ = AP::sub(value_, 1, MC::mod());
    return *this;
  }

  NModNumber operator--(int) {
    NModNumber t(value_, __init_direct);
    --*this;
    return t;
  }

  NModNumber operator+() const { return NModNumber(value_, __init_direct); }

  NModNumber operator-() const {
    return NModNumber(AP::sub(0, value_, MC::mod()), __init_direct);
  }

  NModNumber& operator*=(const NModNumber& y) {
    value_ = AP::mul(value_, y.value_, MC::mod());
    return *this;
  }

  ints value() const { return value_; }

  const NModNumber& fix_value() const {
    AP::fix_value(value_, MC::mod());
    return *this;
  }

  NModNumber& fix_value() {
    AP::fix_value(value_, MC::mod());
    return *this;
  }

 private:
  mutable ints value_;
};

template <typename MC, typename AP>
int operator==(const NModNumber<MC, AP>& x, const NModNumber<MC, AP>& y) {
  return x.fix_value().value() == y.fix_value().value();
}

template <typename MC, typename AP>
int operator!=(const NModNumber<MC, AP>& x, const NModNumber<MC, AP>& y) {
  return x.fix_value().value() != y.fix_value().value();
}

template <typename MC, typename AP>
int operator<(const NModNumber<MC, AP>& x, const NModNumber<MC, AP>& y) {
  return x.fix_value().value() < y.fix_value().value();
}

template <typename MC, typename AP>
int operator<=(const NModNumber<MC, AP>& x, const NModNumber<MC, AP>& y) {
  return x.fix_value().value() <= y.fix_value().value();
}

template <typename MC, typename AP>
int operator>(const NModNumber<MC, AP>& x, const NModNumber<MC, AP>& y) {
  return x.fix_value().value() > y.fix_value().value();
}

template <typename MC, typename AP>
int operator>=(const NModNumber<MC, AP>& x, const NModNumber<MC, AP>& y) {
  return x.fix_value().value() >= y.fix_value().value();
}

template <typename M, M mod_value, typename AP = APSB<M, M>>
using NMod = NModNumber<CCMod<M, mod_value>, AP>;

template <int64 mod_value, typename AP = APSB<int64, int64>>
using NMod64 = NModNumber<CCMod<int64, mod_value>, AP>;

template <typename M = int64, typename AP = APSB<M, M>>
using TLNMod = NModNumber<TLMod<M>, AP>;

template <typename AP = APSB<int64, int64>>
using TLNMod64 = NModNumber<TLMod<int64>, AP>;

// Forward declarations related to NModNumberM;
template <typename MC, typename AP>
struct NModNumberM;

// MC = mod context
// AP = arithmetic policy
// Use mc.mod() to get the modulo.
template <typename MC,
          typename AP = APSB<typename MC::mod_type, typename MC::mod_type>>
struct NModNumberM {
  friend NModNumberM operator+(const NModNumberM& x, const NModNumberM& y) {
    return NModNumberM(AP::add(x.value_, y.value_, x.mod()), x.mc,
                       __init_direct);
  }

  template <typename T>
  friend REQUIRES((is_native_integer<T>::value)) RETURN(NModNumberM) operator+(
      const NModNumberM& x, T y) {
    return x + NModNumberM(y, x.mc);
  }

  template <typename T>
  friend REQUIRES((is_native_integer<T>::value)) RETURN(NModNumberM) operator+(
      T x, const NModNumberM& y) {
    return NModNumberM(x, y.mc) + y;
  }

  friend NModNumberM operator-(const NModNumberM& x, const NModNumberM& y) {
    return NModNumberM(AP::sub(x.value_, y.value_, x.mod()), x.mc,
                       __init_direct);
  }

  template <typename T>
  friend REQUIRES((is_native_integer<T>::value)) RETURN(NModNumberM) operator-(
      const NModNumberM& x, T y) {
    return x - NModNumberM(y, x.mc);
  }

  template <typename T>
  friend REQUIRES((is_native_integer<T>::value)) RETURN(NModNumberM) operator-(
      T x, const NModNumberM& y) {
    return NModNumberM(x, y.mc) - y;
  }

  friend NModNumberM operator*(const NModNumberM& x, const NModNumberM& y) {
    return NModNumberM(AP::mul(x.value_, y.value_, x.mod()), x.mc,
                       __init_direct);
  }

  template <typename T>
  friend REQUIRES((is_native_integer<T>::value)) RETURN(NModNumberM) operator*(
      const NModNumberM& x, T y) {
    return x * NModNumberM(y, x.mc);
  }

  template <typename T>
  friend REQUIRES((is_native_integer<T>::value)) RETURN(NModNumberM) operator*(
      T x, const NModNumberM& y) {
    return NModNumberM(x, y.mc) * y;
  }

  friend ostream& operator<<(ostream& o, const NModNumberM& m) {
    return o << m.value_;
  }

  using ints = typename AP::ints;

  NModNumberM(ints value = 0, const MC& mc = MC()) : mc(mc) {
    const ints M = mod();
    if (value >= 0) {
      value_ = value >= M ? value % M : value;
    } else {
      value_ = value <= -M ? value % M + M : value + M;
    }
  }

  NModNumberM(ints value, const MC& mc, init_direct_t)
      : value_(value), mc(mc) {}

  ints mod() const { return mc.mod(); }

  NModNumberM& operator+=(const NModNumberM& y) {
    value_ = AP::add(value_, y.value_, mod());
    return *this;
  }

  NModNumberM& operator++() {
    value_ = AP::add(value_, 1, mod());
    return *this;
  }

  NModNumberM operator++(int) {
    NModNumberM t(value_, mc, __init_direct);
    ++*this;
    return t;
  }

  NModNumberM& operator-=(const NModNumberM& y) {
    value_ = AP::sub(value_, y.value_, mod());
    return *this;
  }

  NModNumberM& operator--() {
    value_ = AP::sub(value_, 1, mod());
    return *this;
  }

  NModNumberM operator--(int) {
    NModNumberM t(value_, __init_direct);
    --*this;
    return t;
  }

  NModNumberM operator+() const {
    return NModNumberM(value_, mc, __init_direct);
  }

  NModNumberM operator-() const {
    return NModNumberM(AP::sub(0, value_, mod()), mc, __init_direct);
  }

  NModNumberM& operator*=(const NModNumberM& y) {
    value_ = AP::mul(value_, y.value_, mod());
    return *this;
  }

  ints value() const { return value_; }

  const NModNumberM& fix_value() const {
    AP::fix_value(value_, mod());
    return *this;
  }

  NModNumberM& fix_value() {
    AP::fix_value(value_, mod());
    return *this;
  }

 private:
  mutable ints value_;
  MC mc;
};

template <typename MC, typename AP>
int operator==(const NModNumberM<MC, AP>& x, const NModNumberM<MC, AP>& y) {
  return x.fix_value().value() == y.fix_value().value();
}

template <typename MC, typename AP>
int operator!=(const NModNumberM<MC, AP>& x, const NModNumberM<MC, AP>& y) {
  return x.fix_value().value() != y.fix_value().value();
}

template <typename MC, typename AP>
int operator<(const NModNumberM<MC, AP>& x, const NModNumberM<MC, AP>& y) {
  return x.fix_value().value() < y.fix_value().value();
}

template <typename MC, typename AP>
int operator<=(const NModNumberM<MC, AP>& x, const NModNumberM<MC, AP>& y) {
  return x.fix_value().value() <= y.fix_value().value();
}

template <typename MC, typename AP>
int operator>(const NModNumberM<MC, AP>& x, const NModNumberM<MC, AP>& y) {
  return x.fix_value().value() > y.fix_value().value();
}

template <typename MC, typename AP>
int operator>=(const NModNumberM<MC, AP>& x, const NModNumberM<MC, AP>& y) {
  return x.fix_value().value() >= y.fix_value().value();
}

template <typename M, M mod_value, typename AP = APSB<M, M>>
using NModM = NModNumberM<CCMod<M, mod_value>, AP>;

template <int64 M, typename AP = APSB<int64, int64>>
using NModM64 = NModNumberM<CCMod<int64, M>, AP>;

template <typename M = int64, typename AP = APSB<M, M>>
using TLNModM = NModNumber<TLMod<M>, AP>;

template <typename AP = APSB<int64, int64>>
using TLNModM64 = NModNumber<TLMod<int64>, AP>;

template <int v>
struct NModNumberIndicator {
  enum { value = v };
};

template <typename X>
struct IsNModNumber {
  static constexpr NModNumberIndicator<0> NModNumberMatch(...);

  template <typename MC, typename AP>
  static constexpr NModNumberIndicator<1> NModNumberMatch(NModNumber<MC, AP>);

  template <typename MC, typename AP>
  static constexpr NModNumberIndicator<1> NModNumberMatch(NModNumberM<MC, AP>);

  static X makeX();

  using result_type = decltype(NModNumberMatch(makeX()));

  enum { result = result_type::value };
};

#if PE_HAS_CPP20
template <class T>
concept PeModNumber = requires(T v) {
  requires static_cast<bool>(IsNModNumber<T>::result);
  v + 1;
  v - 1;
  v * 1;
  1 - v;
  1 * v;
  1 + v;
  v + 1LL;
  v - 1LL;
  v * 1LL;
  1LL + v;
  1LL - v;
  1LL * v;
#if PE_HAS_INT128
  v + (int128)1;
  v - (int128)1;
  v*(int128)1;
  (int128)1 + v;
  (int128)1 - v;
  (int128)1 * v;
#endif
  v + v;
  v - v;
  v* v;
  v += 1;
  v -= 1;
  v *= 1;
  v += 1LL;
  v -= 1LL;
  v *= 1LL;
#if PE_HAS_INT128
  v += (int128)1;
  v -= (int128)1;
  v *= (int128)1;
#endif
  v += v;
  v -= v;
  v *= v;
  ++v;
  --v;
  v++;
  v--;
};
static_assert(PeModNumber<NMod64<1000000007>>);
static_assert(PeModNumber<TLNMod64<>>);
static_assert(PeModNumber<NModM64<1000000007>>);
static_assert(PeModNumber<TLNModM64<>>);
#endif
/*
  Guide:
  1. Use NModNumber instead of NModNumberM.
  2. If mod is a compiling-time value, use CCMod, CCMod64.
  3. If mod is a runtime value, use DefaultMod for int64, or TLMod<T> for
  other type.
  4. If mod is a runtime value used in different threads, use TLMod<T>.
  5. Call DefaultMod::set(mod_value), TLMod<T>::set(mod_value) when necessary.
*/
#endif
