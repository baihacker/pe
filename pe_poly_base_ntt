#ifndef PE_POLY_BASE_NTT_
#define PE_POLY_BASE_NTT_

#include "pe_base"
#include "pe_type_traits"
#include "pe_poly_base_common"

namespace pe {
namespace ntt_base {
template <typename T>
SL REQUIRES((is_builtin_integer_v<T>)) RETURN(void)
    NttTrans(T* data, const int64 n) {
  int64 j = n >> 1;
  for (int64 i = 1; i < n - 1; ++i) {
    if (i < j) std::swap(data[i], data[j]);
    int64 k = n >> 1;
    while (j >= k) {
      j -= k;
      k >>= 1;
    }
    if (j < k) j += k;
  }
}
}  // namespace ntt_base

// mod is 32 bit
namespace ntt32 {
#define HAS_POLY_MUL_NTT32 1

struct NttMod32 {
  // mod = r * 2 ^ k + 1
  // mod is prime
  const uint32 mod;
  const uint32 r;
  const int k;
  const uint32 g;

  uint32 omg[32];
  mutable uint32* pre_omg[32];

  NttMod32(uint32 mod, uint32 r, int k, uint32 g) : mod(mod), r(r), k(k), g(g) {
    for (int i = 0; i <= k; ++i) {
      omg[i] = static_cast<uint32>(
          PowerMod<uint64, uint64, uint64>(g, (mod - 1) >> i, mod));
    }
    std::fill(pre_omg, pre_omg + 32, nullptr);
  }

  ~NttMod32() {
    for (int i = 0; i <= k; ++i) {
      if (pre_omg[i] != nullptr) {
        delete[] pre_omg[i];
        pre_omg[i] = nullptr;
      }
    }
  }

  void InitPreOmg(int used_k) const {
    PE_ASSERT(used_k <= k);
    for (int i = 0; i <= used_k; ++i) {
      if (pre_omg[i] != nullptr) {
        continue;
      }
      const int64 cnt = 1LL << i;
      pre_omg[i] = new uint32[cnt];
      uint32* target = pre_omg[i];
      const uint64 m = omg[i];
      uint32 last = 1;
      target[0] = 1;
      for (int64 i = 1; i < cnt; ++i) {
        last = last * m % mod;
        target[i] = last;
      }
    }
  }
};

/*
3892314113: 29 * 2^27 + 1, 3
3489660929: 13 * 2^28 + 1, 3
3221225473: 3 * 2^30 + 1, 5
2281701377: 17 * 2^27 + 1, 3
2013265921: 15 * 2^27 + 1, 31
*/

constexpr uint32 ntt_mods[] = {
    0, 3892314113, 3489660929, 3221225473, 2281701377,
};

static const NttMod32 ntt_mod_1(ntt_mods[1], 29, 27, 3);
static const NttMod32 ntt_mod_2(ntt_mods[2], 13, 28, 3);
static const NttMod32 ntt_mod_3(ntt_mods[3], 3, 30, 5);
static const NttMod32 ntt_mod_4(ntt_mods[4], 17, 27, 3);

void InitNtt(int k = 22) {
  PE_ASSERT(k <= 27 && k >= 0);
  ntt_mod_1.InitPreOmg(k);
  ntt_mod_2.InitPreOmg(k);
  ntt_mod_3.InitPreOmg(k);
  ntt_mod_4.InitPreOmg(k);
}

namespace internal {
template <typename T, uint32 mod>
SL REQUIRES((is_builtin_integer_v<T>)) RETURN(void)
    Ntt(T* data, const int64 n, const NttMod32& moder, bool inv = false) {
  ntt_base::NttTrans(data, n);
  using AtLeastUint64T = at_least_uint64_t<T>;
  int id = 0;
  for (int64 h = 2; h <= n; h <<= 1) {
    const uint32* pomg = moder.pre_omg[++id];
    if (pomg != nullptr) {
      for (int64 j = 0; j < n; j += h) {
        const uint32* omg = pomg;
        const int64 half_h = h >> 1;
        const int64 limit = j + half_h;
        for (int64 k = j; k < limit; ++k) {
          const AtLeastUint64T u = data[k];
          const auto t = MulMod(*omg++, data[k + half_h], mod);
          data[k] = static_cast<uint32>(AddMod(u, t, mod));
          data[k + half_h] = static_cast<uint32>(SubMod(u, t, mod));
        }
      }
    } else {
      for (int64 j = 0; j < n; j += h) {
        uint64 omgn = 1;
        const int64 half_h = h >> 1;
        const int64 limit = j + half_h;
        for (int64 k = j; k < limit; ++k) {
          const AtLeastUint64T u = data[k];
          const auto t = MulMod(omgn, data[k + half_h], mod);
          data[k] = static_cast<uint32>(AddMod(u, t, mod));
          data[k + half_h] = static_cast<uint32>(SubMod(u, t, mod));
          omgn = MulMod(omgn, moder.omg[id], mod);
        }
      }
    }
  }
  if (inv) {
    const int64 half_n = n >> 1;
    for (int64 i = 1; i < half_n; ++i) std::swap(data[i], data[n - i]);
    const uint64 c = PowerMod<uint64>(n, mod - 2, mod);
    for (int64 i = 0; i < n; ++i) data[i] = c * data[i] % mod;
  }
}

template <typename T, uint32 mod>
SL std::vector<uint32> RunNtt(const NttMod32& moder, const T* X, int64 n,
                              const T* Y, int64 m, int64 target_mod) {
  const int64 aligned_size = BitCeil(n + m - 1);
  const bool skip_mod = target_mod > 0 && static_cast<uint64>(target_mod) <=
                                              static_cast<uint64>(mod);
  std::vector<uint32> XX(aligned_size);
  std::vector<uint32> YY(aligned_size);
#if ENABLE_OPENMP
#pragma omp parallel sections if (n + m >= 100000)
#endif
  {
#if ENABLE_OPENMP
#pragma omp section
#endif
    {
      if (skip_mod) {
        for (int64 i = 0; i < n; ++i) {
          XX[i] = ToInt<uint32>(X[i]);
        }
      } else {
        for (int64 i = 0; i < n; ++i) {
          XX[i] = ToInt<uint32>(Mod(X[i], mod));
        }
      }
      Ntt<uint32, mod>(std::data(XX), aligned_size, moder, false);
    }
#if ENABLE_OPENMP
#pragma omp section
#endif
    {
      if (skip_mod) {
        for (int64 i = 0; i < m; ++i) {
          YY[i] = ToInt<uint32>(Y[i]);
        }
      } else {
        for (int64 i = 0; i < m; ++i) {
          YY[i] = ToInt<uint32>(Mod(Y[i], mod));
        }
      }
      Ntt<uint32, mod>(std::data(YY), aligned_size, moder, false);
    }
  }
  constexpr uint64 mod1 = mod;
  for (int64 i = 0; i < aligned_size; ++i) {
    XX[i] = static_cast<uint64>(XX[i]) * YY[i] % mod1;
  }
  Ntt<uint32, mod>(std::data(XX), aligned_size, moder, true);
  return XX;
}

template <typename T>
SL void RunNttN(const T* X, int64 n, const T* Y, int64 m, int64 target_mod,
                std::vector<uint32>* result, int ntt_number) {
#if ENABLE_OPENMP
#pragma omp parallel sections
#endif
  {
#if ENABLE_OPENMP
#pragma omp section
#endif
    {
      if (ntt_number >= 1) {
        result[0] = RunNtt<T, ntt_mods[1]>(ntt_mod_1, X, n, Y, m, target_mod);
      }
    }
#if ENABLE_OPENMP
#pragma omp section
#endif
    {
      if (ntt_number >= 2) {
        result[1] = RunNtt<T, ntt_mods[2]>(ntt_mod_2, X, n, Y, m, target_mod);
      }
    }
#if ENABLE_OPENMP
#pragma omp section
#endif
    {
      if (ntt_number >= 3) {
        result[2] = RunNtt<T, ntt_mods[3]>(ntt_mod_3, X, n, Y, m, target_mod);
      }
    }
#if ENABLE_OPENMP
#pragma omp section
#endif
    {
      if (ntt_number >= 4) {
        result[3] = RunNtt<T, ntt_mods[4]>(ntt_mod_4, X, n, Y, m, target_mod);
      }
    }
  }
}

template <typename T, uint32 mod>
SL REQUIRES((is_builtin_integer_v<T>)) RETURN(void)
    Ntt2D(T* data, int64 rows, int64 cols, const NttMod32& moder,
          bool inv = false) {
  for (int64 i = 0; i < rows; ++i) {
    T* row_ptr = data + i * cols;
    Ntt<T, mod>(row_ptr, cols, moder, inv);
  }

  std::vector<T> column_buffer(rows);
  for (int64 j = 0; j < cols; ++j) {
    for (int64 i = 0; i < rows; ++i) {
      column_buffer[i] = data[i * cols + j];
    }
    Ntt<T, mod>(column_buffer.data(), rows, moder, inv);

    for (int64 i = 0; i < rows; ++i) {
      data[i * cols + j] = column_buffer[i];
    }
  }
}

template <typename T, uint32 mod>
SL std::vector<std::vector<uint32>> RunNtt2D(
    const NttMod32& moder, const std::vector<std::vector<T>>& X,
    const std::vector<std::vector<T>>& Y, int64 target_mod) {
  const int64 n1 = sz(X);
  const int64 m1 = sz(X[0]);
  const int64 n2 = sz(Y);
  const int64 m2 = sz(Y[0]);
  const int64 aligned_n = BitCeil(n1 + n2 - 1);
  const int64 aligned_m = BitCeil(m1 + m2 - 1);
  const int64 buffer_size = aligned_n * aligned_m;

  const bool skip_mod = target_mod > 0 && static_cast<uint64>(target_mod) <=
                                              static_cast<uint64>(mod);
  std::vector<uint32> XX(buffer_size, 0);
  std::vector<uint32> YY(buffer_size, 0);
#if ENABLE_OPENMP
#pragma omp parallel sections if (buffer_size >= 100000)
#endif
  {
#if ENABLE_OPENMP
#pragma omp section
#endif
    {
      if (skip_mod) {
        for (int64 i = 0; i < n1; ++i)
          for (int64 j = 0; j < m1; ++j) {
            XX[i * aligned_m + j] = ToInt<uint32>(X[i][j]);
          }
      } else {
        for (int64 i = 0; i < n1; ++i)
          for (int64 j = 0; j < m1; ++j) {
            XX[i * aligned_m + j] = ToInt<uint32>(Mod(X[i][j], mod));
          }
      }
      Ntt2D<uint32, mod>(std::data(XX), aligned_n, aligned_m, moder, false);
    }
#if ENABLE_OPENMP
#pragma omp section
#endif
    {
      if (skip_mod) {
        for (int64 i = 0; i < n2; ++i)
          for (int64 j = 0; j < m2; ++j) {
            YY[i * aligned_m + j] = ToInt<uint32>(Y[i][j]);
          }
      } else {
        for (int64 i = 0; i < n2; ++i)
          for (int64 j = 0; j < m2; ++j) {
            YY[i * aligned_m + j] = ToInt<uint32>(Mod(Y[i][j], mod));
          }
      }
      Ntt2D<uint32, mod>(std::data(YY), aligned_n, aligned_m, moder, false);
    }
  }
  constexpr uint64 mod1 = mod;
  for (int64 i = 0; i < buffer_size; ++i) {
    XX[i] = static_cast<uint64>(XX[i]) * YY[i] % mod1;
  }
  Ntt2D<uint32, mod>(std::data(XX), aligned_n, aligned_m, moder, true);

  std::vector<std::vector<uint32>> result(aligned_n,
                                          std::vector<uint32>(aligned_m, 0));
  for (int64 i = 0; i < aligned_n; ++i)
    for (int64 j = 0; j < aligned_m; ++j) {
      result[i][j] = XX[i * aligned_m + j];
    }

  return result;
}

template <typename T>
SL void RunNtt2DN(const std::vector<std::vector<T>>& X,
                  const std::vector<std::vector<T>>& Y, int64 target_mod,
                  std::vector<std::vector<uint32>>* result, int ntt_number) {
#if ENABLE_OPENMP
#pragma omp parallel sections
#endif
  {
#if ENABLE_OPENMP
#pragma omp section
#endif
    {
      if (ntt_number >= 1) {
        result[0] = RunNtt2D<T, ntt_mods[1]>(ntt_mod_1, X, Y, target_mod);
      }
    }
#if ENABLE_OPENMP
#pragma omp section
#endif
    {
      if (ntt_number >= 2) {
        result[1] = RunNtt2D<T, ntt_mods[2]>(ntt_mod_2, X, Y, target_mod);
      }
    }
#if ENABLE_OPENMP
#pragma omp section
#endif
    {
      if (ntt_number >= 3) {
        result[2] = RunNtt2D<T, ntt_mods[3]>(ntt_mod_3, X, Y, target_mod);
      }
    }
#if ENABLE_OPENMP
#pragma omp section
#endif
    {
      if (ntt_number >= 4) {
        result[3] = RunNtt2D<T, ntt_mods[4]>(ntt_mod_4, X, Y, target_mod);
      }
    }
  }
}
}  // namespace internal

namespace internal {
struct NttRunnerSmall {
  static constexpr PolyMulCoeType kMod = ntt_mods[1];

  // Multiply two polynomials.
  // Make sure the length of result is at least: n + m - 1
  template <typename T>
  SL REQUIRES((is_builtin_integer_v<T> || is_extended_integer_v<T>))
      RETURN(void) PolyMul(const T* X, int64 n, const T* Y, int64 m, T* result,
                           int64 mod) {
    static_assert(pe_is_unsigned_v<T>, "T must be unsigned");

    std::vector<uint32> tresult;

    internal::RunNttN<T>(X, n, Y, m, mod, &tresult, 1);

    const int64 result_size = n + m - 1;

    if (mod > 0) {
      for (int64 i = 0; i < result_size; ++i) {
        result[i] = tresult[i] % mod;
      }
    } else {
      for (int64 i = 0; i < result_size; ++i) {
        result[i] = tresult[i];
      }
    }
  }

  template <typename T>
  SL REQUIRES((is_builtin_integer_v<T> || is_extended_integer_v<T>))
      RETURN(std::vector<std::vector<T>>)
          PolyMul2D(const std::vector<std::vector<T>>& X,
                    const std::vector<std::vector<T>>& Y, int64 mod) {
    const int64 n1 = sz(X);
    const int64 n2 = sz(Y);
    if (n1 == 0 || n2 == 0) {
      return {};
    }

    const int64 m1 = sz(X[0]);
    const int64 m2 = sz(Y[0]);
    if (m1 == 0 || m2 == 0) {
      return {};
    }

    std::vector<std::vector<uint32>> tresult;

    internal::RunNtt2DN<T>(X, Y, mod, &tresult, 1);

    std::vector<std::vector<T>> ret(n1 + n2 - 1,
                                    std::vector<int64>(m1 + m2 - 1, 0));

    if (mod > 0) {
      for (int64 i = 0; i < n1 + n2 - 1; ++i)
        for (int64 j = 0; j < m1 + m2 - 1; ++j) {
          ret[i][j] = tresult[i][j] % mod;
        }
    } else {
      for (int64 i = 0; i < n1 + n2 - 1; ++i)
        for (int64 j = 0; j < m1 + m2 - 1; ++j) {
          ret[i][j] = tresult[i][j];
        }
    }

    return ret;
  }
};
}  // namespace internal

static constexpr PolyMulCoeType kPolyMulSmallMod =
    internal::NttRunnerSmall::kMod;

POLY_MUL_IMPL(PolyMulSmall, internal::NttRunnerSmall::PolyMul)

template <typename T>
SL REQUIRES((is_builtin_integer_v<T> || is_extended_integer_v<T>))
    RETURN(std::vector<std::vector<T>>)
        PolyMul2DSmall(const std::vector<std::vector<T>>& X,
                       const std::vector<std::vector<T>>& Y, int64 mod) {
  return internal::NttRunnerSmall::PolyMul2D<T>(X, Y, mod);
}

namespace internal {
// The medium version uses two modulus.
struct NttRunnerMedium {
 private:
  static constexpr uint64 M1 = ntt_mods[1];
  static constexpr uint64 M2 = ntt_mods[2];
  static constexpr uint64 INV_M2__M1 = 2594876085;

  using Self = NttRunnerMedium;

  template <typename T>
  SL T CombineMod(uint64 a, uint64 b, int64 mod) {
    const uint64 x = a >= b ? a - b : a + Self::M1 - b;
    const uint64 y = x * Self::INV_M2__M1 % Self::M1;
    const uint64 t = y * Self::M2 + b;
    return t % mod;
  }

  template <typename T>
  SL T CombineValue(uint64 a, uint64 b) {
    const uint64 x = a >= b ? a - b : a + Self::M1 - b;
    const uint64 y = x * Self::INV_M2__M1 % Self::M1;
    const uint64 t = y * Self::M2 + b;
    return t;
  }

 public:
  static constexpr PolyMulCoeType kMod =
      Prod<PolyMulCoeType>(ntt_mods[1], ntt_mods[2]);

  // Multiply two polynomials.
  // Make sure the length of result is at least: n + m - 1
  template <typename T>
  SL REQUIRES((is_builtin_integer_v<T> || is_extended_integer_v<T>))
      RETURN(void) PolyMul(const T* X, int64 n, const T* Y, int64 m, T* result,
                           int64 mod) {
    std::vector<uint32> tresult[2];

    internal::RunNttN<T>(X, n, Y, m, mod, tresult, 2);

    const int64 result_size = n + m - 1;
    if (mod > 0) {
#if ENABLE_OPENMP
#pragma omp parallel for schedule(dynamic, 100000) if (n + m >= 100000)
#endif
      for (int64 i = 0; i < result_size; ++i) {
        result[i] = CombineMod<T>(tresult[0][i], tresult[1][i], mod);
      }
    } else {
#if ENABLE_OPENMP
#pragma omp parallel for schedule(dynamic, 100000) if (n + m >= 100000)
#endif
      for (int64 i = 0; i < result_size; ++i) {
        result[i] = CombineValue<T>(tresult[0][i], tresult[1][i]);
      }
    }
  }

  template <typename T>
  SL REQUIRES((is_builtin_integer_v<T> || is_extended_integer_v<T>))
      RETURN(std::vector<std::vector<T>>)
          PolyMul2D(const std::vector<std::vector<T>>& X,
                    const std::vector<std::vector<T>>& Y, int64 mod) {
    const int64 n1 = sz(X);
    const int64 n2 = sz(Y);
    if (n1 == 0 || n2 == 0) {
      return {};
    }

    const int64 m1 = sz(X[0]);
    const int64 m2 = sz(Y[0]);
    if (m1 == 0 || m2 == 0) {
      return {};
    }

    std::vector<std::vector<uint32>> tresult[2];

    internal::RunNtt2DN<T>(X, Y, mod, tresult, 2);

    std::vector<std::vector<T>> result(n1 + n2 - 1,
                                       std::vector<T>(m1 + m2 - 1, 0));
    if (mod > 0) {
      for (int64 i = 0; i < n1 + n2 - 1; ++i)
        for (int64 j = 0; j < m1 + m2 - 1; ++j) {
          result[i][j] = CombineMod<T>(tresult[0][i][j], tresult[1][i][j], mod);
        }
    } else {
      for (int64 i = 0; i < n1 + n2 - 1; ++i)
        for (int64 j = 0; j < m1 + m2 - 1; ++j) {
          result[i][j] = CombineValue<T>(tresult[0][i][j], tresult[1][i][j]);
        }
    }

    return result;
  }
};

}  // namespace internal

static constexpr PolyMulCoeType kPolyMulMediumMod =
    internal::NttRunnerMedium::kMod;

// Multiply two polynomials.
// The length of result is at least n + m - 1.
POLY_MUL_IMPL(PolyMulMedium, internal::NttRunnerMedium::PolyMul)

template <typename T>
SL REQUIRES((is_builtin_integer_v<T> || is_extended_integer_v<T>))
    RETURN(std::vector<std::vector<T>>)
        PolyMul2DMedium(const std::vector<std::vector<T>>& X,
                        const std::vector<std::vector<T>>& Y, int64 mod) {
  return internal::NttRunnerMedium::PolyMul2D<T>(X, Y, mod);
}

namespace internal {
#define NTT32_DIRECT_INT128_IMPLEMENTATION 0

struct NttRunnerLarge {
 private:
  static constexpr uint64 M1 = ntt_mods[1];
  static constexpr uint64 M2 = ntt_mods[2];
  static constexpr uint64 M3 = ntt_mods[3];
#if PE_HAS_INT128 && NTT32_DIRECT_INT128_IMPLEMENTATION
  static constexpr uint64 M12 = M1 * M2;
  static constexpr uint64 M13 = M1 * M3;
  static constexpr uint64 M23 = M2 * M3;
  static constexpr uint64 INV_M12__M3 = 2576980436;
  static constexpr uint64 INV_M13__M2 = 1163220197;
  static constexpr uint64 INV_M23__M1 = 3373338954;

  static constexpr uint128 M13M = static_cast<uint128>(INV_M13__M2) * M13;
  static constexpr uint128 M23M = static_cast<uint128>(INV_M23__M1) * M23;
  static constexpr uint128 M12M = static_cast<uint128>(INV_M12__M3) * M12;
  static constexpr uint128 M123 = static_cast<uint128>(M1) * M2 * M3;
#endif
  static constexpr uint64 INV_M3__M2 = 13;

  static constexpr uint64 M2M3 = M2 * M3;
  static constexpr uint64 INV_M1__M2M3 = 1498797794963418808;

  using Self = NttRunnerLarge;

  template <typename T>
  SL T CombineMod(uint64 a, uint64 b, uint64 c, int64 mod) {
    const uint64 x1 = b >= c ? b - c : Self::M2 - c + b;
    const uint64 y1 = x1 * Self::INV_M3__M2 % Self::M2;
    const uint64 ans_mod_m2m3 = y1 * Self::M3 + c;

    const uint64 x2 =
        ans_mod_m2m3 >= a ? ans_mod_m2m3 - a : Self::M2M3 - a + ans_mod_m2m3;
    const uint64 y2 = MulMod(x2, Self::INV_M1__M2M3, Self::M2M3);
    const uint64 t = MulMod(y2 % mod, Self::M1 % mod, mod);
    return AddMod(t, a % mod, mod);
  }

  template <typename T>
  SL T CombineValue(uint64 a, uint64 b, uint64 c) {
#if PE_HAS_INT128
#if NTT32_DIRECT_INT128_IMPLEMENTATION
    const uint128 A = a * Self::M23M;
    const uint128 B = b * Self::M13M;
    const uint128 C = c * Self::M12M;
    const uint128 t = A + B + C;
    const uint128 tmp = t < Self::M123 ? t : t % Self::M123;
    return static_cast<T>(tmp);
#else
    const uint64 x1 = b >= c ? b - c : Self::M2 - c + b;
    const uint64 y1 = x1 * Self::INV_M3__M2 % Self::M2;
    const uint64 mod_bc = y1 * Self::M3 + c;
    const uint64 x2 = mod_bc >= a ? mod_bc - a : Self::M2M3 - a + mod_bc;

    const uint64 y2 =
        static_cast<uint128>(x2) * Self::INV_M1__M2M3 % Self::M2M3;
    const uint128 t = static_cast<uint128>(y2) * Self::M1 + a;
    return static_cast<T>(t);
#endif
#else
    PE_ASSERT(0);
    return 0;
#endif
  }

 public:
  static constexpr PolyMulCoeType kMod =
      Prod<PolyMulCoeType>(ntt_mods[1], ntt_mods[2], ntt_mods[3]);

  // Multiply two polynomials.
  // Make sure the length of result is at least: n + m - 1
  template <typename T>
  SL REQUIRES((is_builtin_integer_v<T> || is_extended_integer_v<T>))
      RETURN(void) PolyMul(const T* X, int64 n, const T* Y, int64 m, T* result,
                           int64 mod) {
    std::vector<uint32> tresult[3];

    internal::RunNttN<T>(X, n, Y, m, mod, tresult, 3);

    const int64 result_size = n + m - 1;
    if (mod > 0) {
#if ENABLE_OPENMP
#pragma omp parallel for schedule(dynamic, 100000) if (n + m >= 100000)
#endif
      for (int64 i = 0; i < result_size; ++i) {
        result[i] =
            CombineMod<T>(tresult[0][i], tresult[1][i], tresult[2][i], mod);
      }
    } else {
#if ENABLE_OPENMP
#pragma omp parallel for schedule(dynamic, 100000) if (n + m >= 100000)
#endif
      for (int64 i = 0; i < result_size; ++i) {
        result[i] =
            CombineValue<T>(tresult[0][i], tresult[1][i], tresult[2][i]);
      }
    }
  }

  template <typename T>
  SL REQUIRES((is_builtin_integer_v<T> || is_extended_integer_v<T>))
      RETURN(std::vector<std::vector<T>>)
          PolyMul2D(const std::vector<std::vector<T>>& X,
                    const std::vector<std::vector<T>>& Y, int64 mod) {
    const int64 n1 = sz(X);
    const int64 n2 = sz(Y);
    if (n1 == 0 || n2 == 0) {
      return {};
    }

    const int64 m1 = sz(X[0]);
    const int64 m2 = sz(Y[0]);
    if (m1 == 0 || m2 == 0) {
      return {};
    }

    std::vector<std::vector<uint32>> tresult[3];

    internal::RunNtt2DN<T>(X, Y, mod, tresult, 3);

    std::vector<std::vector<T>> result(n1 + n2 - 1,
                                       std::vector<T>(m1 + m2 - 1, 0));
    if (mod > 0) {
      for (int64 i = 0; i < n1 + n2 - 1; ++i)
        for (int64 j = 0; j < m1 + m2 - 1; ++j) {
          result[i][j] = CombineMod<T>(tresult[0][i][j], tresult[1][i][j],
                                       tresult[2][i][j], mod);
        }
    } else {
      for (int64 i = 0; i < n1 + n2 - 1; ++i)
        for (int64 j = 0; j < m1 + m2 - 1; ++j) {
          result[i][j] = CombineValue<T>(tresult[0][i][j], tresult[1][i][j],
                                         tresult[2][i][j]);
        }
    }

    return result;
  }
};
}  // namespace internal

static constexpr PolyMulCoeType kPolyMulLargeMod =
    internal::NttRunnerLarge::kMod;

// Multiply two polynomials.
// The length of result is at least n + m - 1.
POLY_MUL_IMPL(PolyMulLarge, internal::NttRunnerLarge::PolyMul)

template <typename T>
SL REQUIRES((is_builtin_integer_v<T> || is_extended_integer_v<T>))
    RETURN(std::vector<std::vector<T>>)
        PolyMul2DLarge(const std::vector<std::vector<T>>& X,
                       const std::vector<std::vector<T>>& Y, int64 mod) {
  return internal::NttRunnerLarge::PolyMul2D<T>(X, Y, mod);
}

namespace internal {
struct NttRunnerEnormous {
 private:
  static constexpr uint64 M1 = ntt_mods[1];
  static constexpr uint64 M2 = ntt_mods[2];
  static constexpr uint64 M3 = ntt_mods[3];
  static constexpr uint64 M4 = ntt_mods[4];

  static constexpr uint64 INV_M2__M1 = 2594876085;
  static constexpr uint64 INV_M4__M3 = 460175071;

  static constexpr uint64 M1M2 = M1 * M2;
  static constexpr uint64 M3M4 = M3 * M4;

  static constexpr uint64 INV_M3M4__M1M2 = 4552771471729767515;

  using Self = NttRunnerEnormous;

  template <typename T>
  SL T CombineMod(uint64 a, uint64 b, uint64 c, uint64 d, int64 mod) {
    const uint64 x1 = a >= b ? a - b : Self::M1 - b + a;
    const uint64 y1 = x1 * Self::INV_M2__M1 % Self::M1;
    const uint64 ans_mod_m1m2 = y1 * Self::M2 + b;

    const uint64 x2 = c >= d ? c - d : Self::M3 - d + c;
    const uint64 y2 = x2 * Self::INV_M4__M3 % Self::M3;
    const uint64 ans_mod_m3m4 = y2 * Self::M4 + d;

    const uint64 x3 = ans_mod_m1m2 >= ans_mod_m3m4
                          ? ans_mod_m1m2 - ans_mod_m3m4
                          : Self::M1M2 - ans_mod_m3m4 + ans_mod_m1m2;

    const uint64 y3 = MulMod(x3, Self::INV_M3M4__M1M2, Self::M1M2);
    const uint64 t = MulMod(y3 % mod, Self::M3M4 % mod, mod);
    return AddMod(t, ans_mod_m3m4 % mod, mod);
  }

  template <typename T>
  SL T CombineValue(uint64 a, uint64 b, uint64 c, uint64 d) {
#if PE_HAS_INT128
    const uint64 x1 = a >= b ? a - b : Self::M1 - b + a;
    const uint64 y1 = x1 * Self::INV_M2__M1 % Self::M1;
    const uint64 ans_mod_m1m2 = y1 * Self::M2 + b;

    const uint64 x2 = c >= d ? c - d : Self::M3 - d + c;
    const uint64 y2 = x2 * Self::INV_M4__M3 % Self::M3;
    const uint64 ans_mod_m3m4 = y2 * Self::M4 + d;

    const uint64 x3 = ans_mod_m1m2 >= ans_mod_m3m4
                          ? ans_mod_m1m2 - ans_mod_m3m4
                          : Self::M1M2 - ans_mod_m3m4 + ans_mod_m1m2;

    const uint64 y3 =
        static_cast<uint128>(x3) * Self::INV_M3M4__M1M2 % Self::M1M2;
    const uint128 ans = static_cast<uint128>(y3) * Self::M3M4 + ans_mod_m3m4;
    return static_cast<T>(ans);
#else
    PE_ASSERT(0);
    return 0;
#endif
  }

 public:
  static constexpr PolyMulCoeType kMod =
      Prod<PolyMulCoeType>(ntt_mods[1], ntt_mods[2], ntt_mods[3], ntt_mods[4]);

  // Multiply two polynomials.
  // Make sure the length of result is at least: n + m - 1
  template <typename T>
  SL REQUIRES((is_builtin_integer_v<T> || is_extended_integer_v<T>))
      RETURN(void) PolyMul(const T* X, int64 n, const T* Y, int64 m, T* result,
                           int64 mod) {
    std::vector<uint32> tresult[4];

    internal::RunNttN<T>(X, n, Y, m, mod, tresult, 4);

    const int64 result_size = n + m - 1;
    if (mod > 0) {
#if ENABLE_OPENMP
#pragma omp parallel for schedule(dynamic, 100000) if (n + m >= 100000)
#endif
      for (int64 i = 0; i < result_size; ++i) {
        result[i] = CombineMod<T>(tresult[0][i], tresult[1][i], tresult[2][i],
                                  tresult[3][i], mod);
      }
    } else {
#if ENABLE_OPENMP
#pragma omp parallel for schedule(dynamic, 100000) if (n + m >= 100000)
#endif
      for (int64 i = 0; i < result_size; ++i) {
        result[i] = CombineValue<T>(tresult[0][i], tresult[1][i], tresult[2][i],
                                    tresult[3][i]);
      }
    }
  }

  template <typename T>
  SL REQUIRES((is_builtin_integer_v<T> || is_extended_integer_v<T>))
      RETURN(std::vector<std::vector<T>>)
          PolyMul2D(const std::vector<std::vector<T>>& X,
                    const std::vector<std::vector<T>>& Y, int64 mod) {
    const int64 n1 = sz(X);
    const int64 n2 = sz(Y);
    if (n1 == 0 || n2 == 0) {
      return {};
    }

    const int64 m1 = sz(X[0]);
    const int64 m2 = sz(Y[0]);
    if (m1 == 0 || m2 == 0) {
      return {};
    }

    std::vector<std::vector<uint32>> tresult[4];

    internal::RunNtt2DN<T>(X, Y, mod, tresult, 4);

    std::vector<std::vector<T>> result(n1 + n2 - 1,
                                       std::vector<T>(m1 + m2 - 1, 0));
    if (mod > 0) {
      for (int64 i = 0; i < n1 + n2 - 1; ++i)
        for (int64 j = 0; j < m1 + m2 - 1; ++j) {
          result[i][j] = CombineMod<T>(tresult[0][i][j], tresult[1][i][j],
                                       tresult[2][i][j], tresult[3][i][j], mod);
        }
    } else {
      for (int64 i = 0; i < n1 + n2 - 1; ++i)
        for (int64 j = 0; j < m1 + m2 - 1; ++j) {
          result[i][j] = CombineValue<T>(tresult[0][i][j], tresult[1][i][j],
                                         tresult[2][i][j], tresult[3][i][j]);
        }
    }

    return result;
  }
};

}  // namespace internal

static constexpr PolyMulCoeType kPolyMulEnormousMod =
    internal::NttRunnerEnormous::kMod;

// Multiply two polynomials.
// The length of result is at least n + m - 1.
POLY_MUL_IMPL(PolyMulEnormous, internal::NttRunnerEnormous::PolyMul)

template <typename T>
SL REQUIRES((is_builtin_integer_v<T> || is_extended_integer_v<T>))
    RETURN(std::vector<std::vector<T>>)
        PolyMul2DEnormous(const std::vector<std::vector<T>>& X,
                          const std::vector<std::vector<T>>& Y, int64 mod) {
  return internal::NttRunnerEnormous::PolyMul2D<T>(X, Y, mod);
}

namespace internal {
template <typename T>
SL REQUIRES((is_builtin_integer_v<T> || is_extended_integer_v<T>)) RETURN(void)
    PolyMulImpl(const T* X, int64 n, const T* Y, int64 m, T* result,
                int64 mod) {
  using ImplFunctionPointerType =
      typename pe::PolyMulType<T>::CStyleFunctionPointer;
  using Item = std::pair<ImplFunctionPointerType, PolyMulCoeType>;
  constexpr std::array<std::pair<ImplFunctionPointerType, PolyMulCoeType>, 3>
      impls = {
          Item{
              &NttRunnerSmall::PolyMul<T>,
              NttRunnerSmall::kMod,
          },
          Item{
              &NttRunnerMedium::PolyMul<T>,
              NttRunnerMedium::kMod,
          },
          Item{
              &NttRunnerLarge::PolyMul<T>,
              NttRunnerLarge::kMod,
          },
      };
  if (mod > 0) {
    for (int i = 0; i < impls.size(); ++i) {
      if (PolyMulAcceptLengthAndMod(impls[i].second, n, m, mod)) {
        return (*impls[i].first)(X, n, Y, m, result, mod);
      }
    }
  } else {
    const T maxv1 = *std::max_element(X, X + n);
    const T maxv2 = *std::max_element(Y, X + m);
    for (int i = 0; i < impls.size(); ++i) {
      if (PolyMulAcceptLengthAndValue(impls[i].second, n, maxv1, m, maxv2)) {
        return (*impls[i].first)(X, n, Y, m, result, mod);
      }
    }
  }
  return NttRunnerEnormous::PolyMul(X, n, Y, m, result, mod);
}
}  // namespace internal

static constexpr PolyMulCoeType kPolyMulMod = internal::NttRunnerEnormous::kMod;
POLY_MUL_IMPL(PolyMul, internal::PolyMulImpl)
}  // namespace ntt32

// mod is 64 bit
namespace ntt64 {
#define HAS_POLY_MUL_NTT64 1

struct NttMod64 {
  // mod = r * 2 ^ k + 1
  // mod is prime
  const uint64 mod;
  const uint32 r;
  const int k;
  const uint32 g;

  uint64 omg[64];
  mutable uint64* pre_omg[64];

  NttMod64(uint64 mod, uint32 r, int k, uint32 g) : mod(mod), r(r), k(k), g(g) {
    for (int i = 0; i <= k; ++i) {
      omg[i] = PowerMod<uint64, uint64, uint64>(g, (mod - 1) >> i, mod);
    }
    std::fill(pre_omg, pre_omg + 64, nullptr);
  }

  ~NttMod64() {
    for (int i = 0; i <= k; ++i) {
      if (pre_omg[i] != nullptr) {
        delete[] pre_omg[i];
        pre_omg[i] = nullptr;
      }
    }
  }

  void InitPreOmg(int used_k) const {
    PE_ASSERT(used_k <= k);
    for (int i = 0; i <= used_k; ++i) {
      if (pre_omg[i] != nullptr) {
        continue;
      }
      const int64 cnt = 1LL << i;
      pre_omg[i] = new uint64[cnt];
      uint64* target = pre_omg[i];
      const uint64 m = omg[i];
      uint64 last = 1;
      target[0] = 1;
      for (int64 i = 1; i < cnt; ++i) {
#if PE_HAS_INT128
        last = Uint128ModUint64(static_cast<uint128>(last) * m, mod);
#else
        last = MulMod(last, m, mod);
#endif
        target[i] = last;
      }
    }
  }
};

constexpr uint64 ntt_mods[] = {0, 1945555039024054273, 180143985094819841};

static const NttMod64 ntt_mod_1(ntt_mods[1], 27, 56, 5);
static const NttMod64 ntt_mod_2(ntt_mods[2], 5, 55, 6);

void InitNtt(int k = 22) {
  PE_ASSERT(k <= 30 && k >= 0);
  ntt_mod_1.InitPreOmg(k);
  ntt_mod_2.InitPreOmg(k);
}

namespace internal {
template <typename T, uint64 mod>
SL REQUIRES((is_builtin_integer_v<T>)) RETURN(void)
    Ntt(T* data, const int64 n, const NttMod64& moder, bool inv = false) {
  ntt_base::NttTrans(data, n);

  int id = 0;
  for (int64 h = 2; h <= n; h <<= 1) {
    const uint64* pomg = moder.pre_omg[++id];
    if (pomg != nullptr) {
      for (int64 j = 0; j < n; j += h) {
        const uint64* omg = pomg;
        const int64 half_h = h >> 1;
        const int64 limit = j + half_h;
        for (int64 k = j; k < limit; ++k) {
          const T u = data[k];
#if PE_HAS_INT128
          const uint64 t = Uint128ModUint64(
              static_cast<uint128>(*omg++) * data[k + half_h], mod);
#else
          const auto t = MulMod(*omg++, data[k + half_h], mod);
#endif
          data[k] = AddMod(u, t, mod);
          data[k + half_h] = SubMod(u, t, mod);
        }
      }
    } else {
      for (int64 j = 0; j < n; j += h) {
        uint64 omgn = 1;
        const int64 half_h = h >> 1;
        const int64 limit = j + half_h;
        for (int64 k = j; k < limit; ++k) {
          const T u = data[k];
#if PE_HAS_INT128
          const uint64 t = Uint128ModUint64(
              static_cast<uint128>(omgn) * data[k + half_h], mod);
#else
          const auto t = MulMod(omgn, data[k + half_h], mod);
#endif
          data[k] = AddMod(u, t, mod);
          data[k + half_h] = SubMod(u, t, mod);
#if PE_HAS_INT128
          omgn =
              Uint128ModUint64(static_cast<uint128>(omgn) * moder.omg[id], mod);
#else
          omgn = MulMod(omgn, moder.omg[id], mod);
#endif
        }
      }
    }
  }
  if (inv) {
    const int64 half_n = n >> 1;
    for (int64 i = 1; i < half_n; ++i) std::swap(data[i], data[n - i]);
    const uint64 c = PowerMod<uint64>(n, mod - 2, mod);
    for (int64 i = 0; i < n; ++i) {
#if PE_HAS_INT128
      data[i] = Uint128ModUint64(static_cast<uint128>(c) * data[i], mod);
#else
      data[i] = MulMod(c, data[i], mod);
#endif
    }
  }
}

template <typename T, uint64 mod>
SL std::vector<uint64> RunNtt(const NttMod64& moder, const T* X, int64 n,
                              const T* Y, int64 m, int64 target_mod) {
  const int64 aligned_size = BitCeil(n + m - 1);
  const bool skip_mod = target_mod > 0 && static_cast<uint64>(target_mod) <=
                                              static_cast<uint64>(mod);
  std::vector<uint64> XX(aligned_size);
  std::vector<uint64> YY(aligned_size);
#if ENABLE_OPENMP
#pragma omp parallel sections if (n + m >= 100000)
#endif
  {
#if ENABLE_OPENMP
#pragma omp section
#endif
    {
      if (skip_mod) {
        for (int64 i = 0; i < n; ++i) {
          XX[i] = ToInt<uint64>(X[i]);
        }
      } else {
        for (int64 i = 0; i < n; ++i) {
          XX[i] = ToInt<uint64>(Mod(X[i], mod));
        }
      }
      Ntt<uint64, mod>(std::data(XX), aligned_size, moder, false);
    }
#if ENABLE_OPENMP
#pragma omp section
#endif
    {
      if (skip_mod) {
        for (int64 i = 0; i < m; ++i) {
          YY[i] = ToInt<uint64>(Y[i]);
        }
      } else {
        for (int64 i = 0; i < m; ++i) {
          YY[i] = ToInt<uint64>(Mod(Y[i], mod));
        }
      }
      Ntt<uint64, mod>(std::data(YY), aligned_size, moder, false);
    }
  }
  constexpr uint64 mod1 = mod;
  for (int64 i = 0; i < aligned_size; ++i) {
#if PE_HAS_INT128
    XX[i] = Uint128ModUint64(static_cast<uint128>(XX[i]) * YY[i], mod1);
#else
    XX[i] = MulMod(XX[i], YY[i], mod1);
#endif
  }
  Ntt<uint64, mod>(std::data(XX), aligned_size, moder, true);

  return XX;
}

template <typename T>
SL void RunNttN(const T* X, int64 n, const T* Y, int64 m, int64 target_mod,
                std::vector<uint64>* result, int ntt_number) {
#if ENABLE_OPENMP
#pragma omp parallel sections
#endif
  {
#if ENABLE_OPENMP
#pragma omp section
#endif
    {
      if (ntt_number >= 1) {
        result[0] = RunNtt<T, ntt_mods[1]>(ntt_mod_1, X, n, Y, m, target_mod);
      }
    }
#if ENABLE_OPENMP
#pragma omp section
#endif
    {
      if (ntt_number >= 2) {
        result[1] = RunNtt<T, ntt_mods[2]>(ntt_mod_2, X, n, Y, m, target_mod);
      }
    }
  }
}

template <typename T, uint64 mod>
SL REQUIRES((is_builtin_integer_v<T>)) RETURN(void)
    Ntt2D(T* data, int64 rows, int64 cols, const NttMod64& moder,
          bool inv = false) {
  for (int64 i = 0; i < rows; ++i) {
    T* row_ptr = data + i * cols;
    Ntt<T, mod>(row_ptr, cols, moder, inv);
  }

  std::vector<T> column_buffer(rows);
  for (int64 j = 0; j < cols; ++j) {
    for (int64 i = 0; i < rows; ++i) {
      column_buffer[i] = data[i * cols + j];
    }
    Ntt<T, mod>(column_buffer.data(), rows, moder, inv);

    for (int64 i = 0; i < rows; ++i) {
      data[i * cols + j] = column_buffer[i];
    }
  }
}

template <typename T, uint64 mod>
SL std::vector<std::vector<uint64>> RunNtt2D(
    const NttMod64& moder, const std::vector<std::vector<T>>& X,
    const std::vector<std::vector<T>>& Y, int64 target_mod) {
  const int64 n1 = sz(X);
  const int64 m1 = sz(X[0]);
  const int64 n2 = sz(Y);
  const int64 m2 = sz(Y[0]);
  const int64 aligned_n = BitCeil(n1 + n2 - 1);
  const int64 aligned_m = BitCeil(m1 + m2 - 1);
  const int64 buffer_size = aligned_n * aligned_m;

  const bool skip_mod = target_mod > 0 && static_cast<uint64>(target_mod) <=
                                              static_cast<uint64>(mod);
  std::vector<uint64> XX(buffer_size, 0);
  std::vector<uint64> YY(buffer_size, 0);

#if ENABLE_OPENMP
#pragma omp parallel sections if (buffer_size >= 100000)
#endif
  {
#if ENABLE_OPENMP
#pragma omp section
#endif
    {
      if (skip_mod) {
        for (int64 i = 0; i < n1; ++i)
          for (int64 j = 0; j < m1; ++j) {
            XX[i * aligned_m + j] = ToInt<uint64>(X[i][j]);
          }
      } else {
        for (int64 i = 0; i < n1; ++i)
          for (int64 j = 0; j < m1; ++j) {
            XX[i * aligned_m + j] = ToInt<uint64>(Mod(X[i][j], mod));
          }
      }
      Ntt2D<uint64, mod>(std::data(XX), aligned_n, aligned_m, moder, false);
    }
#if ENABLE_OPENMP
#pragma omp section
#endif
    {
      if (skip_mod) {
        for (int64 i = 0; i < n2; ++i)
          for (int64 j = 0; j < m2; ++j) {
            YY[i * aligned_m + j] = ToInt<uint64>(Y[i][j]);
          }
      } else {
        for (int64 i = 0; i < n2; ++i)
          for (int64 j = 0; j < m2; ++j) {
            YY[i * aligned_m + j] = ToInt<uint64>(Mod(Y[i][j], mod));
          }
      }
      Ntt2D<uint64, mod>(std::data(YY), aligned_n, aligned_m, moder, false);
    }
  }
  constexpr uint64 mod1 = mod;
  for (int64 i = 0; i < buffer_size; ++i) {
#if PE_HAS_INT128
    XX[i] = Uint128ModUint64(static_cast<uint128>(XX[i]) * YY[i], mod1);
#else
    XX[i] = MulMod(XX[i], YY[i], mod1);
#endif
  }
  Ntt2D<uint64, mod>(std::data(XX), aligned_n, aligned_m, moder, true);

  std::vector<std::vector<uint64>> result(aligned_n,
                                          std::vector<uint64>(aligned_m, 0));
  for (int64 i = 0; i < aligned_n; ++i)
    for (int64 j = 0; j < aligned_m; ++j) {
      result[i][j] = XX[i * aligned_m + j];
    }

  return result;
}

template <typename T>
SL void RunNtt2DN(const std::vector<std::vector<T>>& X,
                  const std::vector<std::vector<T>>& Y, int64 target_mod,
                  std::vector<std::vector<uint64>>* result, int ntt_number) {
#if ENABLE_OPENMP
#pragma omp parallel sections
#endif
  {
#if ENABLE_OPENMP
#pragma omp section
#endif
    {
      if (ntt_number >= 1) {
        result[0] = RunNtt2D<T, ntt_mods[1]>(ntt_mod_1, X, Y, target_mod);
      }
    }
#if ENABLE_OPENMP
#pragma omp section
#endif
    {
      if (ntt_number >= 2) {
        result[1] = RunNtt2D<T, ntt_mods[2]>(ntt_mod_2, X, Y, target_mod);
      }
    }
  }
}
}  // namespace internal

namespace internal {
struct NttRunnerSmall {
  static constexpr PolyMulCoeType kMod = ntt_mods[1];

  // Multiply two polynomials.
  // Make sure the length of result is at least: n + m - 1
  template <typename T>
  SL REQUIRES((is_builtin_integer_v<T> || is_extended_integer_v<T>))
      RETURN(void) PolyMul(const T* X, int64 n, const T* Y, int64 m, T* result,
                           int64 mod) {
    std::vector<uint64> tresult;

    internal::RunNttN<T>(X, n, Y, m, mod, &tresult, 1);

    const int64 result_size = n + m - 1;
    if (mod > 0) {
#if ENABLE_OPENMP
#pragma omp parallel for schedule(dynamic, 100000) if (n + m >= 100000)
#endif
      for (int64 i = 0; i < result_size; ++i) {
        const uint64 a = tresult[i];
        result[i] = a % mod;
      }
    } else {
#if ENABLE_OPENMP
#pragma omp parallel for schedule(dynamic, 100000) if (n + m >= 100000)
#endif
      for (int64 i = 0; i < result_size; ++i) {
        const uint64 a = tresult[i];
        result[i] = a;
      }
    }
  }

  template <typename T>
  SL REQUIRES((is_builtin_integer_v<T> || is_extended_integer_v<T>))
      RETURN(std::vector<std::vector<T>>)
          PolyMul2D(const std::vector<std::vector<T>>& X,
                    const std::vector<std::vector<T>>& Y, int64 mod) {
    const int64 n1 = sz(X);
    const int64 n2 = sz(Y);
    if (n1 == 0 || n2 == 0) {
      return {};
    }

    const int64 m1 = sz(X[0]);
    const int64 m2 = sz(Y[0]);
    if (m1 == 0 || m2 == 0) {
      return {};
    }

    std::vector<std::vector<uint64>> tresult;

    internal::RunNtt2DN<T>(X, Y, mod, &tresult, 1);

    std::vector<std::vector<T>> ret(n1 + n2 - 1,
                                    std::vector<int64>(m1 + m2 - 1, 0));
    if (mod > 0) {
      for (int64 i = 0; i < n1 + n2 - 1; ++i)
        for (int64 j = 0; j < m1 + m2 - 1; ++j) {
          ret[i][j] = tresult[i][j] % mod;
        }
    } else {
      for (int64 i = 0; i < n1 + n2 - 1; ++i)
        for (int64 j = 0; j < m1 + m2 - 1; ++j) {
          ret[i][j] = tresult[i][j];
        }
    }

    return ret;
  }
};
}  // namespace internal

static constexpr PolyMulCoeType kPolyMulSmallMod =
    internal::NttRunnerSmall::kMod;

// Multiply two polynomials.
// The length of result is at least n + m - 1.
POLY_MUL_IMPL(PolyMulSmall, internal::NttRunnerSmall::PolyMul)

template <typename T>
SL REQUIRES((is_builtin_integer_v<T> || is_extended_integer_v<T>))
    RETURN(std::vector<std::vector<T>>)
        PolyMul2DSmall(const std::vector<std::vector<T>>& X,
                       const std::vector<std::vector<T>>& Y, int64 mod) {
  return internal::NttRunnerSmall::PolyMul2D<T>(X, Y, mod);
}

namespace internal {
struct NttRunnerLarge {
 private:
  static constexpr uint64 M1 = ntt_mods[1];
  static constexpr uint64 M2 = ntt_mods[2];
  static constexpr uint64 INV_M2__M1 = 714693687804754632;

  using Self = NttRunnerLarge;

  template <typename T>
  SL T CombineMod(uint64 a, uint64 b, int64 mod) {
    const uint64 x = a >= b ? a - b : Self::M1 - b + a;
    const uint64 y = MulMod(x, Self::INV_M2__M1, Self::M1);
    const uint64 t = MulMod(y % mod, Self::M2 % mod, mod);
    return AddMod(t, b % mod, mod);
  }

  template <typename T>
  SL T CombineValue(uint64 a, uint64 b) {
#if PE_HAS_INT128
    const uint64 x = a >= b ? a - b : Self::M1 - b + a;
    const uint64 y =
        Uint128ModUint64(static_cast<uint128>(x) * Self::INV_M2__M1, Self::M1);
    const uint128 t = static_cast<uint128>(y) * Self::M2 + b;
    return static_cast<T>(t);
#else
    PE_ASSERT(0);
    return 0;
#endif
  }

 public:
  static constexpr PolyMulCoeType kMod =
      Prod<PolyMulCoeType>(ntt_mods[1], ntt_mods[2]);

  // Multiply two polynomials.
  // Make sure the length of result is at least: n + m - 1
  template <typename T>
  SL REQUIRES((is_builtin_integer_v<T> || is_extended_integer_v<T>))
      RETURN(void) PolyMul(const T* X, int64 n, const T* Y, int64 m, T* result,
                           int64 mod) {
    std::vector<uint64> tresult[2];

    internal::RunNttN<T>(X, n, Y, m, mod, tresult, 2);

    const int64 result_size = n + m - 1;
    if (mod > 0) {
#if ENABLE_OPENMP
#pragma omp parallel for schedule(dynamic, 100000) if (n + m >= 100000)
#endif
      for (int64 i = 0; i < result_size; ++i) {
        result[i] = CombineMod<T>(tresult[0][i], tresult[1][i], mod);
      }
    } else {
#if ENABLE_OPENMP
#pragma omp parallel for schedule(dynamic, 100000) if (n + m >= 100000)
#endif
      for (int64 i = 0; i < result_size; ++i) {
        result[i] = CombineValue<T>(tresult[0][i], tresult[1][i]);
      }
    }
  }

  template <typename T>
  SL REQUIRES((is_builtin_integer_v<T> || is_extended_integer_v<T>))
      RETURN(std::vector<std::vector<T>>)
          PolyMul2D(const std::vector<std::vector<T>>& X,
                    const std::vector<std::vector<T>>& Y, int64 mod) {
    const int64 n1 = sz(X);
    const int64 n2 = sz(Y);
    if (n1 == 0 || n2 == 0) {
      return {};
    }

    const int64 m1 = sz(X[0]);
    const int64 m2 = sz(Y[0]);
    if (m1 == 0 || m2 == 0) {
      return {};
    }

    std::vector<std::vector<uint64>> tresult[2];

    internal::RunNtt2DN<T>(X, Y, mod, tresult, 2);

    std::vector<std::vector<T>> result(n1 + n2 - 1,
                                       std::vector<T>(m1 + m2 - 1, 0));
    if (mod > 0) {
      for (int64 i = 0; i < n1 + n2 - 1; ++i)
        for (int64 j = 0; j < m1 + m2 - 1; ++j) {
          result[i][j] = CombineMod<T>(tresult[0][i][j], tresult[1][i][j], mod);
        }
    } else {
      for (int64 i = 0; i < n1 + n2 - 1; ++i)
        for (int64 j = 0; j < m1 + m2 - 1; ++j) {
          result[i][j] = CombineValue<T>(tresult[0][i][j], tresult[1][i][j]);
        }
    }

    return result;
  }
};

}  // namespace internal

static constexpr PolyMulCoeType kPolyMulLargeMod =
    internal::NttRunnerLarge::kMod;

// Multiply two polynomials.
// The length of result is at least n + m - 1.
POLY_MUL_IMPL(PolyMulLarge, internal::NttRunnerLarge::PolyMul)

template <typename T>
SL REQUIRES((is_builtin_integer_v<T> || is_extended_integer_v<T>))
    RETURN(std::vector<std::vector<T>>)
        PolyMul2DLarge(const std::vector<std::vector<T>>& X,
                       const std::vector<std::vector<T>>& Y, int64 mod) {
  return internal::NttRunnerLarge::PolyMul2D<T>(X, Y, mod);
}

namespace internal {
template <typename T>
SL REQUIRES((is_builtin_integer_v<T> || is_extended_integer_v<T>)) RETURN(void)
    PolyMulImpl(const T* X, int64 n, const T* Y, int64 m, T* result,
                int64 mod) {
  if (mod > 0) {
    if (PolyMulAcceptLengthAndMod(kPolyMulSmallMod, n, m, mod)) {
      return NttRunnerSmall::PolyMul(X, n, Y, m, result, mod);
    }
  } else {
    const T maxv1 = *std::max_element(X, X + n);
    const T maxv2 = *std::max_element(Y, X + m);
    if (PolyMulAcceptLengthAndValue(kPolyMulSmallMod, n, maxv1, m, maxv2)) {
      return NttRunnerSmall::PolyMul(X, n, Y, m, result, mod);
    }
  }
  return NttRunnerLarge::PolyMul(X, n, Y, m, result, mod);
}
}  // namespace internal

static constexpr PolyMulCoeType kPolyMulMod = internal::NttRunnerLarge::kMod;
POLY_MUL_IMPL(PolyMul, internal::PolyMulImpl)
}  // namespace ntt64

namespace ntt {
namespace internal {
template <typename T>
SL REQUIRES((is_builtin_integer_v<T> || is_extended_integer_v<T>)) RETURN(void)
    PolyMulImpl(const T* X, int64 n, const T* Y, int64 m, T* result,
                int64 mod) {
  using ImplFunctionPointerType =
      typename pe::PolyMulType<T>::CStyleFunctionPointer;
  using Item = std::pair<ImplFunctionPointerType, PolyMulCoeType>;
#if ENABLE_OPENMP
  constexpr std::array<std::pair<ImplFunctionPointerType, PolyMulCoeType>, 3>
      impls = {
          Item{
              &ntt32::internal::NttRunnerSmall::PolyMul<T>,
              ntt32::internal::NttRunnerSmall::kMod,
          },
          Item{
              &ntt32::internal::NttRunnerMedium::PolyMul<T>,
              ntt32::internal::NttRunnerMedium::kMod,
          },
          Item{
              &ntt32::internal::NttRunnerLarge::PolyMul<T>,
              ntt32::internal::NttRunnerLarge::kMod,
          },
      };
#else
  constexpr std::array<std::pair<ImplFunctionPointerType, PolyMulCoeType>, 5>
      impls = {
          Item{
              &ntt32::internal::NttRunnerSmall::PolyMul<T>,
              ntt32::internal::NttRunnerSmall::kMod,
          },
          Item{
              &ntt64::internal::NttRunnerSmall::PolyMul<T>,
              ntt64::internal::NttRunnerSmall::kMod,
          },
          Item{
              &ntt32::internal::NttRunnerMedium::PolyMul<T>,
              ntt32::internal::NttRunnerMedium::kMod,
          },
          Item{
              &ntt32::internal::NttRunnerLarge::PolyMul<T>,
              ntt32::internal::NttRunnerLarge::kMod,
          },
          Item{
              &ntt64::internal::NttRunnerLarge::PolyMul<T>,
              ntt64::internal::NttRunnerLarge::kMod,
          },
      };
#endif
  if (mod > 0) {
    for (int i = 0; i < impls.size(); ++i) {
      if (PolyMulAcceptLengthAndMod(impls[i].second, n, m, mod)) {
        return (*impls[i].first)(X, n, Y, m, result, mod);
      }
    }
  } else {
    const T maxv1 = *std::max_element(X, X + n);
    const T maxv2 = *std::max_element(Y, Y + m);
    for (int i = 0; i < impls.size(); ++i) {
      if (PolyMulAcceptLengthAndValue(impls[i].second, n, maxv1, m, maxv2)) {
        return (*impls[i].first)(X, n, Y, m, result, mod);
      }
    }
  }

  return ntt32::internal::NttRunnerEnormous::PolyMul(X, n, Y, m, result, mod);
}
}  // namespace internal

static constexpr PolyMulCoeType kPolyMulMod =
    ntt32::internal::NttRunnerEnormous::kMod;
POLY_MUL_IMPL(PolyMul, internal::PolyMulImpl)
}  // namespace ntt

}  // namespace pe

#endif