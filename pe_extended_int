#ifndef PE_EXTENDED_INT_
#define PE_EXTENDED_INT_

#include "pe_base"
#include "pe_type_traits"
#include "pe_int"
#include "pe_bit"
#include "pe_extended_unsigned_int"
#include "pe_extended_signed_int"

namespace std {
template <typename ET, bool is_builtin_integer>
struct numeric_limits<pe::ExtendedUnsignedIntImpl<ET, is_builtin_integer>> {
  using T = pe::ExtendedUnsignedIntImpl<ET, is_builtin_integer>;
  static constexpr T max() { return -1; }
  static constexpr T min() { return 0; }
  static constexpr T lowest() { return min(); }
  static constexpr bool is_signed = false;
  static constexpr bool is_unsigned = true;
  static constexpr bool is_integer = true;
};

template <typename ET, bool is_builtin_integer>
struct numeric_limits<pe::ExtendedSignedIntImpl<ET, is_builtin_integer>> {
  using T = pe::ExtendedSignedIntImpl<ET, is_builtin_integer>;
  static constexpr T max() {
    T t = -1;
    t.ResetHighestBit();
    return t;
  }
  static constexpr T min() {
    T t = 0;
    t.SetHighestBit();
    return t;
  }
  static constexpr T lowest() { return min(); }
  static constexpr bool is_signed = true;
  static constexpr bool is_unsigned = false;
  static constexpr bool is_integer = true;
};
}  // namespace std

namespace pe {
template <typename T>
SL REQUIRES((is_extended_integer_v<T>)) RETURN(int) IsZero(const T& x) {
  return x.IsZero();
}

template <typename T>
SL REQUIRES((is_extended_integer_v<T>)) RETURN(int) IntSign(const T& x) {
  return x.IntSign();
}

template <typename T>
SL REQUIRES((is_extended_integer_v<T>)) RETURN(int) IsEven(const T& x) {
  return x.IsEven();
}

template <typename T>
SL REQUIRES((is_extended_integer_v<T>)) RETURN(int) IsOdd(const T& x) {
  return x.IsOdd();
}

template <typename T0, typename T1>
SL REQUIRES((is_extended_integer_v<T0> && is_extended_integer_v<T1>))
    RETURN(int) SameParity(const T0& l, const T1& r) {
  return SameParity(l.LowerBits(), r.LowerBits());
}

template <typename T>
SL REQUIRES((is_extended_integer_v<T>)) RETURN(uint32) LowerBits(const T& x) {
  return x.LowerBits();
}

template <typename T>
SL REQUIRES((is_extended_integer_v<T> && pe_is_unsigned_v<T>)) RETURN(T)
    Abs(const T& x) {
  return x;
}

template <typename T>
SL REQUIRES((is_extended_integer_v<T> && pe_is_unsigned_v<T>)) RETURN(T)
    FAbs(const T& x) {
  return x;
}

template <typename T>
SL REQUIRES((is_extended_integer_v<T> && pe_is_signed_v<T>)) RETURN(T)
    Abs(const T& x) {
  return IntSign(x) >= 0 ? x : -x;
}

template <typename T>
SL REQUIRES((is_extended_integer_v<T> && pe_is_signed_v<T>)) RETURN(T)
    FAbs(const T& x) {
  return IntSign(x) >= 0 ? x : -x;
}

template <typename T, typename TN>
SL REQUIRES((is_extended_integer_v<T> && is_builtin_integer_v<TN>)) RETURN(T)
    Power(T x, TN n) {
  PE_ASSERT(n >= 0);
  T ret = 1;
  for (; n > 0; n >>= 1) {
    if (n & 1) ret *= x;
    if (n > 1) x *= x;
  }
  return ret;
}

template <typename T>
SL REQUIRES(is_extended_integer_v<T>) RETURN(std::tuple<T, T>)
    Div(const T& l, const T& r) {
  T remain;
  T d(l);
  T::DivideInplace(d, r, remain);
  return {d, remain};
}

template <typename T>
SL REQUIRES((is_extended_integer_v<T>)) RETURN(T)
    FloorDiv(const T& a, const T& b) {
  const int sign_a = IntSign(a);
  const int sign_b = IntSign(b);
  if (sign_a > 0 && sign_b > 0) {
    return a / b;
  }
  if (sign_a < 0 && sign_b < 0) {
    return a / b;
  }
  T q = a / b;
  if (((sign_a < 0) != (sign_b < 0)) && !IsZero(a % b)) {
    --q;
  }
  return q;
}

template <typename T>
SL REQUIRES((is_extended_integer_v<T>)) RETURN(T)
    CeilDiv(const T& a, const T& b) {
  const int sign_a = IntSign(a);
  const int sign_b = IntSign(b);
  if (sign_a > 0 && sign_b > 0) {
    return 1 + (a - 1) / b;
  }
  if (sign_a < 0 && sign_b < 0) {
    return 1 + (a + 1) / b;
  }
  T q = a / b;
  if (((sign_a < 0) == (sign_b < 0)) && !IsZero(a % b)) {
    ++q;
  }
  return q;
}

template <typename T, typename TM>
SL constexpr REQUIRES((is_extended_integer_v<T>)) RETURN(int_promotion_t<T, TM>)
    Mod(T a, TM mod) {
  return a % mod;
}

template <typename T, typename TN>
SL REQUIRES((is_extended_integer_v<T> && is_builtin_integer_v<TN>)) RETURN(T)
    PowerMod(T x, TN n, const T& mod) {
  PE_ASSERT(n >= 0);
  T ret = 1;
  for (; n > 0; n >>= 1) {
    if (n & 1) ret = ret * x % mod;
    if (n > 1) x = x * x % mod;
  }
  return ret;
}

template <typename T, typename TN, typename TM>
SL REQUIRES((is_extended_integer_v<T> && is_builtin_integer_v<TN> &&
             is_builtin_integer_v<TM>)) RETURN(T) PowerMod(T x, TN n, TM mod) {
  PE_ASSERT(n >= 0);
  T ret = 1;
  for (; n > 0; n >>= 1) {
    if (n & 1) ret = ret * x % mod;
    if (n > 1) x = x * x % mod;
  }
  return ret;
}

template <typename TT, typename T>
SL REQUIRES((is_extended_integer_v<T>)) RETURN(TT) ToInt(const T& x) {
  return x.template ToInt<TT>();
}

template <typename TT, typename T>
SL REQUIRES((is_extended_integer_v<T>)) RETURN(TT) ToFloat(const T& x) {
  return x.template ToFloat<TT>();
}

template <typename T>
SL REQUIRES((is_extended_integer_v<T>)) RETURN(std::string)
    ToString(const T& x) {
  return x.ToString();
}

template <typename T>
SL REQUIRES((is_extended_integer_v<T>)) RETURN(std::string)
    to_string(const T& x) {
  return ToString(x);
}
}  // namespace pe

#if PE_HAS_CPP20
namespace pe {
template <class T>
concept PeExtendedInteger = requires(T v) {
  requires static_cast<bool>(is_extended_integer_v<T>);
  requires PeArithmeticOperation<T>;
  requires PeSelfOperation<T>;
  requires PeComparable<T>;
  requires PeIntegerUtil<T>;
};

static_assert(PeExtendedInteger<ExtendedUnsignedInt<uint64>>);
static_assert(PeExtendedInteger<ExtendedSignedInt<uint64>>);
#if PE_HAS_INT128
static_assert(PeExtendedInteger<ExtendedUnsignedInt<uint128>>);
static_assert(PeExtendedInteger<ExtendedSignedInt<uint128>>);
#endif
}  // namespace pe
#endif

namespace pe {
using uint128e = ExtendedUnsignedInt<uint64>;
using int128e = ExtendedSignedInt<uint64>;

#if PE_HAS_INT128
using uint256e = ExtendedUnsignedInt<uint128>;
using int256e = ExtendedSignedInt<uint128>;
#else
using uint256e = ExtendedUnsignedInt<uint128e>;
using int256e = ExtendedSignedInt<uint128e>;
#endif

using uint512e = ExtendedUnsignedInt<uint256e>;
using uint1024e = ExtendedUnsignedInt<uint512e>;

using int512e = ExtendedSignedInt<uint256e>;
using int1024e = ExtendedSignedInt<uint512e>;

}  // namespace pe
#endif
