#ifndef PE_BI32_
#define PE_BI32_

#include "pe_base"
#include "pe_type_traits"
#include "pe_int"
#include "pe_extended_int"
#include "pe_nt"
#include "pe_fraction"
#include "pe_poly_base"
#include "pe_gbi"

namespace pe {
namespace internal {
static constexpr struct alloc_mem {
} alloc_mem_tag;

static constexpr struct zero_initialize {
} zero_initialize_tag;

// Predefined allocator
struct BiAllocatorStd {
  static unsigned int* Allocate(int& length) {
    length = std::max(((length + 3) >> 2) << 2, 1);
    return new unsigned int[length];
  }
  static void Deallocate(unsigned int* data) { delete[] data; }
};

template <int SIZE>
struct BiAllocatorFixedSizeImpl {
  std::vector<unsigned int*> available;
  int top;

  BiAllocatorFixedSizeImpl() { top = 0; }

  unsigned int* Allocate(int& length) {
    if (length > SIZE) {
      dbg(length);
    }
    PE_ASSERT(length <= SIZE);
    length = SIZE;
    if (top == static_cast<int>(std::size(available))) {
      available.push_back(new unsigned int[SIZE]);
    }
    return available[top++];
  }

  void Deallocate(unsigned int* ptr) { available[--top] = ptr; }
};

static BiAllocatorFixedSizeImpl<1 << 16> allocator_16;
static BiAllocatorFixedSizeImpl<1 << 20> allocator_20;

static auto& allocator_impl = allocator_16;

struct BiAllocatorFixedSize {
  static unsigned int* Allocate(int& length) {
    return allocator_impl.Allocate(length);
  }
  static void Deallocate(unsigned int* data) {
    allocator_impl.Deallocate(data);
  }
};
}  // namespace internal

// Configuration of BigInteger.
using BiAllocator = internal::BiAllocatorStd;

// Class layout principle:
// Idealy, if a method A uses method B, B should be declared before A.

// Class layout:
// Usefule constants
// Utility function for constructors
// Constructor and operator=
// Internal constructors
// Implementation internals
// Normal methods
// Integer concept methods
// Unary operators
// Self operators
// Friend binary operators
// Member fields
class BigInteger {
  static_assert(sizeof(unsigned int) == sizeof(uint32));

 public:
  static constexpr unsigned int max_32bit_value = 0xFFFFFFFF;
  static constexpr uint64 bit32_value = 1ULL << 32;
  static constexpr unsigned int output_mod = 1000000000;
  static constexpr unsigned int output_mod_dig = 9;

  static constexpr unsigned int div32_bit = 5;
  static constexpr unsigned int mod32_mask = 31;

  static constexpr int div_bit_size = 4;

 private:
  template <typename T>
  REQUIRES((is_builtin_integer_v<T> && pe_is_unsigned_v<T>))
  RETURN(void) FromNativeInt(T value) {
    if (value == 0) {
      Reserve(1);
      data_[0] = 0;
      sign_ = 0;
      return;
    }

    if (sizeof(T) <= 8) {
      SetNativeUInt64AndKeepSign(value);
    } else {
      int need = 0;
      for (T t = value; t > 0; ++need) {
#if defined(COMPILER_MSVC) || defined(COMPILER_CLANG)
        t >>= 16;
        t >>= 16;
#else
        t >>= 32;
#endif
      }
      Reserve(need);

      pos_ = -1;
      for (T t = value; t > 0;) {
        data_[++pos_] = t & BigInteger::max_32bit_value;
#if defined(COMPILER_MSVC) || defined(COMPILER_CLANG)
        t >>= 16;
        t >>= 16;
#else
        t >>= 32;
#endif
      }
    }
    sign_ = 1;
  }

  template <typename T>
  REQUIRES((is_builtin_integer_v<T> && pe_is_signed_v<T>))
  RETURN(void) FromNativeInt(T value) {
    if (value == 0) {
      Reserve(1);
      data_[0] = 0;
      sign_ = 0;
      return;
    }

    using UnsignedT = pe_make_unsigned_t<T>;
    if (value > 0) {
      FromNativeInt<UnsignedT>(static_cast<UnsignedT>(value));
    } else {
      // Note: it works for value = T::min()
      FromNativeInt<UnsignedT>(static_cast<UnsignedT>(-value));
      sign_ = -1;
    }
  }

  void FromUInt32Vector(const std::vector<uint32>& v) {
    if (std::empty(v)) {
      Reserve(1);
      data_[0] = 0;
      sign_ = 0;
      return;
    }

    const unsigned int n = static_cast<unsigned int>(std::size(v));
    Reserve(n);

    std::copy(v.begin(), v.end(), data_);

    FixLeadingZeros();
    FixSign();
  }

  template <typename T>
  REQUIRES((is_extended_integer_v<T> && pe_is_unsigned_v<T>))
  RETURN(void) FromExtendedInt(const T& value) {
    FromUInt32Vector(value.ToUInt32Vector());
  }

  template <typename T>
  REQUIRES((is_extended_integer_v<T> && pe_is_signed_v<T>))
  RETURN(void) FromExtendedInt(const T& value) {
    if (value.IntSign() >= 0) {
      FromUInt32Vector(value.ToUInt32Vector());
    } else {
      T tmp = value;
      tmp.MakeAbs();
      FromUInt32Vector(tmp.ToUInt32Vector());
      sign_ = -1;
    }
  }

  void FromString(const std::string& str) {
    const int n = static_cast<int>(std::size(str));
    if (n == 0) {
      Reserve(1);
      data_[0] = 0;
      sign_ = 0;
      return;
    }
    std::vector<unsigned int> value(n);
    for (int i = 0, j = n - 1; i < n; ++i, --j) {
      value[j] = str[i] - '0';
    }

    int now = n - 1;
    while (now > 0 && value[now] == 0) --now;

    std::vector<unsigned int> result;
    do {
      uint64 add = 0;
      for (int i = now; i > 0; --i) {
        const uint64 x = add + value[i];
        const uint64 next_add = (x & max_32bit_value) * 10;
        value[i] = x >> 32;
        add = next_add;
      }
      uint64 x = add + value[0];
      value[0] = x >> 32;
      result.push_back(x & max_32bit_value);
      while (now > 0 && value[now] == 0) --now;
    } while (now > 0 || value[now] > 0);

    Reserve(static_cast<int>(std::size(result)));

    sign_ = 1;
    pos_ = std::max<int>(0, static_cast<int>(std::size(result)) - 1);
    std::copy(result.begin(), result.end(), data_);
    FixLeadingZeros();
  }

  void Reserve(int new_size) {
    PE_ASSERT(new_size > 0);
    unsigned int* old_data = nullptr;
    if (data_) {
      if (new_size > buffer_length_) {
        old_data = data_;
      } else {
        return;
      }
    }

    data_ = BiAllocator::Allocate(new_size);
    if (old_data != nullptr) {
      // copy used data only.
      std::copy(old_data, old_data + pos_ + 1, data_);
      BiAllocator::Deallocate(old_data);
    }
    buffer_length_ = new_size;
  }

  void FixLeadingZeros() const {
    while (pos_ > 0 && data_[pos_] == 0) --pos_;
  }

  void FixSign() const {
    if (pos_ == 0 && data_[0] == 0) sign_ = 0;
  }

  template <typename T>
  static void FixSize(std::vector<T>& v) {
    if (std::empty(v)) v.push_back(0);
    int now = static_cast<int>(std::size(v)) - 1;
    while (now > 0 && v[now] == 0) --now;
    v.resize(now + 1);
  }

 public:
  // constructors, destructors, value semantics.
  BigInteger() : BigInteger(internal::zero_initialize_tag) {
    Reserve(1);
    data_[0] = 0;
    sign_ = 0;
  }

  template <typename T, typename = std::enable_if_t<is_builtin_integer_v<T>>>
  BigInteger(T value) : BigInteger(internal::zero_initialize_tag) {
    FromNativeInt(value);
  }

  template <typename T, typename = std::enable_if_t<is_builtin_integer_v<T>>>
  BigInteger(const std::vector<T>& v)
      : BigInteger(internal::zero_initialize_tag) {
    FromUInt32Vector(v);
  }

  template <typename T, typename = std::enable_if_t<is_extended_integer_v<T>>>
  BigInteger(const T& value) : BigInteger(internal::zero_initialize_tag) {
    FromExtendedInt(value);
  }

  BigInteger(const std::string& str)
      : BigInteger(internal::zero_initialize_tag) {
    FromString(str);
  }

  BigInteger(const BigInteger& other)
      : BigInteger(internal::zero_initialize_tag) {
    ASSUME(other.buffer_length_ >= other.pos_ + 1);
    Reserve(other.buffer_length_);
    sign_ = other.sign_;
    pos_ = other.pos_;
    std::copy(other.data_, other.data_ + other.pos_ + 1, data_);
  }

  BigInteger(BigInteger&& other) noexcept
      : BigInteger(internal::zero_initialize_tag) {
    std::swap(data_, other.data_);
    std::swap(buffer_length_, other.buffer_length_);
    std::swap(sign_, other.sign_);
    std::swap(pos_, other.pos_);
  }

  ~BigInteger() {
    if (data_) {
      BiAllocator::Deallocate(data_);
    }
  }

  template <typename T,
            typename TT = REQUIRES((is_builtin_integer_v<T>)) RETURN(T)>
  BigInteger& operator=(T value) {
    return *this = BigInteger(value);
  }

  BigInteger& operator=(const BigInteger& other) {
    return *this = BigInteger(other);
  }

  BigInteger& operator=(BigInteger&& other) noexcept {
    std::swap(data_, other.data_);
    std::swap(buffer_length_, other.buffer_length_);
    std::swap(sign_, other.sign_);
    std::swap(pos_, other.pos_);
    return *this;
  }

 private:
  // Internal constructor
  BigInteger(int size, internal::alloc_mem)
      : BigInteger(internal::zero_initialize_tag) {
    Reserve(size);
    data_[0] = 0;
    sign_ = 0;
  }

  BigInteger(const BigInteger& other, int min_buffer)
      : BigInteger(internal::zero_initialize_tag) {
    ASSUME(other.buffer_length_ >= other.pos_ + 1);
    Reserve(std::max(other.buffer_length_, min_buffer));
    sign_ = other.sign_;
    pos_ = other.pos_;
    std::copy(other.data_, other.data_ + other.pos_ + 1, data_);
  }

  BigInteger(internal::zero_initialize)
      : data_(nullptr), buffer_length_(0), sign_(0), pos_(0) {}

 private:
  // Implementation internals

  // Operations on native integer.
  template <typename T>
  SL REQUIRES((is_builtin_integer_v<T> && pe_is_signed_v<T>)) RETURN(T)
      GetAbsValue(T x) {
    return x >= 0 ? x : -x;
  }

  template <typename T>
  SL REQUIRES((is_builtin_integer_v<T> && pe_is_unsigned_v<T>)) RETURN(T)
      GetAbsValue(T x) {
    return x;
  }

  template <typename T>
  SL REQUIRES((is_builtin_integer_v<T> && pe_is_signed_v<T>)) RETURN(T)
      GetNegValue(T x) {
    return -x;
  }

  template <typename T>
  SL REQUIRES((is_builtin_integer_v<T> && pe_is_unsigned_v<T>)) RETURN(T)
      GetNegValue(T x) {
    return x;
  }

  template <typename T>
  REQUIRES((is_builtin_integer_v<T>))
  RETURN(std::vector<T>) ToKBits(int k, int fix_size = 1) const {
    if (k == 1) {
      return ToBinary<T>(fix_size);
    }
    const unsigned mask = (1U << k) - 1;
    const int blocks = 32 / k;
    std::vector<T> ret;
    for (int i = 0; i <= pos_; ++i) {
      unsigned int t = data_[i];
      for (int j = 0; j < blocks; ++j) {
        ret.push_back(t & mask);
        t >>= k;
      }
    }
    if (fix_size) {
      FixSize(ret);
    }
    return ret;
  }

  template <typename T>
  REQUIRES((is_builtin_integer_v<T>))
  RETURN(void) FromKBits(int k, const std::vector<T>& v) {
    if (k == 1) {
      FromBinary(v);
      return;
    }
    if (std::empty(v)) {
      Reserve(1);
      data_[0] = 0;
      sign_ = 0;
      return;
    }

    const unsigned int n = static_cast<unsigned int>(std::size(v));
    unsigned int need = (n * k + 31) >> 5;
    Reserve(need);

    unsigned int value = 0;
    int offset = 0;
    for (unsigned i = 0; i < n; ++i) {
      if (v[i]) {
        value |= v[i] << offset;
      }
      offset += k;
      if (offset == 32) {
        data_[pos_++] = value;
        value = 0;
        offset = 0;
      }
    }
    if (value) {
      data_[pos_++] = value;
    }
    if (pos_ > 0) {
      --pos_;
    }
    sign_ = 1;
    FixLeadingZeros();
    FixSign();
  }

  template <typename T>
  REQUIRES((is_builtin_integer_v<T>))
  RETURN(std::vector<T>) ToBinary(int fix_size = 1) const {
    std::vector<T> ret;
    for (int i = 0; i <= pos_; ++i) {
      unsigned int t = data_[i];
      for (int j = 0; j < 32; ++j) {
        ret.push_back(t & 1);
        t >>= 1;
      }
    }
    if (fix_size) {
      FixSize(ret);
    }
    return ret;
  }

  template <typename T>
  REQUIRES((is_builtin_integer_v<T>))
  RETURN(void) FromBinary(const std::vector<T>& v) {
    if (std::empty(v)) {
      Reserve(1);
      data_[0] = 0;
      sign_ = 0;
      return;
    }

    const unsigned int n = static_cast<unsigned int>(std::size(v));
    unsigned int need = (n + 31) >> 5;
    Reserve(need);

    unsigned int value = 0;
    unsigned int flag = 1;
    for (unsigned i = 0; i < n; ++i) {
      if (v[i]) {
        value |= flag;
      }
      flag <<= 1;
      if (((i + 1) & mod32_mask) == 0) {
        data_[pos_++] = value;
        value = 0;
        flag = 1;
      }
    }
    if (n & mod32_mask) {
      data_[pos_++] = value;
    }
    --pos_;
    sign_ = 1;
    FixLeadingZeros();
    FixSign();
  }

  void SetNativeUInt64AndKeepSign(uint64 v) {
    if (v <= max_32bit_value) {
      Reserve(1);
      data_[0] = static_cast<unsigned>(v);
      pos_ = 0;
    } else {
      Reserve(2);
      data_[0] = v & max_32bit_value;
      data_[1] = v >> 32;
      pos_ = 1;
    }
  }

  static int AbsCompare(const BigInteger& l, const BigInteger& r) {
    if (std::size(l) <= 2 && std::size(r) <= 2) {
      const uint64 a = l.ToInt<uint64>();
      const uint64 b = r.ToInt<uint64>();
      if (a == b) return 0;
      return a > b ? 1 : -1;
    }

    int left_pos = l.pos_;
    int right_pos = r.pos_;

    if (left_pos != right_pos) {
      return left_pos > right_pos ? 1 : -1;
    }

    for (; left_pos >= 0 && l[left_pos] == r[left_pos]; --left_pos) {
      ;
    }

    return left_pos >= 0 ? (l[left_pos] > r[left_pos] ? 1 : -1) : 0;
  }

  static void AbsAddInplace(BigInteger& self, const BigInteger& other) {
    if (std::size(self) <= 2 && std::size(other) <= 1 ||
        std::size(self) <= 1 && std::size(other) <= 2) {
      self.SetNativeUInt64AndKeepSign(self.ToInt<uint64>() +
                                      other.ToInt<uint64>());
      return;
    }

    self.Reserve(std::size(self) + std::size(other) + 1);

    const int max_pos = std::max(self.pos_, other.pos_);
    const int min_pos = std::min(self.pos_, other.pos_);

    int idx = 0;
    unsigned int inc = 0;

    while (idx <= min_pos) {
      uint64 t = static_cast<uint64>(self[idx]) + other[idx] + inc;
      self[idx++] = t & max_32bit_value;
      inc = t >> 32;
    }

    const unsigned int* large_data =
        self.pos_ > other.pos_ ? self.data_ : other.data_;
    while (idx <= max_pos) {
      uint64 t = static_cast<uint64>(large_data[idx]) + inc;
      self[idx++] = t & max_32bit_value;
      inc = t >> 32;
    }

    if (inc) {
      self[idx++] = inc;
    }

    self.pos_ = std::max(idx - 1, 0);
    self.FixLeadingZeros();
  }

  static void AbsSubtractInplace(BigInteger& self, const BigInteger& other) {
    PE_ASSERT(BigInteger::AbsCompare(self, other) >= 0);

    if (std::size(self) <= 2 && std::size(other) <= 2) {
      self.SetNativeUInt64AndKeepSign(self.ToInt<uint64>() -
                                      other.ToInt<uint64>());
      return;
    }

    int max_pos = self.pos_;
    int min_pos = other.pos_;

    unsigned int borrow = 0;
    for (int curr = 0; curr <= min_pos; ++curr) {
      unsigned int next_borrow = 0;
      uint64 t = self[curr];
      while (t < static_cast<uint64>(other[curr]) + borrow) {
        next_borrow++;
        t += bit32_value;
      }
      self[curr] = static_cast<unsigned>(t - other[curr] - borrow);
      borrow = next_borrow;
    }
    for (int curr = min_pos + 1; curr <= max_pos; ++curr) {
      unsigned int next_borrow = 0;
      uint64 t = self[curr];
      while (t < borrow) {
        next_borrow++;
        t += bit32_value;
      }
      self[curr] = static_cast<unsigned>(t - borrow);
      borrow = next_borrow;
    }
    self.FixLeadingZeros();
  }

#if HAS_POLY_MUL_NTT32
  static BigInteger AbsMultiplyNtt(const BigInteger& l, const BigInteger& r) {
    const int n = std::size(l) << 1;
    const int m = std::size(r) << 1;

    std::vector<uint64> X(n), Y(m);

    for (int i = 0; i <= l.pos_; ++i) {
      X[i << 1] = l[i] & 65535u;
      X[(i << 1) + 1] = l[i] >> 16;
    }
    for (int i = 0; i <= r.pos_; ++i) {
      Y[i << 1] = r[i] & 65535;
      Y[(i << 1) + 1] = r[i] >> 16;
    }
    const int allocate_size = n + m + 8;
    const int result_size = n + m - 1;
    std::vector<uint64> result = ntt32::PolyMulSmall(X, Y, 0);
    result.resize(allocate_size);
    uint64 inc = 0;
    for (int i = 0; i < result_size; ++i) {
      uint64 t = inc + result[i];
      result[i] = t & 65535u;
      inc = t >> 16;
    }
    int now = result_size;
    while (inc > 0) {
      result[now++] = inc & 65535u;
      inc >>= 16;
    }
    if (now & 1) {
      result[now++] = 0;
    }

    BigInteger ret(now >> 1, internal::alloc_mem_tag);
    for (int i = 0; i < now; i += 2) {
      ret[i >> 1] = static_cast<unsigned>((result[i + 1] << 16) | result[i]);
    }
    ret.pos_ = (now >> 1) - 1;
    ret.sign_ = 1;
    ret.FixLeadingZeros();
    return ret;
  }
#endif

  static BigInteger AbsMultiply(const BigInteger& l, const BigInteger& r) {
    if (std::size(l) <= 1 && std::size(r) <= 1) {
      return static_cast<uint64>(l[0]) * r[0];
    }
    if (std::size(r) <= 1) {
      return AbsMultiply(l, r.ToInt<uint64>());
    }
    if (std::size(l) <= 1) {
      return AbsMultiply(r, l.ToInt<uint64>());
    }

#if HAS_POLY_MUL_NTT32
    {
      // If the cost of ntt is less than normal multiplication, then use ntt.
      const uint64 cost1 = static_cast<uint64>(std::size(l)) * std::size(r);
      const uint64 len = (std::size(l) + std::size(r)) << 1;
      int64 aligned_len = 1;
      int bit = 1;
      while (aligned_len < static_cast<int64>(len)) aligned_len <<= 1, ++bit;
      const uint64 cost2 = aligned_len * bit * 3;

      if (cost2 * 2 < cost1) {
        return AbsMultiplyNtt(l, r);
      }
    }
#endif

    const int left_pos = l.pos_;
    const int right_pos = r.pos_;

    const int new_size = std::size(l) + std::size(r) + 1;

    BigInteger ret(new_size, internal::alloc_mem_tag);
    std::fill(ret.data_, ret.data_ + new_size, 0);

    for (int i = 0; i <= right_pos; ++i) {
      unsigned int t = r[i];
      uint64 inc = 0;
      int j = 0;
      for (; j <= left_pos; ++j) {
        inc += static_cast<uint64>(t) * l[j] + ret[i + j];
        ret[i + j] = inc & max_32bit_value;
        inc >>= 32;
      }
      for (; inc; inc >>= 32) {
        ret[i + j++] = inc & max_32bit_value;
      }
    }
    ret.pos_ = left_pos + right_pos + 2;
    ret.FixLeadingZeros();
    return ret;
  }

  template <typename T>
  static BigInteger AbsMultiply(const BigInteger& l, T r) {
    static_assert(pe_is_unsigned_v<T>, "T must be unsigned");
    if (r > max_32bit_value) {
      return AbsMultiply(l, BigInteger(r));
    }
    BigInteger ret(l, std::size(l) + std::size(BigInteger(r)) + 1);
    AbsMultiplyInplace(ret, r);
    return ret;
  }

  template <typename T>
  static void AbsMultiplyInplace(BigInteger& self, T other) {
    static_assert(pe_is_unsigned_v<T>, "T must be unsigned");
    if (other > max_32bit_value) {
      self = AbsMultiply(self, BigInteger(other));
      return;
    }

    if (std::size(self) <= 1) {
      self.SetNativeUInt64AndKeepSign(static_cast<uint64>(self[0]) * other);
      return;
    }

    self.Reserve(std::size(self) + std::size(BigInteger(other)) + 1);

    uint64 inc = 0;
    int top = 0;
    for (int i = 0; i <= self.pos_; ++i) {
      uint64 v = static_cast<uint64>(self[i]) * other + inc;
      self[top++] = v & max_32bit_value;
      inc = v >> 32;
    }

    while (inc > 0) {
      self[top++] = inc & max_32bit_value;
      inc >>= 32;
    }

    self.pos_ = top - 1;
    self.FixLeadingZeros();
  }

  static BigInteger AbsDivide(const BigInteger& l, const BigInteger& r,
                              BigInteger& remain) {
    if (std::size(l) <= 2 && std::size(r) <= 2) {
      const uint64 a = l.ToInt<uint64>();
      const uint64 b = r.ToInt<uint64>();
      remain = a % b;
      return a / b;
    }

    const int t = AbsCompare(l, r);
    if (t < 0) {
      remain = l;
      remain.sign_ = 1;
      return 0;
    }
    if (t == 0) {
      remain = 0;
      return 1;
    }

    const int k = div_bit_size;

    std::vector<unsigned int> rb;
    std::vector<unsigned int> rr = internal::AbsDivide<unsigned int>(
        k, l.ToKBits<unsigned int>(k), r.ToKBits<unsigned int>(k), rb);
    remain.FromKBits(k, rb);

    BigInteger ret(internal::zero_initialize_tag);
    ret.FromKBits(k, rr);

    return ret;
  }

  static BigInteger AbsDivide(const BigInteger& l, const BigInteger& r) {
    if (std::size(l) <= 2 && std::size(r) <= 2) {
      const uint64 a = l.ToInt<uint64>();
      const uint64 b = r.ToInt<uint64>();
      return a / b;
    }

    const int t = AbsCompare(l, r);
    if (t < 0) {
      return 0;
    }
    if (t == 0) {
      return 1;
    }

    const int k = div_bit_size;

    std::vector<unsigned int> rb;
    std::vector<unsigned int> rr = internal::AbsDivide<unsigned int>(
        k, l.ToKBits<unsigned int>(k), r.ToKBits<unsigned int>(k), rb);

    BigInteger ret(internal::zero_initialize_tag);
    ret.FromKBits(k, rr);

    return ret;
  }

  template <typename T>
  static BigInteger AbsDivide(const BigInteger& l, T r, T& remain) {
    static_assert(pe_is_unsigned_v<T>, "T must be unsigned");
    static_assert(sizeof(T) <= 8, "T must be at most 64-bit");
    if (std::size(l) <= 2) {
      const uint64 a = l.ToInt<uint64>();
      const uint64 b = r;
      remain = a % b;
      return a / b;
    }

    BigInteger t(l);
    AbsDivideInplace(t, r, remain);
    return t;
  }

  template <typename T>
  static BigInteger AbsDivide(const BigInteger& l, T r) {
    static_assert(pe_is_unsigned_v<T>, "T must be unsigned");
    static_assert(sizeof(T) <= 8, "T must be at most 64-bit");
    if (std::size(l) <= 2) {
      const uint64 a = l.ToInt<uint64>();
      const uint64 b = r;
      return a / b;
    }

    BigInteger t(l);
    T remain;
    AbsDivideInplace(t, r, remain);
    return t;
  }

  template <typename T>
  static void AbsDivideInplace(BigInteger& self, T other, T& remain) {
    static_assert(pe_is_unsigned_v<T>, "T must be unsigned");
    static_assert(sizeof(T) <= 8, "T must be at most 64-bit");

    self.FixLeadingZeros();
    if (std::size(self) <= 2) {
      const uint64 a = self.ToInt<uint64>();
      const uint64 b = other;
      remain = static_cast<T>(a % b);
      self.SetNativeUInt64AndKeepSign(a / b);
      return;
    }
#if !PE_HAS_INT128
    if (sizeof(T) > 4) {
      BigInteger tmp_remain;
      self = AbsDivide(self, BigInteger(other), tmp_remain);
      remain = tmp_remain.ToInt<T>();
      return;
    }
#else
    if (other <= max_32bit_value) {
      uint64 add = 0;
      for (int i = self.pos_; i > 0; --i) {
        const uint64 x = add + self.data_[i];
        const uint64 next_add = (x % other) << 32;
        self.data_[i] = x / other;
        add = next_add;
      }
      const uint64 x = add + self.data_[0];
      self.data_[0] = x / other;
      remain = x % other;
      self.FixLeadingZeros();
    } else {
      uint64 add = 0;
      for (int i = self.pos_; i > 0; --i) {
        const uint128 x = (static_cast<uint128>(add) << 32) + self.data_[i];
        const uint64 next_add = x % other;
        self.data_[i] = x / other;
        add = next_add;
      }
      const uint128 x = (static_cast<uint128>(add) << 32) + self.data_[0];
      self.data_[0] = x / other;
      remain = x % other;
      self.FixLeadingZeros();
    }
#endif
  }

 public:
  const unsigned int* data() const { return data_; }

  unsigned int* data() { return data_; }

  int size() const { return pos_ + 1; }

  unsigned int operator[](int idx) const { return data_[idx]; }

  unsigned int& operator[](int idx) { return data_[idx]; }

  int sign() const { return sign_; }

  int CompareTo(const BigInteger& other) const {
    if (sign_ != other.sign_) {
      return sign_ < other.sign_ ? -1 : 1;
    }
    if (sign_ == 0) {
      return 0;
    }
    const int t = BigInteger::AbsCompare(*this, other);
    return sign_ > 0 ? t : -t;
  }

  int IntSign() const { return sign_; }

  bool IsZero() const { return sign_ == 0; }

  int IsEven() const { return data_[0] & 1 ? 0 : 1; }

  int IsOdd() const { return data_[0] & 1 ? 1 : 0; }

  unsigned int LowerBits() const { return static_cast<unsigned int>(data_[0]); }

  template <typename T>
  REQUIRES((is_builtin_integer_v<T> && pe_is_signed_v<T>))
  RETURN(T) ToInt() const {
    using UnsignedT = pe_make_unsigned_t<T>;
    UnsignedT v = ToInt<UnsignedT>();
    if (IntSign() < 0) {
      v = ~v + 1;
    }
    return static_cast<T>(v);
  }

  template <typename T>
  REQUIRES((is_builtin_integer_v<T> && pe_is_unsigned_v<T>))
  RETURN(T) ToInt() const {
    T result = 0;
    for (int i = pos_; i >= 0; --i) {
#if defined(COMPILER_MSVC) || defined(COMPILER_CLANG)
      result <<= 16;
      result = (result << 16) | data_[i];
#else
      result = (result << 32) | data_[i];
#endif
    }
    return result;
  }

  template <typename T>
  T ToFloat() const {
    T result = 0;
    for (int i = pos_; i >= 0; --i) {
      result = result * 4294967296 + data_[i];
    }
    if (sign_ < 0) {
      result = -result;
    }
    return result;
  }

  void SetBit(int idx) {
    const int x = idx >> div32_bit;
    const int y = idx & mod32_mask;
    data_[x] = pe::SetBit(data_[x], y);
  }

  void ResetBit(int idx) {
    const int x = idx >> div32_bit;
    const int y = idx & mod32_mask;
    data_[x] = pe::ResetBit(data_[x], y);
  }

  int GetBit(int idx) const {
    const int x = idx >> div32_bit;
    const int y = idx & mod32_mask;
    return x > pos_ ? 0 : (data_[x] >> y) & 1;
  }

  void RevBit(int idx) {
    const int x = idx >> div32_bit;
    const int y = idx & mod32_mask;
    data_[x] = pe::RevBit(data_[x], y);
  }

  int BitCount() const {
    int ret = 0;
    for (int i = pos_; i >= 0; --i) ret += pe_popcount(data_[i]);
    return ret;
  }

  int BitHeight() const {
    int ret = pos_ << div32_bit;
    int hiCnt = 0;
    unsigned int v = data_[pos_];
    for (unsigned int x = 1; v; ++hiCnt, x <<= 1, v >>= 1) {
      ;
    }
    return ret + hiCnt;
  }

  std::string ToString() const {
    BigInteger t(*this);
    std::vector<unsigned int> mods;
    t.FixLeadingZeros();
    t.FixSign();
    std::stringstream ss;
    if (t.sign_ == -1) {
      ss << "-";
    }

    do {
      uint64 add = 0;
      for (int i = t.pos_; i > 0; --i) {
        const uint64 x = add + t.data_[i];
        const uint64 next_add = (x % output_mod) << 32;
        t.data_[i] = static_cast<unsigned>(x / output_mod);
        add = next_add;
      }
      uint64 x = add + t.data_[0];
      t.data_[0] = static_cast<unsigned>(x / output_mod);
      mods.push_back(x % output_mod);
      t.FixLeadingZeros();
      t.FixSign();
    } while (!t.IsZero());

    int idx = static_cast<int>(std::size(mods)) - 1;
    char buff[32];
    sprintf(buff, "%u", mods[idx--]);
    ss << buff;
    for (; idx >= 0; --idx) {
      sprintf(buff, "%0*u", output_mod_dig, mods[idx]);
      ss << buff;
    }
    return ss.str();
  }

  std::string to_string() const { return ToString(); }

  BigInteger Difference(const BigInteger& other) const {
    int t = CompareTo(other);
    if (t == 0) {
      return 0;
    }
    return t > 0 ? *this - other : other - *this;
  }

  void Dump() const {
    dbg(sign_);
    dbg(pos_);
    dbg(buffer_length_);
    for (int i = 0; i <= pos_; ++i) std::cerr << data_[i] << ",";
    std::cerr << std::endl;
  }

 public:
  // Operators
  const BigInteger& operator+() const { return *this; }

  BigInteger operator-() const {
    BigInteger ret(*this);
    ret.sign_ = -ret.sign_;
    return ret;
  }

  BigInteger operator~() const {
    BigInteger ret(*this);
    for (int i = 0; i < ret.pos_; ++i) {
      ret[i] ^= max_32bit_value;
    }
    unsigned int y = ret[ret.pos_];
    for (unsigned int x = 1; y; x <<= 1, y >>= 1) {
      ret[ret.pos_] ^= x;
    }

    ret.FixLeadingZeros();
    ret.FixSign();

    return ret;
  }

  BigInteger& operator+=(const BigInteger& other) {
    if (other.IsZero()) {
      // Do nothing
    } else if (IsZero()) {
      *this = other;
    } else if (sign() == other.sign()) {
      AbsAddInplace(*this, other);
      FixSign();
    } else {
      int c = AbsCompare(*this, other);
      if (c == 0) {
        pos_ = 0;
        data_[0] = 0;
        sign_ = 0;
      } else if (c > 0) {
        AbsSubtractInplace(*this, other);
        FixSign();
      } else {
        BigInteger t(other);
        AbsSubtractInplace(t, *this);
        t.FixSign();
        *this = std::move(t);
      }
    }
    return *this;
  }

  BigInteger& operator-=(const BigInteger& other) {
    if (other.IsZero()) {
      // Do nothing
    } else if (IsZero()) {
      *this = other;
      sign_ = -other.sign_;
    } else if (sign() != other.sign()) {
      AbsAddInplace(*this, other);
      FixSign();
    } else {
      int c = AbsCompare(*this, other);
      if (c == 0) {
        pos_ = 0;
        data_[0] = 0;
        sign_ = 0;
      } else if (c > 0) {
        AbsSubtractInplace(*this, other);
        FixSign();
      } else {
        BigInteger t(other);
        AbsSubtractInplace(t, *this);
        t.FixSign();
        *this = std::move(t);
        sign_ = -other.sign_;
      }
    }
    return *this;
  }

  BigInteger& operator*=(const BigInteger& other) {
    *this = *this * other;
    return *this;
  }

  template <typename T>
  REQUIRES((is_builtin_integer_v<T>))
  RETURN(BigInteger&) operator*=(T other) {
    if (IsZero()) {
      return *this;
    }
    if (other == 0) {
      pos_ = 0;
      data_[0] = 0;
      sign_ = 0;
      return *this;
    }
    using UnsignedT = pe_make_unsigned_t<T>;
    UnsignedT abs_value = GetAbsValue(other);
    const int s = sign_ * (other > 0 ? 1 : -1);
    AbsMultiplyInplace(*this, abs_value);
    sign_ = s;
    FixSign();
    return *this;
  }

  BigInteger& operator/=(const BigInteger& other) {
    *this = *this / other;
    return *this;
  }

  template <typename T>
  REQUIRES((is_builtin_integer_v<T> && sizeof(T) <= 8))
  RETURN(BigInteger&) operator/=(T other) {
    T remain;
    DivideInplace(*this, other, remain);
    return *this;
  }

  BigInteger& operator%=(const BigInteger& other) {
    *this = *this % other;
    return *this;
  }

  template <typename T>
  REQUIRES((is_builtin_integer_v<T> && sizeof(T) <= 8))
  RETURN(BigInteger&) operator%=(T other) {
    T remain;
    DivideInplace(*this, other, remain);
    return *this = remain;
  }

  BigInteger& operator&=(const BigInteger& other) {
    *this = *this & other;
    return *this;
  }

  BigInteger& operator^=(const BigInteger& other) {
    *this = *this ^ other;
    return *this;
  }

  BigInteger& operator|=(const BigInteger& other) {
    *this = *this | other;
    return *this;
  }

  template <typename T>
  REQUIRES(
      (is_builtin_integer_v<T> &&
       !std::is_same<typename std::remove_cvref<T>::type, BigInteger>::value))
  RETURN(BigInteger&) operator>>=(T other) {
    *this = *this >> other;
    return *this;
  }

  template <typename T>
  REQUIRES(
      (is_builtin_integer_v<T> &&
       !std::is_same<typename std::remove_cvref<T>::type, BigInteger>::value))
  RETURN(BigInteger&) operator<<=(T other) {
    *this = *this << other;
    return *this;
  }

  BigInteger& operator++() {
    *this += 1;
    return *this;
  }

  BigInteger operator++(int) {
    BigInteger ret(*this);
    *this += 1;
    return ret;
  }

  BigInteger& operator--() {
    *this -= 1;
    return *this;
  }

  BigInteger operator--(int) {
    BigInteger ret(*this);
    *this -= 1;
    return ret;
  }

 public:
  // All the binary operators are friend operators
  // Comparison operators
#if PE_HAS_CPP20
  friend inline int operator<=>(const BigInteger& l, const BigInteger& r) {
    return l.CompareTo(r);
  }
  friend inline int operator==(const BigInteger& l, const BigInteger& r) {
    return l.CompareTo(r) == 0;
  }
  friend inline int operator!=(const BigInteger& l, const BigInteger& r) {
    return l.CompareTo(r) != 0;
  }
#else
  friend inline int operator<(const BigInteger& l, const BigInteger& r) {
    const int s1 = l.sign_;
    const int s2 = r.sign_;

    if (s1 < 0) {
      return s2 >= 0 || BigInteger::AbsCompare(l, r) > 0;
    } else if (s1 > 0) {
      return s2 > 0 && BigInteger::AbsCompare(l, r) < 0;
    } else {
      return s2 > 0;
    }
  }

  friend inline int operator<=(const BigInteger& l, const BigInteger& r) {
    const int s1 = l.sign_;
    const int s2 = r.sign_;

    if (s1 < 0) {
      return s2 >= 0 || BigInteger::AbsCompare(l, r) >= 0;
    } else if (s1 > 0) {
      return s2 > 0 && BigInteger::AbsCompare(l, r) <= 0;
    } else {
      return s2 >= 0;
    }
  }

  friend inline int operator>(const BigInteger& l, const BigInteger& r) {
    const int s1 = l.sign_;
    const int s2 = r.sign_;

    if (s1 < 0) {
      return s2 < 0 && BigInteger::AbsCompare(l, r) < 0;
    } else if (s1 > 0) {
      return s2 <= 0 || BigInteger::AbsCompare(l, r) > 0;
    } else {
      return s2 < 0;
    }
  }

  friend inline int operator>=(const BigInteger& l, const BigInteger& r) {
    const int s1 = l.sign_;
    const int s2 = r.sign_;

    if (s1 < 0) {
      return s2 < 0 && BigInteger::AbsCompare(l, r) <= 0;
    } else if (s1 > 0) {
      return s2 <= 0 || BigInteger::AbsCompare(l, r) >= 0;
    } else {
      return s2 <= 0;
    }
  }

  friend inline int operator==(const BigInteger& l, const BigInteger& r) {
    return l.sign_ == r.sign_ && BigInteger::AbsCompare(l, r) == 0;
  }

  friend inline int operator!=(const BigInteger& l, const BigInteger& r) {
    return !(l == r);
  }
#endif
  friend inline BigInteger operator+(const BigInteger& l, const BigInteger& r) {
    if (r.IsZero()) {
      return l;
    } else if (l.IsZero()) {
      return r;
    } else if (l.sign() == r.sign()) {
      BigInteger t(l);
      AbsAddInplace(t, r);
      t.FixSign();
      return t;
    } else {
      int c = AbsCompare(l, r);
      if (c == 0) {
        return 0;
      } else if (c > 0) {
        BigInteger t(l);
        AbsSubtractInplace(t, r);
        t.FixSign();
        return t;
      } else {
        BigInteger t(r);
        AbsSubtractInplace(t, l);
        t.FixSign();
        return t;
      }
    }
  }

  friend inline BigInteger operator-(const BigInteger& l, const BigInteger& r) {
    if (r.IsZero()) {
      return l;
    } else if (l.IsZero()) {
      return -r;
    } else if (l.sign() != r.sign()) {
      BigInteger t(l);
      BigInteger::AbsAddInplace(t, r);
      t.FixSign();
      return t;
    } else {
      int c = BigInteger::AbsCompare(l, r);
      if (c == 0) {
        return 0;
      } else if (c > 0) {
        BigInteger t(l);
        BigInteger::AbsSubtractInplace(t, r);
        t.FixSign();
        return t;
      } else {
        BigInteger t(r);
        BigInteger::AbsSubtractInplace(t, l);
        t.sign_ = -r.sign_;
        t.FixSign();
        return t;
      }
    }
  }

  friend inline BigInteger operator*(const BigInteger& l, const BigInteger& r) {
    if (l.IsZero() || r.IsZero()) return 0;

    const int s = l.sign() * (r > 0 ? 1 : -1);
    BigInteger ret(BigInteger::AbsMultiply(l, r));
    ret.sign_ = s;
    ret.FixSign();

    return ret;
  }

  template <typename T>
  friend inline REQUIRES(
      (is_builtin_integer_v<T> &&
       !std::is_same<typename std::remove_cvref<T>::type, BigInteger>::value))
      RETURN(BigInteger) operator*(const BigInteger & l, T r) {
    if (r == 0 || l.IsZero()) return 0;

    using UnsignedT = pe_make_unsigned_t<T>;
    UnsignedT abs_value = BigInteger::GetAbsValue(r);
    const int s = l.sign() * (r > 0 ? 1 : -1);
    BigInteger ret(BigInteger::AbsMultiply(l, abs_value));
    ret.sign_ = s;
    ret.FixSign();

    return ret;
  }

  template <typename T>
  friend inline REQUIRES(
      (is_builtin_integer_v<T> &&
       !std::is_same<typename std::remove_cvref<T>::type, BigInteger>::value))
      RETURN(BigInteger) operator*(T l, const BigInteger & r) {
    return r * l;
  }

  friend inline BigInteger operator/(const BigInteger& l, const BigInteger& r) {
    return Divide(l, r);
  }

  template <typename T>
  friend inline REQUIRES((
      is_builtin_integer_v<T> &&
      !std::is_same<typename std::remove_cvref<T>::type, BigInteger>::value &&
      sizeof(T) <= 8)) RETURN(BigInteger) operator/(const BigInteger & l, T r) {
    T remain;
    return Divide(l, r, remain);
  }

  friend inline BigInteger Divide(const BigInteger& l, const BigInteger& r,
                                  BigInteger& remain) {
    if (l.IsZero() && r.IsZero()) {
      remain = 0;
      return 1;
    }
    if (l.IsZero() || r.IsZero()) {
      remain = 0;
      return 0;
    }

    if (std::size(r) > 2) {
      BigInteger x;
      BigInteger ret(BigInteger::AbsDivide(l, r, x));
      ret.sign_ = l.sign_ * r.sign_;
      ret.FixLeadingZeros();
      ret.FixSign();
      if (l.sign_ < 0) {
        x.sign_ = -x.sign_;
      }
      x.FixLeadingZeros();
      x.FixSign();

      remain = std::move(x);

      return ret;
    } else {
      uint64 abs_value = r.ToInt<uint64>();
      uint64 x;
      BigInteger ret(l);
      BigInteger::AbsDivideInplace(ret, abs_value, x);
      ret.sign_ = l.sign() * (r.sign() > 0 ? 1 : -1);
      ret.FixLeadingZeros();
      ret.FixSign();

      remain = x;
      if (l.sign_ < 0) {
        remain.sign_ = -remain.sign_;
      }

      return ret;
    }
  }

  friend inline BigInteger Divide(const BigInteger& l, const BigInteger& r) {
    if (l.IsZero() && r.IsZero()) {
      return 1;
    }
    if (l.IsZero() || r.IsZero()) {
      return 0;
    }

    if (std::size(r) > 2) {
      BigInteger x;
      BigInteger ret(BigInteger::AbsDivide(l, r, x));
      ret.sign_ = l.sign_ * r.sign_;
      ret.FixLeadingZeros();
      ret.FixSign();

      return ret;
    } else {
      uint64 abs_value = r.ToInt<uint64>();
      uint64 x;
      BigInteger ret(l);
      BigInteger::AbsDivideInplace(ret, abs_value, x);
      ret.sign_ = l.sign() * (r.sign() > 0 ? 1 : -1);
      ret.FixLeadingZeros();
      ret.FixSign();

      return ret;
    }
  }

  // The following version always has "remain" output while the above version
  // doesn't because the cost of output native integer remain is not high.

  template <typename T>
  friend inline REQUIRES(
      (is_builtin_integer_v<T> &&
       !std::is_same<typename std::remove_cvref<T>::type, BigInteger>::value &&
       sizeof(T) <= 8)) RETURN(BigInteger)
      Divide(const BigInteger& l, T r, T& remain) {
    if (l.IsZero() && r == 0) {
      remain = 0;
      return 1;
    }
    if (l.IsZero() || r == 0) {
      remain = 0;
      return 0;
    }

    const int signl = l.sign_;
    using UnsignedT = pe_make_unsigned_t<T>;
    UnsignedT abs_value = BigInteger::GetAbsValue(r);
    UnsignedT x;
    BigInteger ret(l);
    BigInteger::AbsDivideInplace(ret, abs_value, x);
    ret.sign_ = signl * (r > 0 ? 1 : -1);
    ret.FixLeadingZeros();
    ret.FixSign();
    if (l.sign_ < 0) {
      PE_ASSERT(x == 0 || !pe_is_unsigned_v<T>);
      x = BigInteger::GetAbsValue(x);
    }

    remain = static_cast<T>(x);

    return ret;
  }

  template <typename T>
  friend inline REQUIRES(
      (is_builtin_integer_v<T> &&
       !std::is_same<typename std::remove_cvref<T>::type, BigInteger>::value))
      RETURN(void) DivideInplace(BigInteger& self, T other, T& remain) {
    if (self.IsZero() && other == 0) {
      self = 1;
      remain = 0;
      return;
    }

    if (self.IsZero() || other == 0) {
      if (!self.IsZero()) {
        self.pos_ = 0;
        self.data_[0] = 0;
        self.sign_ = 0;
      }
      remain = 0;
      return;
    }
    using UnsignedT = pe_make_unsigned_t<T>;
    UnsignedT abs_value = BigInteger::GetAbsValue(other);
    UnsignedT tmp_remain;
    const int signl = self.sign_;
    BigInteger::AbsDivideInplace(self, abs_value, tmp_remain);
    self.sign_ = signl * (other > 0 ? 1 : -1);
    self.FixLeadingZeros();
    self.FixSign();
    remain = static_cast<T>(tmp_remain);
    if (signl < 0) {
      PE_ASSERT(remain == 0 || !pe_is_unsigned_v<T>);
      remain = BigInteger::GetNegValue(remain);
    }
  }

  friend inline BigInteger operator%(const BigInteger& l, const BigInteger& r) {
    BigInteger remain;
    Divide(l, r, remain);
    return remain;
  }

  template <typename T>
  friend inline REQUIRES((
      is_builtin_integer_v<T> &&
      !std::is_same<typename std::remove_cvref<T>::type, BigInteger>::value &&
      sizeof(T) <= 8)) RETURN(BigInteger) operator%(const BigInteger & l, T r) {
    BigInteger u;
    T remain;
    Divide(l, r, remain);
    if (l.sign() < 0) {
      remain = BigInteger::GetNegValue(remain);
    }
    return remain;
  }

  friend inline BigInteger operator&(const BigInteger& l, const BigInteger& r) {
    if (std::size(l) <= 2 && std::size(r) <= 2) {
      return l.ToInt<uint64>() & r.ToInt<uint64>();
    }

    const int min_pos = std::min(l.pos_, r.pos_);
    BigInteger ret(min_pos + 1, internal::alloc_mem_tag);
    for (int i = 0; i <= min_pos; ++i) {
      ret[i] = l[i] & r[i];
    }
    ret.pos_ = min_pos;
    ret.sign_ = 1;
    ret.FixLeadingZeros();
    ret.FixSign();
    return ret;
  }

  friend inline BigInteger operator^(const BigInteger& l, const BigInteger& r) {
    if (std::size(l) <= 2 && std::size(r) <= 2) {
      return l.ToInt<uint64>() ^ r.ToInt<uint64>();
    }

    const int max_pos = std::max(l.pos_, r.pos_);
    BigInteger ret(max_pos + 1, internal::alloc_mem_tag);
    for (int i = 0; i <= max_pos; ++i) {
      unsigned int t = 0;
      if (i <= l.pos_) t ^= l[i];
      if (i <= r.pos_) t ^= r[i];
      ret[i] = t;
    }
    ret.pos_ = max_pos;
    ret.sign_ = 1;
    ret.FixLeadingZeros();
    ret.FixSign();
    return ret;
  }

  friend inline BigInteger operator|(const BigInteger& l, const BigInteger& r) {
    if (std::size(l) <= 2 && std::size(r) <= 2) {
      return l.ToInt<uint64>() | r.ToInt<uint64>();
    }

    const int max_pos = std::max(l.pos_, r.pos_);
    BigInteger ret(max_pos + 1, internal::alloc_mem_tag);
    for (int i = 0; i <= max_pos; ++i) {
      unsigned int t = 0;
      if (i <= l.pos_) t |= l[i];
      if (i <= r.pos_) t |= r[i];
      ret[i] = t;
    }
    ret.pos_ = max_pos;
    ret.sign_ = 1;
    ret.FixLeadingZeros();
    ret.FixSign();
    return ret;
  }

  template <typename T>
  friend inline REQUIRES(
      (is_builtin_integer_v<T> &&
       !std::is_same<typename std::remove_cvref<T>::type, BigInteger>::value))
      RETURN(BigInteger) operator<<(const BigInteger & l, T n) {
    if (l.sign() == 0) {
      return 0;
    }
    if (n == 0) {
      return l;
    }
    const int bit_cnt = l.BitHeight();
    std::vector<unsigned int> v(n + bit_cnt, 0);
    for (int i = 0, j = n; i < bit_cnt; ++i, ++j) {
      const int x = i >> BigInteger::div32_bit;
      const int y = i & BigInteger::mod32_mask;
      v[j] = (l[x] >> y) & 1;
    }
    BigInteger ret(internal::zero_initialize_tag);
    ret.FromBinary(v);
    ret.FixLeadingZeros();
    ret.sign_ = l.sign_;
    ret.FixSign();
    return ret;
  }

  template <typename T>
  friend inline REQUIRES(
      (is_builtin_integer_v<T> &&
       !std::is_same<typename std::remove_cvref<T>::type, BigInteger>::value))
      RETURN(BigInteger) operator>>(const BigInteger & l, T n) {
    if (l.sign() == 0) {
      return 0;
    }
    if (n == 0) {
      return l;
    }
    const int bit_cnt = l.BitHeight();
    if (n >= bit_cnt) {
      return 0;
    }

    std::vector<unsigned int> v(bit_cnt - n, 0);
    for (int i = n, j = 0; i < bit_cnt; ++i, ++j) {
      const int x = i >> BigInteger::div32_bit;
      const int y = i & BigInteger::mod32_mask;
      v[j] = (l[x] >> y) & 1;
    }

    BigInteger ret(internal::zero_initialize_tag);
    ret.FromBinary(v);
    ret.FixLeadingZeros();
    ret.sign_ = l.sign_;
    ret.FixSign();

    return ret;
  }

  friend std::ostream& operator<<(std::ostream& o, const BigInteger& bi) {
    return o << bi.ToString();
  }

 private:
  unsigned int* data_;
  int buffer_length_;
  mutable int pos_;
  mutable int sign_;
};

using bi = BigInteger;

template <>
struct Gbi<BigInteger> {
  template <typename T, typename = std::enable_if_t<is_builtin_integer_v<T>>>
  static BigInteger Of(T value) {
    return BigInteger(value);
  }

  static BigInteger Of(const std::string& s) { return BigInteger(s); }
};

SL int IsZero(const BigInteger& x) { return x.IsZero(); }

SL int IntSign(const BigInteger& x) { return x.sign(); }

SL int IsEven(const BigInteger& x) { return x.IsEven(); }

SL int IsOdd(const BigInteger& x) { return x.IsOdd(); }

SL unsigned int LowerBits(const BigInteger& x) { return x.LowerBits(); }

SL std::tuple<BigInteger, BigInteger> Div(const BigInteger& l,
                                          const BigInteger& r) {
  BigInteger remain;
  BigInteger d = Divide(l, r, remain);
  return {std::move(d), std::move(remain)};
}

template <typename T>
SL T ToInt(const BigInteger& x) {
  return x.ToInt<T>();
}

template <typename T>
SL T ToFloat(const BigInteger& x) {
  return x.ToFloat<T>();
}

// Power operation has a default implementation

SL std::string ToString(const BigInteger& x) { return x.ToString(); }

SL std::string to_string(const BigInteger& x) { return ToString(x); }
}  // namespace pe

#if PE_HAS_CPP20
namespace pe {
static_assert(PeGbi<BigInteger>);
static_assert(PeFraction<Fraction<BigInteger>>);
}  // namespace pe
#endif

inline pe::BigInteger operator"" _bi(const char* sv, size_t /*sc*/) {
  return pe::BigInteger(std::string(sv));
}

inline pe::BigInteger operator"" _bi(unsigned long long v) {
  return pe::BigInteger(v);
}
#endif