#ifndef PE_EXTENDED_UNSIGNED_INT_
#define PE_EXTENDED_UNSIGNED_INT_

#include "pe_base"
#include "pe_int128"
#include "pe_type_traits"
#include "pe_int"
#include "pe_bit"
#include "pe_uint_pair"

namespace pe {
// Extended integers

// Extended unsigned integer.
template <typename ET, bool is_native>
struct ExtendedUnsignedIntImpl;

template <typename ET>
struct ExtendedUnsignedIntImpl<ET, true> : public UIntPairImpl<ET, true> {
  constexpr static int quarter_bitcount = sizeof(ET) * 4;
  constexpr static int half_bitcount = quarter_bitcount * 2;
  constexpr static int bitcount = half_bitcount * 2;

  constexpr static ET quarter_mask =
      (static_cast<ET>(1) << quarter_bitcount) - 1;

  // The corresponding native integer type.
  using NT = ET;
  using base = UIntPairImpl<ET, true>;

 public:
  ExtendedUnsignedIntImpl(ET low = 0) : base(low) {}
  ExtendedUnsignedIntImpl(ET low, ET hi) : base(low, hi) {}

  template <typename T,
            typename TT = REQUIRES((is_native_integer<T>::value)) RETURN(T)>
  ExtendedUnsignedIntImpl(T v) : base(v) {}

  ExtendedUnsignedIntImpl(const std::string& str) {
    const int n = static_cast<int>(str.size());
    if (n == 0) return;
    int idx = 0;
    int neg = 0;
    if (str[idx] == '-') {
      ++idx;
      neg = 1;
    } else if (str[idx] == '+') {
      ++idx;
    }
    while (idx < n && std::isdigit(str[idx])) {
      *this = *this * 10 + (str[idx] - '0');
      ++idx;
    }
    if (neg) {
      base::FlipBits();
      base::AddOne();
    }
  }

  ExtendedUnsignedIntImpl(const ExtendedUnsignedIntImpl& other) : base(other) {}

  ExtendedUnsignedIntImpl& operator=(const ExtendedUnsignedIntImpl& other) {
    base::low_ = other.low_;
    base::hi_ = other.hi_;
    return *this;
  }

  ExtendedUnsignedIntImpl& operator=(const ExtendedUnsignedIntImpl&& other) {
    base::low_ = std::move(other.low_);
    base::hi_ = std::move(other.hi_);
    return *this;
  }

  ExtendedUnsignedIntImpl& operator=(const ET& other) {
    base::low_ = other;
    base::hi_ = 0;
    return *this;
  }

  template <typename T,
            typename TT = REQUIRES((is_native_integer<T>::value)) RETURN(T)>
  ExtendedUnsignedIntImpl& operator=(const T& other) {
    base::MakeZeroBits();
    base::template FromNativeInt<T>(other);
    return *this;
  }

 public:
  ExtendedUnsignedIntImpl& DivImpl(const ExtendedUnsignedIntImpl& other) {
    base::UIntDivImpl(other);
    return *this;
  }

  ExtendedUnsignedIntImpl& DivImpl(const ExtendedUnsignedIntImpl& other,
                                   ExtendedUnsignedIntImpl& r) {
    base::UIntDivImpl(other);
    return *this;
  }

  ExtendedUnsignedIntImpl& ModImpl(const ExtendedUnsignedIntImpl& other) {
    base::UIntModImpl(other);
    return *this;
  }

 public:
  using base::hi;
  using base::low;

  int sign() const { return base::low_ || base::hi_ ? 1 : 0; }

  int CompareTo(const ExtendedUnsignedIntImpl& other) const {
    return base::UIntCompareTo(other);
  }

  int IntSign() const { return base::low_ || base::hi_ ? 1 : 0; }

  using base::IsEven;
  using base::IsOdd;
  using base::IsZero;
  using base::LowerBits;

  ExtendedUnsignedIntImpl Abs() const { return *this; }

  ExtendedUnsignedIntImpl FAbs() const { return *this; }

  using base::ToInt;

  template <typename T>
  T ToFloat() const {
    auto t = base::ToUInt32Vector();
    const int size = t.size();
    T r = 0;
    for (int i = size - 1; i >= 0; --i) {
      r = r * 4294967296 + t[i];
    }
    return r;
  }

  using base::BitCount;
  using base::GetBit;
  using base::ResetBit;
  using base::RevBit;
  using base::SetBit;

  std::string ToString() const {
    const uint32_t output_mod = 1000000000;
    if (IsZero()) {
      return "0";
    }
    if (base::hi_ == 0) {
      return pe::ToString(base::low_);
    }

    std::vector<uint32_t> bits32 = base::ToUInt32Vector();
    std::vector<uint32_t> mods;

    std::stringstream ss;

    int idx = bits32.size() - 1;
    while (bits32[idx] == 0) --idx;

    do {
      uint64 add = 0;
      for (int i = idx; i > 0; --i) {
        const uint64 x = add + bits32[i];
        const uint64 next_add = (x % output_mod) << 32;
        bits32[i] = static_cast<unsigned>(x / output_mod);
        add = next_add;
      }
      uint64 x = add + bits32[0];
      bits32[0] = static_cast<unsigned>(x / output_mod);
      mods.push_back(x % output_mod);
      while (idx >= 0 && bits32[idx] == 0) --idx;
    } while (idx >= 0);

    idx = static_cast<int>(mods.size()) - 1;
    char buff[32];
    sprintf(buff, "%u", mods[idx--]);
    ss << buff;
    for (; idx >= 0; --idx) {
      sprintf(buff, "%09u", mods[idx]);
      ss << buff;
    }
    return ss.str();
  }

  std::string to_string() const { return ToString(); }

  ExtendedUnsignedIntImpl Difference(
      const ExtendedUnsignedIntImpl& other) const {
    auto t = base::Difference(other);
    return ExtendedUnsignedIntImpl(t.low(), t.hi());
  }

 public:
  // Operators
  const ExtendedUnsignedIntImpl& operator+() const { return *this; }

  const ExtendedUnsignedIntImpl& operator-() const {
    ExtendedUnsignedIntImpl ret(*this);
    base::FlipBits();
    base::AddOne();
    return ret;
  }

  ExtendedUnsignedIntImpl operator~() const {
    return ExtendedUnsignedIntImpl(~base::low_, ~base::hi_);
  }

  ExtendedUnsignedIntImpl& operator+=(const ExtendedUnsignedIntImpl& other) {
    if (IsZero()) {
      base::low_ = other.low();
      base::hi_ = other.hi();
      return *this;
    }

    if (!other.IsZero()) {
      ET x = other.low() + base::low_;
      ET y = other.hi() + base::hi_;
      if (other.low_ && base::low_ && (x < other.low() || x < base::low_)) {
        ++y;
      }
      base::low_ = x;
      base::hi_ = y;
    }
    return *this;
  }

  ExtendedUnsignedIntImpl& operator+=(const ET& other) {
    if (IsZero()) {
      base::low_ = other;
      base::hi_ = 0;
      return *this;
    }

    if (other) {
      ET x = base::low_ + other;
      ET y = base::hi_;
      if (base::low_ && other && (x < base::low_ || x < other)) {
        ++y;
      }
      base::low_ = x;
      base::hi_ = y;
    }
    return *this;
  }

  ExtendedUnsignedIntImpl& operator-=(const ExtendedUnsignedIntImpl& other) {
    if (other.IsZero()) {
      return *this;
    }

    if (IsZero()) {
      base::low_ = other.low();
      base::hi_ = other.hi();
      base::FlipBits();
      base::AddOne();
      return *this;
    }

    int t = CompareTo(other);
    if (t == 0) {
      base::low_ = base::hi_ = 0;
      return *this;
    } else {
      ExtendedUnsignedIntImpl d = Difference(other);
      if (t < 0) {
        d.FlipBits();
        d.AddOne();
      }
      base::low_ = d.low();
      base::hi_ = d.hi();
    }

    return *this;
  }

  ExtendedUnsignedIntImpl& operator-=(const ET& other) {
    if (other == 0) {
      return *this;
    }

    if (IsZero()) {
      base::low_ = other;
      base::FlipBits();
      base::AddOne();
      return *this;
    }

    int t = CompareTo(other);
    if (t == 0) {
      base::low_ = base::hi_ = 0;
      return *this;
    } else {
      ExtendedUnsignedIntImpl d = Difference(other);
      if (t < 0) {
        d.FlipBits();
        d.AddOne();
      }
      base::low_ = d.low();
      base::hi_ = d.hi();
    }

    return *this;
  }

  ExtendedUnsignedIntImpl& operator*=(const ExtendedUnsignedIntImpl& other) {
    if (IsZero() || other.IsZero()) {
      base::low_ = base::hi_ = 0;
      return *this;
    }
    ET t[4] = {0};
    for (int i = 0; i < 4; ++i)
      for (int j = 0; j + i < 4; ++j) {
        ET carry = base::GetQuarter(i) * other.GetQuarter(j);
        for (int now = i + j; now < 4; ++now) {
          ET x = t[now] + (carry & quarter_mask);
          t[now] = x & quarter_mask;
          carry = (x >> quarter_bitcount) + (carry >> quarter_bitcount);
          if (carry == 0) {
            break;
          }
        }
      }
    base::low_ = t[0] | (t[1] << quarter_bitcount);
    base::hi_ = t[2] | (t[3] << quarter_bitcount);

    return *this;
  }

  ExtendedUnsignedIntImpl& operator*=(const ET& other) {
    if (IsZero() || other == 0) {
      base::low_ = base::hi_ = 0;
      return *this;
    }
    ET t[4] = {0};
    for (int i = 0; i < 4; ++i)
      for (int j = 0; j < 2 && j + i < 4; ++j) {
        ET carry = base::GetQuarter(i) *
                   (j == 0 ? other & quarter_mask : other >> quarter_bitcount);
        for (int now = i + j; now < 4; ++now) {
          ET x = t[now] + (carry & quarter_mask);
          t[now] = x & quarter_mask;
          carry = (x >> quarter_bitcount) + (carry >> quarter_bitcount);
          if (carry == 0) {
            break;
          }
        }
      }
    base::low_ = t[0] | (t[1] << quarter_bitcount);
    base::hi_ = t[2] | (t[3] << quarter_bitcount);

    return *this;
  }

  ExtendedUnsignedIntImpl& operator/=(const ExtendedUnsignedIntImpl& other) {
    return DivImpl(other);
  }

  ExtendedUnsignedIntImpl& operator/=(const ET& other) {
    return *this /= ExtendedUnsignedIntImpl(other);
  }

  ExtendedUnsignedIntImpl& operator%=(const ExtendedUnsignedIntImpl& other) {
    return ModImpl(other);
  }

  ExtendedUnsignedIntImpl& operator%=(const ET& other) {
    return *this %= ExtendedUnsignedIntImpl(other);
  }

  ExtendedUnsignedIntImpl& operator&=(const ExtendedUnsignedIntImpl& other) {
    base::low_ &= other.low();
    base::hi_ &= other.hi();
    return *this;
  }

  ExtendedUnsignedIntImpl& operator&=(const ET& other) {
    base::low_ &= other;
    base::hi_ = 0;
    return *this;
  }

  ExtendedUnsignedIntImpl& operator^=(const ExtendedUnsignedIntImpl& other) {
    base::low_ ^= other.low();
    base::hi_ ^= other.hi();
    return *this;
  }

  ExtendedUnsignedIntImpl& operator^=(const ET& other) {
    base::low_ ^= other;
    return *this;
  }

  ExtendedUnsignedIntImpl& operator|=(const ExtendedUnsignedIntImpl& other) {
    base::low_ |= other.low();
    base::hi_ |= other.hi();
    return *this;
  }

  ExtendedUnsignedIntImpl& operator|=(const ET& other) {
    base::low_ |= other;
    return *this;
  }

  ExtendedUnsignedIntImpl& operator>>=(int cnt) {
    base::ShiftRight(cnt);
    return *this;
  }

  ExtendedUnsignedIntImpl& operator<<=(int cnt) {
    base::ShiftLeft(cnt);
    return *this;
  }

  ExtendedUnsignedIntImpl& operator++() {
    base::AddOne();
    return *this;
  }

  ExtendedUnsignedIntImpl operator++(int) {
    ExtendedUnsignedIntImpl ret(*this);
    *this += 1;
    return ret;
  }

  ExtendedUnsignedIntImpl& operator--() {
    if (base::low_) {
      --base::low_;
    } else {
      --base::low_;
      --base::hi_;
    }
    return *this;
  }

  ExtendedUnsignedIntImpl operator--(int) {
    ExtendedUnsignedIntImpl ret(*this);
    *this -= 1;
    return ret;
  }

 public:
  // All the binary operators are friend operators
  // Comparison operators
#if PE_HAS_CPP20
  friend inline int operator<=>(const ExtendedUnsignedIntImpl& l,
                                const ExtendedUnsignedIntImpl& r) {
    return l.CompareTo(r);
  }
  friend inline int operator==(const ExtendedUnsignedIntImpl& l,
                               const ExtendedUnsignedIntImpl& r) {
    return l.CompareTo(r) == 0;
  }
  friend inline int operator!=(const ExtendedUnsignedIntImpl& l,
                               const ExtendedUnsignedIntImpl& r) {
    return l.CompareTo(r) != 0;
  }
#else
  friend inline int operator<(const ExtendedUnsignedIntImpl& l,
                              const ExtendedUnsignedIntImpl& r) {
    return l.CompareTo(r) < 0;
  }
  friend inline int operator<=(const ExtendedUnsignedIntImpl& l,
                               const ExtendedUnsignedIntImpl& r) {
    return l.CompareTo(r) <= 0;
  }
  friend inline int operator>(const ExtendedUnsignedIntImpl& l,
                              const ExtendedUnsignedIntImpl& r) {
    return l.CompareTo(r) > 0;
  }
  friend inline int operator>=(const ExtendedUnsignedIntImpl& l,
                               const ExtendedUnsignedIntImpl& r) {
    return l.CompareTo(r) >= 0;
  }
  friend inline int operator==(const ExtendedUnsignedIntImpl& l,
                               const ExtendedUnsignedIntImpl& r) {
    return l.CompareTo(r) == 0;
  }
  friend inline int operator!=(const ExtendedUnsignedIntImpl& l,
                               const ExtendedUnsignedIntImpl& r) {
    return l.CompareTo(r) != 0;
  }
#endif
  friend inline ExtendedUnsignedIntImpl operator+(
      const ExtendedUnsignedIntImpl& l, const ExtendedUnsignedIntImpl& r) {
    ExtendedUnsignedIntImpl ret(l);
    ret += r;
    return ret;
  }
  friend inline ExtendedUnsignedIntImpl operator-(
      const ExtendedUnsignedIntImpl& l, const ExtendedUnsignedIntImpl& r) {
    ExtendedUnsignedIntImpl ret(l);
    ret -= r;
    return ret;
  }
  friend inline ExtendedUnsignedIntImpl operator*(
      const ExtendedUnsignedIntImpl& l, const ExtendedUnsignedIntImpl& r) {
    ExtendedUnsignedIntImpl ret(l);
    ret *= r;
    return ret;
  }
  friend inline ExtendedUnsignedIntImpl operator/(
      const ExtendedUnsignedIntImpl& l, const ExtendedUnsignedIntImpl& r) {
    ExtendedUnsignedIntImpl ret(l);
    ret /= r;
    return ret;
  }
  friend inline ExtendedUnsignedIntImpl operator%(
      const ExtendedUnsignedIntImpl& l, const ExtendedUnsignedIntImpl& r) {
    ExtendedUnsignedIntImpl ret(l);
    ret %= r;
    return ret;
  }
  friend inline ExtendedUnsignedIntImpl operator&(
      const ExtendedUnsignedIntImpl& l, const ExtendedUnsignedIntImpl& r) {
    ExtendedUnsignedIntImpl ret(l);
    ret &= r;
    return ret;
  }
  friend inline ExtendedUnsignedIntImpl operator^(
      const ExtendedUnsignedIntImpl& l, const ExtendedUnsignedIntImpl& r) {
    ExtendedUnsignedIntImpl ret(l);
    ret ^= r;
    return ret;
  }
  friend inline ExtendedUnsignedIntImpl operator|(
      const ExtendedUnsignedIntImpl& l, const ExtendedUnsignedIntImpl& r) {
    ExtendedUnsignedIntImpl ret(l);
    ret |= r;
    return ret;
  }
  friend inline ExtendedUnsignedIntImpl operator<<(
      const ExtendedUnsignedIntImpl& l, const int cnt) {
    ExtendedUnsignedIntImpl ret(l);
    ret <<= cnt;
    return ret;
  }
  friend inline ExtendedUnsignedIntImpl operator>>(
      const ExtendedUnsignedIntImpl& l, const int cnt) {
    ExtendedUnsignedIntImpl ret(l);
    ret >>= cnt;
    return ret;
  }
  friend inline std::ostream& operator<<(std::ostream& o,
                                         const ExtendedUnsignedIntImpl& n) {
    return o << n.ToString();
  }
};
template <typename ET>
struct ExtendedUnsignedIntImpl<ET, false> : public UIntPairImpl<ET, false> {
  constexpr static int quarter_bitcount = sizeof(ET) * 4;
  constexpr static int half_bitcount = quarter_bitcount * 2;
  constexpr static int bitcount = half_bitcount * 2;

  using NT = typename ET::NT;
  using base = UIntPairImpl<ET, false>;

 public:
  ExtendedUnsignedIntImpl(ET low = 0) : base(low) {}
  ExtendedUnsignedIntImpl(ET low, ET hi) : base(low, hi) {}

  template <typename T,
            typename TT = REQUIRES((is_native_integer<T>::value)) RETURN(T)>
  ExtendedUnsignedIntImpl(T v) : base(v) {}

  ExtendedUnsignedIntImpl(const std::string& str) : base(str) {
    const int n = static_cast<int>(str.size());
    if (n == 0) return;
    int idx = 0;
    int neg = 0;
    if (str[idx] == '-') {
      ++idx;
      neg = 1;
    } else if (str[idx] == '+') {
      ++idx;
    }
    while (idx < n && std::isdigit(str[idx])) {
      *this = *this * 10 + (str[idx] - '0');
      ++idx;
    }
    if (neg) {
      base::FlipBits();
      base::AddOne();
    }
  }

  ExtendedUnsignedIntImpl(const ExtendedUnsignedIntImpl& other) : base(other) {}

  ExtendedUnsignedIntImpl& operator=(const ExtendedUnsignedIntImpl& other) {
    base::low_ = other.low_;
    base::hi_ = other.hi_;
    return *this;
  }

  ExtendedUnsignedIntImpl& operator=(const ExtendedUnsignedIntImpl&& other) {
    base::low_ = std::move(other.low_);
    base::hi_ = std::move(other.hi_);
    return *this;
  }

  ExtendedUnsignedIntImpl& operator=(const ET& other) {
    base::low_ = other;
    base::hi_.MakeZeroBits();
    return *this;
  }

  template <typename T,
            typename TT = REQUIRES((is_native_integer<T>::value)) RETURN(T)>
  ExtendedUnsignedIntImpl& operator=(const T& other) {
    base::MakeZeroBits();
    base::template FromNativeInt<T>(other);
    return *this;
  }

 public:
  ExtendedUnsignedIntImpl& DivImpl(const ExtendedUnsignedIntImpl& other) {
    base::UIntDivImpl(other);
    return *this;
  }

  ExtendedUnsignedIntImpl& DivImpl(const ExtendedUnsignedIntImpl& other,
                                   ExtendedUnsignedIntImpl& r) {
    base::UIntDivImpl(other);
    return *this;
  }

  ExtendedUnsignedIntImpl& ModImpl(const ExtendedUnsignedIntImpl& other) {
    base::UIntModImpl(other);
    return *this;
  }

 public:
  using base::hi;
  using base::low;

  int sign() const {
    return base::low_.IntSign() || base::hi_.IntSign() ? 1 : 0;
  }

  int CompareTo(const ExtendedUnsignedIntImpl& other) const {
    int t = base::hi_.UIntCompareTo(other.hi_);
    if (t != 0) {
      return t;
    }
    return base::low_.UIntCompareTo(other.low_);
  }

  int IntSign() const {
    return base::low_.IntSign() || base::hi_.IntSign() ? 1 : 0;
  }

  using base::IsEven;
  using base::IsOdd;
  using base::IsZero;
  using base::LowerBits;

  ExtendedUnsignedIntImpl Abs() const { return *this; }

  ExtendedUnsignedIntImpl FAbs() const { return *this; }

  using base::ToInt;

  template <typename T>
  T ToFloat() const {
    auto t = base::ToUInt32Vector();
    const int size = t.size();
    T r = 0;
    for (int i = size - 1; i >= 0; --i) {
      r = r * 4294967296 + t[i];
    }
    return r;
  }

  using base::BitCount;
  using base::GetBit;
  using base::ResetBit;
  using base::RevBit;
  using base::SetBit;

  std::string ToString() const {
    const uint32_t output_mod = 1000000000;
    if (IsZero()) {
      return "0";
    }
    if (base::hi_.IsZero()) {
      return base::low_.ToString();
    }

    std::vector<uint32_t> bits32 = base::ToUInt32Vector();
    std::vector<uint32_t> mods;

    std::stringstream ss;
    int idx = bits32.size() - 1;
    while (bits32[idx] == 0) --idx;
    do {
      uint64 add = 0;
      for (int i = idx; i > 0; --i) {
        const uint64 x = add + bits32[i];
        const uint64 next_add = (x % output_mod) << 32;
        bits32[i] = static_cast<unsigned>(x / output_mod);
        add = next_add;
      }
      uint64 x = add + bits32[0];
      bits32[0] = static_cast<unsigned>(x / output_mod);
      mods.push_back(x % output_mod);
      while (idx >= 0 && bits32[idx] == 0) --idx;
    } while (idx >= 0);

    idx = static_cast<int>(mods.size()) - 1;
    char buff[32];
    sprintf(buff, "%u", mods[idx--]);
    ss << buff;
    for (; idx >= 0; --idx) {
      sprintf(buff, "%09u", mods[idx]);
      ss << buff;
    }
    return ss.str();
  }

  std::string to_string() const { return ToString(); }

  ExtendedUnsignedIntImpl Difference(
      const ExtendedUnsignedIntImpl& other) const {
    auto t = base::Difference(other);
    return ExtendedUnsignedIntImpl(t.low(), t.hi());
  }

 public:
  // Operators
  const ExtendedUnsignedIntImpl& operator+() const { return *this; }

  const ExtendedUnsignedIntImpl& operator-() const {
    ExtendedUnsignedIntImpl ret(*this);
    base::FlipBits();
    base::AddOne();
    return ret;
  }

  ExtendedUnsignedIntImpl operator~() const {
    return ExtendedUnsignedIntImpl(~base::low_, ~base::hi_);
  }

  ExtendedUnsignedIntImpl& operator+=(const ExtendedUnsignedIntImpl& other) {
    if (IsZero()) {
      base::low_ = other.low();
      base::hi_ = other.hi();
      return *this;
    }

    if (!other.IsZero()) {
      ET x = other.low() + base::low_;
      ET y = other.hi() + base::hi_;
      if (!other.low().IsZero() && !base::low_.IsZero() &&
          (x < other.low() || x < base::low_)) {
        ++y;
      }
      base::low_ = x;
      base::hi_ = y;
    }
    return *this;
  }

  ExtendedUnsignedIntImpl& operator+=(const ET& other) {
    return *this += ExtendedUnsignedIntImpl(other);
  }

  template <typename T>
  REQUIRES((is_native_integer<T>::value))
  RETURN(ExtendedUnsignedIntImpl&) operator+=(const T& other) {
    return *this += ExtendedUnsignedIntImpl(other);
  }

  ExtendedUnsignedIntImpl& operator-=(const ExtendedUnsignedIntImpl& other) {
    if (other.IsZero()) {
      return *this;
    }

    if (IsZero()) {
      base::low_ = other.low();
      base::hi_ = other.hi();
      base::FlipBits();
      base::AddOne();
      return *this;
    }

    int t = CompareTo(other);
    if (t == 0) {
      base::low_.MakeZeroBits();
      base::hi_.MakeZeroBits();
      return *this;
    } else {
      ExtendedUnsignedIntImpl d = Difference(other);
      if (t < 0) {
        d.FlipBits();
        d.AddOne();
      }
      base::low_ = d.low_;
      base::hi_ = d.hi_;
    }

    return *this;
  }

  ExtendedUnsignedIntImpl& operator-=(const ET& other) {
    return *this -= ExtendedUnsignedIntImpl(other);
  }

  template <typename T>
  REQUIRES((is_native_integer<T>::value))
  RETURN(ExtendedUnsignedIntImpl&) operator-=(const T& other) {
    return *this -= ExtendedUnsignedIntImpl(other);
  }

  ExtendedUnsignedIntImpl& operator*=(const ExtendedUnsignedIntImpl& other) {
    if (IsZero() || other.IsZero()) {
      base::low_.MakeZeroBits();
      base::hi_.MakeZeroBits();
      return *this;
    }
    ET t[4];
    for (int i = 0; i < 4; ++i)
      for (int j = 0; j + i < 4; ++j) {
        ET carry = base::GetQuarter(i) * other.GetQuarter(j);
        for (int now = i + j; now < 4; ++now) {
          ET x = ET(t[now]) + ET(carry.low());
          t[now] = x.low();
          carry = ET(x.hi()) + ET(carry.hi());
          if (carry.IsZero()) {
            break;
          }
        }
      }
    base::low_ = t[0] | (t[1] << quarter_bitcount);
    base::hi_ = t[2] | (t[3] << quarter_bitcount);

    return *this;
  }

  ExtendedUnsignedIntImpl& operator*=(const ET& other) {
    return *this *= ExtendedUnsignedIntImpl(other);
  }

  template <typename T>
  REQUIRES((is_native_integer<T>::value))
  RETURN(ExtendedUnsignedIntImpl&) operator*=(const T& other) {
    return *this *= ExtendedUnsignedIntImpl(other);
  }

  ExtendedUnsignedIntImpl& operator/=(const ExtendedUnsignedIntImpl& other) {
    return DivImpl(other);
  }

  ExtendedUnsignedIntImpl& operator/=(const ET& other) {
    return *this /= ExtendedUnsignedIntImpl(other);
  }

  template <typename T>
  REQUIRES((is_native_integer<T>::value))
  RETURN(ExtendedUnsignedIntImpl&) operator/=(const T& other) {
    return *this /= ExtendedUnsignedIntImpl(other);
  }

  ExtendedUnsignedIntImpl& operator%=(const ExtendedUnsignedIntImpl& other) {
    return ModImpl(other);
  }

  ExtendedUnsignedIntImpl& operator%=(const ET& other) {
    return *this %= ExtendedUnsignedIntImpl(other);
  }

  template <typename T>
  REQUIRES((is_native_integer<T>::value))
  RETURN(ExtendedUnsignedIntImpl&) operator%=(const T& other) {
    return *this %= ExtendedUnsignedIntImpl(other);
  }

  ExtendedUnsignedIntImpl& operator&=(const ExtendedUnsignedIntImpl& other) {
    base::low_ &= other.low();
    base::hi_ &= other.hi();
    return *this;
  }

  template <typename T>
  REQUIRES((is_native_integer<T>::value))
  RETURN(ExtendedUnsignedIntImpl&) operator&=(const T& other) {
    return *this &= ExtendedUnsignedIntImpl(other);
  }

  ExtendedUnsignedIntImpl& operator&=(const ET& other) {
    return *this &= ExtendedUnsignedIntImpl(other);
  }

  ExtendedUnsignedIntImpl& operator^=(const ExtendedUnsignedIntImpl& other) {
    base::low_ ^= other.low();
    base::hi_ ^= other.hi();
    return *this;
  }

  ExtendedUnsignedIntImpl& operator^=(const ET& other) {
    return *this ^= ExtendedUnsignedIntImpl(other);
  }

  template <typename T>
  REQUIRES((is_native_integer<T>::value))
  RETURN(ExtendedUnsignedIntImpl&) operator^=(const T& other) {
    return *this ^= ExtendedUnsignedIntImpl(other);
  }

  ExtendedUnsignedIntImpl& operator|=(const ExtendedUnsignedIntImpl& other) {
    base::low_ |= other.low();
    base::hi_ |= other.hi();
    return *this;
  }

  ExtendedUnsignedIntImpl& operator|=(const ET& other) {
    return *this |= ExtendedUnsignedIntImpl(other);
  }

  template <typename T>
  REQUIRES((is_native_integer<T>::value))
  RETURN(ExtendedUnsignedIntImpl&) operator|=(const T& other) {
    return *this |= ExtendedUnsignedIntImpl(other);
  }

  ExtendedUnsignedIntImpl& operator>>=(int cnt) {
    base::ShiftRight(cnt);
    return *this;
  }

  ExtendedUnsignedIntImpl& operator<<=(int cnt) {
    base::ShiftLeft(cnt);
    return *this;
  }

  ExtendedUnsignedIntImpl& operator++() {
    base::AddOne();
    return *this;
  }

  ExtendedUnsignedIntImpl operator++(int) {
    ExtendedUnsignedIntImpl ret(*this);
    *this += 1;
    return ret;
  }

  ExtendedUnsignedIntImpl& operator--() {
    if (!base::low_.IsZero()) {
      --base::low_;
    } else {
      --base::low_;
      --base::hi_;
    }
    return *this;
  }

  ExtendedUnsignedIntImpl operator--(int) {
    ExtendedUnsignedIntImpl ret(*this);
    *this -= 1;
    return ret;
  }

 public:
  // All the binary operators are friend operators
  // Comparison operators
#if PE_HAS_CPP20
  friend inline int operator<=>(const ExtendedUnsignedIntImpl& l,
                                const ExtendedUnsignedIntImpl& r) {
    return l.CompareTo(r);
  }
  friend inline int operator==(const ExtendedUnsignedIntImpl& l,
                               const ExtendedUnsignedIntImpl& r) {
    return l.CompareTo(r) == 0;
  }
  friend inline int operator!=(const ExtendedUnsignedIntImpl& l,
                               const ExtendedUnsignedIntImpl& r) {
    return l.CompareTo(r) != 0;
  }
#else
  friend inline int operator<(const ExtendedUnsignedIntImpl& l,
                              const ExtendedUnsignedIntImpl& r) {
    return l.CompareTo(r) < 0;
  }
  friend inline int operator<=(const ExtendedUnsignedIntImpl& l,
                               const ExtendedUnsignedIntImpl& r) {
    return l.CompareTo(r) <= 0;
  }
  friend inline int operator>(const ExtendedUnsignedIntImpl& l,
                              const ExtendedUnsignedIntImpl& r) {
    return l.CompareTo(r) > 0;
  }
  friend inline int operator>=(const ExtendedUnsignedIntImpl& l,
                               const ExtendedUnsignedIntImpl& r) {
    return l.CompareTo(r) >= 0;
  }
  friend inline int operator==(const ExtendedUnsignedIntImpl& l,
                               const ExtendedUnsignedIntImpl& r) {
    return l.CompareTo(r) == 0;
  }
  friend inline int operator!=(const ExtendedUnsignedIntImpl& l,
                               const ExtendedUnsignedIntImpl& r) {
    return l.CompareTo(r) != 0;
  }
#endif
  friend inline ExtendedUnsignedIntImpl operator+(
      const ExtendedUnsignedIntImpl& l, const ExtendedUnsignedIntImpl& r) {
    ExtendedUnsignedIntImpl ret(l);
    ret += r;
    return ret;
  }
  friend inline ExtendedUnsignedIntImpl operator-(
      const ExtendedUnsignedIntImpl& l, const ExtendedUnsignedIntImpl& r) {
    ExtendedUnsignedIntImpl ret(l);
    ret -= r;
    return ret;
  }
  friend inline ExtendedUnsignedIntImpl operator*(
      const ExtendedUnsignedIntImpl& l, const ExtendedUnsignedIntImpl& r) {
    ExtendedUnsignedIntImpl ret(l);
    ret *= r;
    return ret;
  }
  friend inline ExtendedUnsignedIntImpl operator/(
      const ExtendedUnsignedIntImpl& l, const ExtendedUnsignedIntImpl& r) {
    ExtendedUnsignedIntImpl ret(l);
    ret /= r;
    return ret;
  }
  friend inline ExtendedUnsignedIntImpl operator%(
      const ExtendedUnsignedIntImpl& l, const ExtendedUnsignedIntImpl& r) {
    ExtendedUnsignedIntImpl ret(l);
    ret %= r;
    return ret;
  }
  friend inline ExtendedUnsignedIntImpl operator&(
      const ExtendedUnsignedIntImpl& l, const ExtendedUnsignedIntImpl& r) {
    ExtendedUnsignedIntImpl ret(l);
    ret &= r;
    return ret;
  }
  friend inline ExtendedUnsignedIntImpl operator^(
      const ExtendedUnsignedIntImpl& l, const ExtendedUnsignedIntImpl& r) {
    ExtendedUnsignedIntImpl ret(l);
    ret ^= r;
    return ret;
  }
  friend inline ExtendedUnsignedIntImpl operator|(
      const ExtendedUnsignedIntImpl& l, const ExtendedUnsignedIntImpl& r) {
    ExtendedUnsignedIntImpl ret(l);
    ret |= r;
    return ret;
  }
  friend inline ExtendedUnsignedIntImpl operator<<(
      const ExtendedUnsignedIntImpl& l, const int cnt) {
    ExtendedUnsignedIntImpl ret(l);
    ret <<= cnt;
    return ret;
  }
  friend inline ExtendedUnsignedIntImpl operator>>(
      const ExtendedUnsignedIntImpl& l, const int cnt) {
    ExtendedUnsignedIntImpl ret(l);
    ret >>= cnt;
    return ret;
  }
  friend inline std::ostream& operator<<(std::ostream& o,
                                         const ExtendedUnsignedIntImpl& n) {
    return o << n.ToString();
  }
};

template <typename ET, bool is_native_integer>
SL int IsZero(const ExtendedUnsignedIntImpl<ET, is_native_integer>& x) {
  return x.IsZero();
}

template <typename ET, bool is_native_integer>
SL int IntSign(const ExtendedUnsignedIntImpl<ET, is_native_integer>& x) {
  return x.IntSign();
}

template <typename ET, bool is_native_integer>
SL int IsEven(const ExtendedUnsignedIntImpl<ET, is_native_integer>& x) {
  return x.IsEven();
}

template <typename ET, bool is_native_integer>
SL int IsOdd(const ExtendedUnsignedIntImpl<ET, is_native_integer>& x) {
  return x.IsOdd();
}

template <typename ET, bool is_native_integer>
SL unsigned int LowerBits(
    const ExtendedUnsignedIntImpl<ET, is_native_integer>& x) {
  return x.LowerBits();
}

template <typename ET, bool is_native_integer>
SL ExtendedUnsignedIntImpl<ET, is_native_integer> Abs(
    const ExtendedUnsignedIntImpl<ET, is_native_integer>& x) {
  return x;
}

template <typename ET, bool is_native_integer>
SL ExtendedUnsignedIntImpl<ET, is_native_integer> FAbs(
    const ExtendedUnsignedIntImpl<ET, is_native_integer>& x) {
  return x;
}

template <typename ET, bool is_native_integer>
SL int SameParity(const ExtendedUnsignedIntImpl<ET, is_native_integer>& l,
                  const ExtendedUnsignedIntImpl<ET, is_native_integer>& r) {
  return SameParity(l.LowerBits(), r.LowerBits());
}

template <typename ET, bool is_native_integer>
SL std::tuple<ExtendedUnsignedIntImpl<ET, is_native_integer>,
              ExtendedUnsignedIntImpl<ET, is_native_integer>>
Div(const ExtendedUnsignedIntImpl<ET, is_native_integer>& l,
    const ExtendedUnsignedIntImpl<ET, is_native_integer>& r) {
  ExtendedUnsignedIntImpl<ET, is_native_integer> remain;
  ExtendedUnsignedIntImpl<ET, is_native_integer> d(l);
  d.DivImpl(r, remain);
  return {d, remain};
}

template <typename T, typename ET, bool is_native_integer>
SL T ToInt(const ExtendedUnsignedIntImpl<ET, is_native_integer>& x) {
  return x.template ToInt<T>();
}

template <typename T, typename ET, bool is_native_integer>
SL T ToFloat(const ExtendedUnsignedIntImpl<ET, is_native_integer>& x) {
  return x.template ToFloat<T>();
}

template <typename ET, bool is_native_integer>
SL std::string ToString(
    const ExtendedUnsignedIntImpl<ET, is_native_integer>& x) {
  return x.ToString();
}

template <typename ET, bool is_native_integer>
SL std::string to_string(
    const ExtendedUnsignedIntImpl<ET, is_native_integer>& x) {
  return ToString(x);
}

template <typename ET, bool is_native_integer, typename T2>
SL REQUIRES((pe::is_native_integer<T2>::value))
    RETURN(ExtendedUnsignedIntImpl<ET, is_native_integer>)
        Power(ExtendedUnsignedIntImpl<ET, is_native_integer> x, T2 n) {
  PE_ASSERT(n >= 0);
  ExtendedUnsignedIntImpl<ET, is_native_integer> ret = 1;
  for (; n > 0; n >>= 1) {
    if (n & 1) ret *= x;
    if (n > 1) x *= x;
  }
  return ret;
}

template <typename ET, bool is_native_integer, typename T2, typename T3>
SL REQUIRES((pe::is_native_integer<T2>::value))
    RETURN(ExtendedUnsignedIntImpl<ET, is_native_integer>)
        Power(ExtendedUnsignedIntImpl<ET, is_native_integer> x, T2 n, T3 mod) {
  PE_ASSERT(n >= 0);
  ExtendedUnsignedIntImpl<ET, is_native_integer> ret = 1;
  for (; n > 0; n >>= 1) {
    if (n & 1) ret = ret * x % mod;
    if (n > 1) x = x * x % mod;
  }
  return ret;
}

template <typename ET>
using ExtendedUnsignedInt =
    ExtendedUnsignedIntImpl<ET, is_native_integer<ET>::value>;

#if PE_HAS_CPP20
static_assert(PeNumberUtil<ExtendedUnsignedInt<uint64>>);
#if PE_HAS_INT128
static_assert(PeNumberUtil<ExtendedUnsignedInt<uint128>>);
#endif
#endif
}  // namespace pe

#endif
