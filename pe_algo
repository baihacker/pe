#ifndef PE_ALGO_
#define PE_ALGO_

#include "pe_base"
#include "pe_int128"
#include "pe_span"
#include "pe_nt"
#include "pe_poly_algo"
#include "pe_tree"
#include "pe_array"
#include "pe_parallel_algo"

namespace pe {
// Finds the first x value in [l, r] such that f(x) is true.
// Returns r + 1 if failed.
// It is assumed that if f(x) is true then f(x+1) is true.
// It's required that l - 1 <= r, i.e. l <= r or l - 1 = r.
template <typename T, typename F>
SL constexpr T BinarySearchFirst(T l, T r, const F& f) {
  ++r;
  PE_ASSERT(l <= r);
  auto len = r - l;
  while (len > 0) {
    const auto half = len >> 1;
    const T mid = l + half;
    if (f(mid)) {
      len = half;
    } else {
      l = mid + 1;
      len = len - half - 1;
    }
  }
  return l;
}

// Finds the last x value in [l, r] such that f(x) is true.
// Returns l - 1 if failed.
// It is assumed that if f(x) is true then f(x-1) is true.
// It's required that l - 1 <= r, i.e. l <= r or l - 1 = r.
template <typename T, typename F>
SL constexpr T BinarySearchLast(T l, T r, const F& f) {
  --l;
  PE_ASSERT(l <= r);
  auto len = r - l;
  while (len > 0) {
    const auto half = len >> 1;
    const T mid = r - half;
    if (f(mid)) {
      len = half;
    } else {
      r = mid - 1;
      len = len - half - 1;
    }
  }
  return r;
}

// Calculates n! % p.
// Algorithm source: https://min-25.hatenablog.com/entry/2017/04/10/215046
// Complexity: M(p^(1/2))
template <typename T = int64>
struct FactModer {
  FactModer(uint64 p) : p_(p) { Init(); }

  // Evaluate (x+v*0+1)*(x+v*1+1)*(x+v*2+1)*...*(x+v*(d-1)+1) at 0, 1, 2, ..., d
  void Evaluate(int d, uint64* result, uint64 v) {
    if (d == 1) {
      result[0] = 1;
      result[1] = p_ == 2 ? 0 : 2;
      return;
    }

    const int half_d = d >> 1;
    Evaluate(half_d, result, v);
    std::copy(result, result + half_d + 1, &g0_[0]);
#if ENABLE_OPENMP
#pragma omp parallel sections if (d >= 10000)
#endif
    {
#if ENABLE_OPENMP
#pragma omp section
#endif
      PolyOffsetEvaluate<uint64>(half_d, result, &g1_[0], half_d + 1,
                                 &pre_fact_inv_[0], p_);
#if ENABLE_OPENMP
#pragma omp section
#endif
      PolyOffsetEvaluate<uint64>(half_d, result, &g2_[0], v * half_d,
                                 &pre_fact_inv_[0], p_);
#if ENABLE_OPENMP
#pragma omp section
#endif
      PolyOffsetEvaluate<uint64>(half_d, result, &g3_[0], v * half_d + half_d,
                                 &pre_fact_inv_[0], p_);
    }

    for (int i = 0; i <= half_d; ++i) {
      result[i] = MulMod(g0_[i], g2_[i], p_);
    }
    for (int i = half_d + 1, j = 0; i <= half_d * 2; ++i, ++j) {
      result[i] = MulMod(g1_[j], g3_[j + 1], p_);
    }

    if (d & 1) {
      uint64 tmp = (v * (d - 1) + 1) % p_;
      for (int i = 0; i <= 2 * half_d; ++i) {
        result[i] = MulMod(result[i], tmp++, p_);
        if (tmp >= p_) tmp -= p_;
      }
      uint64 t = 1;
      uint64 c = d + 1;
      for (int i = 0; i < d; ++i) {
        t = MulMod(t, c, p_);
        c += v;
        if (c >= p_) c -= p_;
      }
      result[d] = t;
    }
  }

  T operator()(uint64 n) { return Cal(n); }

  T Cal(uint64 n) {
    if (n >= p_) return 0;
    if (n < q_) return pre_fact_[n];

    uint64 m = static_cast<int64>(std::sqrt(n));
    uint64 ret = 1;

    for (uint64 i = m * m + 1; i <= n; ++i) {
      ret = MulMod(ret, i, p_);
    }

    Evaluate(static_cast<int>(m), static_cast<uint64*>(&v_[0]), m);

    for (int i = 0; i < m; ++i) {
      ret = MulMod(ret, v_[i], p_);
    }
    return static_cast<int64>(ret);
  }

  void Init() {
    q_ = static_cast<uint64>(std::sqrt(p_));
    while (q_ * q_ < p_) ++q_;
    q_ <<= 1;
    q_ += 1;
    pre_fact_.resize(q_);
    pre_fact_inv_.resize(q_);
    InitSeqProd2<uint64>(&pre_fact_[0], &pre_fact_inv_[0], 1, q_ - 1, p_);
    g0_.resize(q_);
    g1_.resize(q_);
    g2_.resize(q_);
    g3_.resize(q_);
    v_.resize(q_);
  }

 private:
  uint64 p_;
  uint64 q_;
  std::vector<uint64> pre_fact_, pre_fact_inv_;
  std::vector<uint64> g0_, g1_, g2_, g3_;
  std::vector<uint64> v_;
};

// Calculates: (0! + 1! + 2! + ... + n!) % p
// Complexity: M(p^(1/2))
// Example result: f(4e8)%99999999907 = 16815920030
template <typename T = int64>
struct FactSumModer {
  FactSumModer(uint64 p) : p_(p) { Init(); }

  T operator()(uint64 n) { return Cal(n); }

  T Cal(uint64 n) {
    if (n >= p_) n = p_ - 1;
    if (n < q_) return pre_fact_sum_[n];

    const int64 m = static_cast<int64>(std::sqrt(n));
    uint64 ret = 1;

    // Prepare data for computing P
    std::vector<uint64> X((m - 1) * 2);
    for (int i = 0; i < m - 1; ++i) {
      X[i * 2] = i + 1;
      X[i * 2 + 1] = m;
    }

    std::vector<uint64> V(m);
    for (int i = 0; i < m; ++i) {
      V[i] = i;
    }

    // Compute P
    std::vector<uint64> YQ;
    auto YP = PolyBatchMulAcc(X, 0, static_cast<int>(m - 1), YQ, p_);
    YP[0] = AddMod(YP[0], 1, p_);
    auto P = PolyMultipointEvaluate(YP, V, p_);

    // Prepare data for computing Q
    // YQ *= (m + xm)
    YQ.resize(m + 1);
    YQ[m] = YQ[m - 1];
    for (int i = static_cast<int>(m - 1); i >= 1; --i) {
      YQ[i] = AddMod(YQ[i], YQ[i - 1], p_);
    }
    for (auto& i : YQ) i = MulMod(i, m, p_);

    // V.extend(m)
    V.push_back(m);

    // Compute Q
    auto Q = PolyMultipointEvaluate(YQ, V, p_);
    for (int i = 1; i <= m; ++i) {
      Q[i] = MulMod(Q[i], Q[i - 1], p_);
    }

    // Compute P
    X.resize((m - 1) * 2);
    V.resize(m);
    // deg y = m - 1

    // Compute result
    int64 result = P[0];
    for (int i = 1; i < m; ++i) {
      uint64 t = MulMod(P[i], Q[i - 1], p_);
      result = AddMod(result, t, p_);
    }

    uint64 last = Q[m - 1];
    for (int64 i = m * m; i <= static_cast<int64>(n); ++i) {
      result = AddMod(result, last, p_);
      last = MulMod(last, i + 1, p_);
    }
    return result;
  }

  void Init() {
    q_ = static_cast<uint64>(std::sqrt(p_));
    while (q_ * q_ < p_) ++q_;
    q_ <<= 1;
    q_ += 1;
    pre_fact_.resize(q_);
    pre_fact_sum_.resize(q_);
    InitSeqProd2<uint64>(&pre_fact_[0], nullptr, q_ - 1, p_);
    pre_fact_sum_[0] = pre_fact_[0];
    for (int i = 1; i < q_; ++i) {
      pre_fact_sum_[i] = AddMod(pre_fact_sum_[i - 1], pre_fact_[i], p_);
    }
  }

 private:
  uint64 p_;
  uint64 q_;
  std::vector<uint64> pre_fact_;
  std::vector<uint64> pre_fact_sum_;
};

// Calculates x^n % mod using pre-computed x^(2^(i))
template <typename T = int64>
struct PowerModer {
  PowerModer(int64 x, int64 mod, int64 f = 0) { Init(x, mod, f); }

  ~PowerModer() = default;

  void Init(int64 f) { Init(x_, mod_, f); }

  void Init(int64 x, int64 mod, int64 f) {
    x_ = x;
    mod_ = mod;
    f_ = std::max<int64>(100000LL, f);
    powers_.resize(f_ + 1);
    powers_[0] = 1 % mod_;
    for (int64 i = 1; i <= f_; ++i) {
      powers_[i] = MulMod<int64, int64, int64>(powers_[i - 1], x_, mod_);
    }
    ppowers_.resize(128);
    ppowers_[0] = x_ % mod_;
    for (int i = 1; i < 128; ++i) {
      ppowers_[i] = MulMod(ppowers_[i - 1], ppowers_[i - 1], mod_);
    }
  }

  T operator()(int64 n) { return Cal(n); }

  T Cal(int64 n) {
    if (n <= f_) {
      return powers_[n];
    }
    int64 r = 1 % mod_;
    for (int i = 0; n; n >>= 1, ++i) {
      if (n & 1) {
        r = MulMod(r, ppowers_[i], mod_);
      }
    }
    return r;
  }

 private:
  int64 x_, mod_, f_;
  std::vector<int64> powers_, ppowers_;
};

// Calculates x^n % mod.
// Unlike using pre-computed x^(2^(i)), this implementation extends 2 to 2^k.
// (k = lgf_, f is aligned to the power of 2).
// In most cases, it is not necessary to specify f.
template <typename T = int64>
struct PowerModerEx {
  PowerModerEx(int64 x, int64 mod, int64 f = 0) { Init(x, mod, f); }

  ~PowerModerEx() = default;

  void Init(int64 f) { Init(x_, mod_, f); }

  void Init(int64 x, int64 mod, int64 f) {
    x_ = x;
    mod_ = mod;
    f_ = std::max<int64>(512LL, f);
    lgf_ = pe_lgll(f_);
    if (1LL << lgf_ <= f_) {
      ++lgf_;
    }
    f_ = 1LL << lgf_;
    mask_ = f_ - 1;
    powers_.resize(f_);
    powers_[0] = 1 % mod_;
    for (int64 i = 1; i < f_; ++i) {
      powers_[i] = MulMod<int64, int64, int64>(powers_[i - 1], x_, mod_);
    }
    c_ = MulMod(powers_.back(), x_, mod_);

    const int64 size = (128 + lgf_ - 1) / lgf_;
    ppowers_.resize(size);
    ppowers_[0] = powers_;

    for (int64 i = 1; i < size; ++i) {
      const int64 base = PowerMod(ppowers_[i - 1][1], f_, mod_);
      ppowers_[i].push_back(1 % mod_);
      for (int64 j = 1; j < f_; ++j) {
        ppowers_[i].push_back(PowerMod<int64, int64, int64>(base, j, mod_));
      }
    }
  }

  T operator()(int64 n) { return Cal(n); }

  T Cal(int64 n) {
    if (n <= f_) {
      return powers_[n];
    }
    int64 r = 1 % mod_;
    for (int i = 0; n; n >>= lgf_, ++i) {
      const int64 now = n & mask_;
      if (now) {
        r = MulMod(r, ppowers_[i][now], mod_);
      }
    }
    return r;
  }

 private:
  int64 x_, mod_, f_, lgf_, mask_, c_;
  std::vector<int64> powers_;
  std::vector<std::vector<int64>> ppowers_;
};

// Calculates Binomial(n, m) % p where p is prime
template <typename T = int64>
struct CombModer {
  CombModer(int64 p, int64 f = 0) { Init(p, f == 0 ? p : f); }

  ~CombModer() = default;

  void Init(int64 f) { Init(p_, f); }

  void Init(int64 p, int64 f) {
    p_ = p;
    f_ = std::min(f, p_ - 1);
    fac_.resize(f_ + 1);
    ifac_.resize(f_ + 1);
    InitSeqProd2<int64>(&fac_[0], &ifac_[0], 1, f_, p_);
  }

  int64 Sign(int64 x) const { return x & 1 ? p_ - 1 : 1; }

  T operator()(int64 n, int64 m) const { return Cal(n, m); }

  T Comb(int64 n, int64 m) const { return Cal(n, m); }

  T Cal(int64 n, int64 m) const {
    if (n < 0 || m > n) return 0;
    if (m == n || m == 0) return 1;
    if (m == 1 || m == n - 1) return n % p_;

    if (n <= f_) {
      return MulMod(MulMod(fac_[n], ifac_[m], p_), ifac_[n - m], p_);
    }

    // It's required that x % p_ <= f_ in the following code.

    int64 pp = 0;
    int64 dist = n - m;

    for (int64 nn = n / p_, mm = m / p_, dd = dist / p_; nn;
         nn /= p_, mm /= p_, dd /= p_) {
      pp += nn - mm - dd;
    }
    if (pp) return 0;
    int64 l = 1, r = 1;
    for (int64 x = n; x; x /= p_) {
      l = MulMod(l, Sign(x / p_), p_);
      l = MulMod(l, fac_[x % p_], p_);
    }
    for (int64 x = m; x; x /= p_) {
      r = MulMod(r, Sign(x / p_), p_);
      r = MulMod(r, fac_[x % p_], p_);
    }
    for (int64 x = dist; x; x /= p_) {
      r = MulMod(r, Sign(x / p_), p_);
      r = MulMod(r, fac_[x % p_], p_);
    }
    return MulMod(InvOf(r, p_), l, p_);
  }

 private:
  int64 p_, f_;
  std::vector<int64> fac_, ifac_;
};

// Calculates Binomial(n, m) % mod
SL int64 ShortCombMod(int64 n, int64 m, int64 mod) {
  if (m > n || m < 0) return 0;
  if (n - m < m) m = n - m;
  std::vector<int64> data;
  for (int64 i = n; i >= n - m + 1; --i) data.push_back(i);
  const int size = static_cast<int>(data.size());
  for (int i = 2; i <= m; ++i) {
    int64 a = i;
    for (int j = 0; j < size && a > 1; ++j) {
      for (;;) {
        int64 t = Gcd(a, data[j]);
        if (t == 1) break;
        a /= t;
        data[j] /= t;
      }
    }
  }
  int64 ret = 1;
  for (int i = 0; i < size; ++i) {
    ret = MulMod(ret, data[i], mod);
  }
  return ret;
}

// Calculates C(n, m) % p where p is a large prime.
// Complexity: log(m) M(p^(1/2))
template <typename T = int64>
struct CombModerEx {
  CombModerEx(int64 p) : p_(p), fmoder_(p) {}

  int64 Sign(int64 x) const { return x & 1 ? p_ - 1 : 1; }

  T Comb(int64 n, int64 m) { return Cal(n, m); }

  T Cal(int64 n, int64 m) {
    if (n < 0 || m > n) return 0;
    if (m == n || m == 0) return 1;
    if (m == 1 || m == n - 1) return n % p_;

    int64 pp = 0;
    int64 dist = n - m;

    for (int64 nn = n / p_, mm = m / p_, dd = dist / p_; nn;
         nn /= p_, mm /= p_, dd /= p_) {
      pp += nn - mm - dd;
    }
    if (pp) return 0;
    int64 l = 1, r = 1;
    for (int64 x = n; x; x /= p_) {
      l = MulMod(l, Sign(x / p_), p_);
      l = MulMod(l, fmoder_.Cal(x % p_), p_);
    }
    for (int64 x = m; x; x /= p_) {
      r = MulMod(r, Sign(x / p_), p_);
      r = MulMod(r, fmoder_.Cal(x % p_), p_);
    }
    for (int64 x = dist; x; x /= p_) {
      r = MulMod(r, Sign(x / p_), p_);
      r = MulMod(r, fmoder_.Cal(x % p_), p_);
    }

    return MulMod(InvOf(r, p_), l, p_);
  }

 private:
  int64 p_;
  FactModer<int64> fmoder_;
};

// Computes Binomial(a, b) mod p^e
template <typename T>
struct CombModerPrimePower {
  CombModerPrimePower(const T p, const T e) : p_(p), e_(e) {
    T pe = p_ * e_;
    mod_ = Power(T(p_), e_);
    phi_ = Power(T(p_), (e_ - 1)) * (p_ - 1);
    f_.resize(pe + 1, 1);
    for (int i = 1; i <= pe; ++i) {
      if (i % p_ == 0) {
        f_[i] = f_[i - 1];
      } else {
        f_[i] = MulMod(f_[i - 1], i, mod_);
      }
    }

    ppower_.resize(e_);
    ppower_[0] = 1;
    for (int i = 1; i < e_; ++i) {
      ppower_[i] = MulMod(ppower_[i - 1], p, mod_);
    }
  }

  // Note: if i % p == 0, then the contribution of i is 1.
  T FactorialModInternal(const T& n) const {
    T u = n / p_;
    T v = n % p_;
    T r = (e_ + 1) >> 1;

    T ret = 1;
    const T u2 = u * u;

    for (int j = 1; j <= r; ++j) {
      T beta_numer = u;
      T beta_denom = j;
      const int j2 = j * j;
      for (int i = 1; i <= r; ++i) {
        if (i != j) {
          beta_numer *= u2 - i * i;
          beta_denom *= j2 - i * i;
        }
      }
      T beta = beta_numer / beta_denom % phi_;
      if (IntSign(beta) < 0) {
        beta += phi_;
      }
      ret = MulMod(ret, PowerMod(f_[j * p_], beta, mod_), mod_);
    }

    if (p_ == 2) {
      T left_mod4 = ((LowerBits(u * p_ + 1) & 4) >> 1) + 1;
      T right_mod4 = LowerBits(ret) & 3;
      if (left_mod4 != right_mod4) {
        ret = (mod_ - ret) % mod_;
      }
    }

    ret = MulMod(ret, f_[v], mod_);

    for (int j = 1; j < e_; ++j) {
      T base = MulMod(f_[j * p_ + v],
                      ModInv(MulMod(f_[v], f_[j * p_], mod_), mod_), mod_);
      T alpha_numer = u;
      T alpha_denom = j;
      for (int i = 1; i < e_; ++i) {
        if (i != j) {
          alpha_numer *= u - i;
          alpha_denom *= j - i;
        }
      }
      T alpha = alpha_numer / alpha_denom % phi_;
      if (IntSign(alpha) < 0) alpha += phi_;
      ret = MulMod(ret, PowerMod(base, alpha, mod_), mod_);
    }

    return ret;
  }

  // Note: if i = p^a q where (p, q) = 1, then the contribution of i is q.
  T FactorialMod(T n) const {
    T result = FactorialModInternal(n);
    for (n /= p_; n; n /= p_) {
      result = MulMod(result, FactorialModInternal(n), mod_);
    }
    return result;
  }

  T operator()(T n, T m) const { return Cal(n, m); }

  T Comb(T n, T m) const { return Cal(n, m); }

  T Cal(T n, T m) const {
    if (m < 0 || m > n) return 0;
    if (m == 0 || n == m) return 1;
    T pp = 0;
    for (T nn = n / p_, mm = m / p_, dd = (n - m) / p_; nn;
         nn /= p_, mm /= p_, dd /= p_) {
      pp += nn - mm - dd;
    }
    if (pp >= e_) return 0;
    T u = FactorialMod(n);
    T v = MulMod(FactorialMod(m), FactorialMod(n - m), mod_);
    if (pp) u = MulMod(u, ppower_[pp], mod_);
    return MulMod(u, ModInv(v, mod_), mod_);
  }

 private:
  std::vector<T> f_;
  std::vector<T> ppower_;
  T p_;
  T e_;
  T mod_;
  T phi_;
};

// Computes Binomial(a, b) mod p^2
template <typename T>
struct CombModerPrimeSquare {
  CombModerPrimeSquare(const T p) : p_(p) {
    mod_ = p_ * p_;
    f_.resize(p_);
    f_[0] = 1 % mod_;

    for (T i = 1; i < p_; ++i) {
      f_[i] = MulMod(f_[i - 1], i, mod_);
    }

    h_.resize(p_);
    InitInverse(h_.begin(), p_ - 1, p_);
    for (T i = 1; i < p_; ++i) {
      h_[i] = AddMod(h_[i - 1], h_[i], p_);
    }
  }

  // Note: if i = p^a q where (p, q) = 1, then the contribution of i is q.
  T FactorialMod(T n) const {
    T result = 1;
    for (; n; n /= p_) {
      const T t0 = Mod(n / p_, mod_);
      const T t1 = MulMod(MulMod(f_[n % p_], p_, mod_),
                          MulMod(h_[n % p_], t0, mod_), mod_);
      const T t2 = PowerMod(f_[p_ - 1], n / p_, mod_);
      const T t = MulMod(AddMod(f_[n % p_], t1, mod_), t2, mod_);
      result = MulMod(result, t, mod_);
    }
    return result;
  }

  T operator()(T n, T m) const { return Cal(n, m); }

  T Comb(T n, T m) const { return Cal(n, m); }

  T Cal(T n, T m) const {
    if (m < 0 || m > n) return 0;
    if (m == 0 || n == m) return 1;
    T pp = 0;
    for (T nn = n / p_, mm = m / p_, dd = (n - m) / p_; nn;
         nn /= p_, mm /= p_, dd /= p_) {
      pp += nn - mm - dd;
    }
    if (pp >= 2) return 0;
    T u = FactorialMod(n);
    T v = MulMod(FactorialMod(m), FactorialMod(n - m), mod_);
    if (pp) u = MulMod(u, p_, mod_);
    return MulMod(u, ModInv(v, mod_), mod_);
  }

 private:
  std::vector<T> f_;
  std::vector<T> h_;
  T p_;
  T mod_;
};

// Calculates (1^k + 2^k + ... + n^k) % mod based on k! * Stirling2.
// https://oeis.org/A019538
// https://blog.csdn.net/xianhaoming/article/details/80390426
template <typename T = int64>
struct PowerSumModer {
  PowerSumModer(int64 mod, int maxk = 128) : mod_(mod), maxk_(maxk) {
    Init(maxk);
  }

  ~PowerSumModer() = default;

  void Init(int maxk = 128) {
    maxk_ = maxk;

    std::vector<std::vector<int64>>(maxk_ + 1).swap(p_);
    for (int i = 0; i <= maxk_; ++i) {
      std::vector<int64>(maxk_ + 1).swap(p_[i]);
    }

    std::vector<int64>(maxk_ + 2).swap(invs_);

    InitInverse(&invs_[0], maxk_ + 1, mod_);
    for (int i = 0; i <= maxk_; ++i) {
      for (int j = 0; j <= maxk_; ++j) {
        p_[i][j] = 0;
      }
    }
    for (int i = 0; i <= maxk_; ++i) p_[i][1] = 1;
    for (int i = 1; i <= maxk_; ++i) {
      for (int j = 1; j < i; ++j) {
        int64 t = p_[i - 1][j - 1] + p_[i - 1][j];
        if (t >= mod_) t -= mod_;
        p_[i][j] = MulMod(j, t, mod_);
      }
      p_[i][i] = 1;
      for (int j = 1; j <= i; ++j) {
        p_[i][i] = MulMod(p_[i][i], j, mod_);
      }
    }
  }

  T operator()(int64 n, int64 k) const { return Cal(n, k); }

  // n + 1, n, ..., n-k+1 is not divisible by mod
  // 2, 3, ..., k+1 is not divisible by mod
  T Cal(int64 n, int64 k) const {
    PE_ASSERT(k <= maxk_);
    if (k == 0) {
      return n % mod_;
    }

    int64 ret = 0;
    int64 c = (n + 1) % mod_;
    for (int i = 1; i <= k; ++i) {
      // ret += P[k][i] * ShortCombMod(n + 1, i + 1, mod) % mod;
      c = MulMod(c, Mod(n + 1 - i, mod_), mod_);
      c = MulMod(c, invs_[i + 1], mod_);
      if (c == 0) {
        break;
      }
      ret += MulMod(p_[k][i], c, mod_);
      if (ret >= mod_) ret -= mod_;
    }
    return ret % mod_;
  }

  int64 CalSafe(int64 n, int64 k) {
    PE_ASSERT(k <= maxk_);
    if (k == 0) {
      return n % mod_;
    }

    int64 A, B;
    std::tie(A, B) = ExtractFactor(n + 1, mod_);

    int64 ret = 0;
    int64 c = A;
    int64 d = B;
    for (int i = 1; i <= k; ++i) {
      // ret += P[k][i] * ShortCombMod(n + 1, i + 1, mod) % mod;
      std::tie(A, B) = ExtractFactor(n + 1 - i, mod_);
      d += B;
      c = MulMod(c, Mod(A, mod_), mod_);

      std::tie(A, B) = ExtractFactor(i + 1, mod_);
      d -= B;
      c = MulMod(c, invs_[A], mod_);

      if (c == 0) {
        break;
      }

      if (d == 0) {
        ret += MulMod(p_[k][i], c, mod_);
        if (ret >= mod_) ret -= mod_;
      }
    }
    return ret % mod_;
  }

 private:
  int64 mod_;
  int maxk_;
  std::vector<std::vector<int64>> p_;
  std::vector<int64> invs_;
};

// Calculates (1^k + 2^k + ... + n^k) % mod based on Bernoulli number
// See
// https://en.wikipedia.org/wiki/Bernoulli_number#Sum_of_powers
// https://blog.csdn.net/acdreamers/article/details/38929067
template <typename T = int64>
struct PowerSumModerB {
  PowerSumModerB(int64 mod, int64 maxk = 128) : mod_(mod), maxk_(maxk) {
    Init(maxk);
  }

  ~PowerSumModerB() = default;

  void Init(int64 maxk = 128) {
    maxk_ = maxk;

    std::vector<int64>(maxk_ + 1).swap(bnl_);
    std::vector<int64>(maxk_ + 2).swap(invs_);

    InitInverse(&invs_[0], maxk_ + 1, mod_);
    InitBernoulliNumber(&bnl_[0], maxk_ + 1, &invs_[0], mod_);

    bnl_[1] = mod_ - bnl_[1];
  }

  T operator()(int64 n, int64 k) const { return Cal(n, k); }

  std::vector<T> operator()(const std::vector<int64>& vec) const {
    return Cal(vec);
  }

  // n + 1, n, ..., n-k+1 is not divisible by mod
  // 2, 3, ..., k+1 is not divisible by mod
  T Cal(int64 n, int64 k) const {
    PE_ASSERT(k <= maxk_);
    if (k == 0) {
      return n % mod_;
    }

    int64 ret = 0;

    const int64 invn = PowerMod(n % mod_, mod_ - 2, mod_);
    int64 c = PowerMod(n % mod_, k + 1, mod_);

    for (int64 i = 0; i <= k; ++i) {
      if (i > 0) {
        c = MulMod(c, Mod(k + 2 - i, mod_), mod_);
        c = MulMod(c, invs_[i], mod_);
        c = MulMod(c, invn, mod_);
      }

      if (c == 0) {
        break;
      }

      ret += MulMod(c, bnl_[i], mod_);
      if (ret >= mod_) ret -= mod_;
    }
    ret = MulMod(ret, invs_[k + 1], mod_);
    return ret;
  }

  std::vector<T> Cal(const std::vector<int64>& vec) const {
    PE_ASSERT(vec.size() <= maxk_ + 1);
    const int64 size = vec.size();
    std::vector<int64> result(size + 1, 0);
    for (int k = 0; k < size; ++k) {
      // comb(k+1, i) b[i] n^(k+1-i) / (k + 1)
      int64 c = invs_[k + 1];
      for (int i = 0; i <= k; ++i) {
        if (i > 0) {
          c = MulMod(c, Mod(k + 2 - i, mod_), mod_);
          c = MulMod(c, invs_[i], mod_);
        }
        int64 x = MulMod(c, bnl_[i], mod_);
        const int idx = k + 1 - i;
        result[idx] = AddMod(result[idx], MulMod(vec[k], x, mod_), mod_);
      }
    }
    std::vector<T> ret(size + 1);
    for (int i = 0; i <= size; ++i) {
      ret[i] = result[i];
    }
    return result;
  }

  T CalSafe(int64 n, int64 k) const {
    PE_ASSERT(k <= maxk_);
    if (k == 0) {
      return n % mod_;
    }

    int64 ret = 0;

    const int64 invn = PowerMod(n % mod_, mod_ - 2, mod_);
    int64 c = PowerMod(n % mod_, k + 1, mod_);

    int64 d = 0;
    for (int64 i = 0; i <= k; ++i) {
      if (i > 0) {
        int64 A, B;

        std::tie(A, B) = ExtractFactor(k + 2 - i, mod_);
        d += B;
        c = MulMod(c, Mod(A, mod_), mod_);

        std::tie(A, B) = ExtractFactor(i, mod_);
        d -= B;
        c = MulMod(c, invs_[A], mod_);

        c = MulMod(c, invn, mod_);
      }
      if (c == 0) {
        break;
      }
      if (d == 0) {
        ret += MulMod(c, bnl_[i], mod_);
        if (ret >= mod_) ret -= mod_;
      }
    }
    ret = MulMod(ret, invs_[k + 1], mod_);
    return ret;
  }

 private:
  int64 mod_;
  int64 maxk_;
  std::vector<int64> bnl_;
  std::vector<int64> invs_;
};

// Calculates (1^k + 2^k + ... + n^k) % mod based on Bernoulli number
// See
// https://en.wikipedia.org/wiki/Bernoulli_number#Sum_of_powers
// https://blog.csdn.net/acdreamers/article/details/38929067
template <typename T = int64>
struct PowerSumModerB1 {
  PowerSumModerB1(int64 mod, int64 maxk = 128) : mod_(mod), maxk_(maxk) {
    Init(maxk);
  }

  ~PowerSumModerB1() = default;

  void Init(int64 maxk = 128) {
    maxk_ = maxk;

    std::vector<int64>(maxk_ + 1).swap(bnl_);
    std::vector<int64>(maxk_ + 2).swap(invs_);

    InitInverse(&invs_[0], maxk_ + 1, mod_);
    InitBernoulliNumber(&bnl_[0], maxk_ + 1, &invs_[0], mod_);
  }

  T operator()(int64 n, int64 k) const { return Cal(n, k); }

  // n + 1, n, ..., n-k+1 is not divisible by mod
  // 2, 3, ..., k+1 is not divisible by mod
  T Cal(int64 n, int64 k) const {
    PE_ASSERT(k <= maxk_);
    if (k == 0) {
      return n % mod_;
    }

    const int64 n1 = (n + 1) % mod_;
    const int64 k1 = k + 1;

    int64 ret = 0;

    int64 c = 1 % mod_;
    for (int64 i = 1; i <= k1; ++i) {
      c = MulMod(c, Mod(k1 - i + 1, mod_), mod_);
      c = MulMod(c, invs_[i], mod_);
      c = MulMod(c, n1, mod_);

      if (c == 0) {
        break;
      }

      ret += MulMod(c, bnl_[k1 - i], mod_);
      if (ret >= mod_) ret -= mod_;
    }
    ret = MulMod(ret, invs_[k1], mod_);
    return ret;
  }

  T CalSafe(int64 n, int64 k) const {
    PE_ASSERT(k <= maxk_);
    if (k == 0) {
      return n % mod_;
    }

    const int64 n1 = (n + 1) % mod_;
    const int64 k1 = k + 1;

    int64 ret = 0;

    int64 c = 1 % mod_;
    int64 d = 0;
    for (int64 i = 1; i <= k1; ++i) {
      int64 A, B;

      std::tie(A, B) = ExtractFactor(k1 - i + 1, mod_);
      d += B;
      c = MulMod(c, Mod(A, mod_), mod_);

      std::tie(A, B) = ExtractFactor(i, mod_);
      d -= B;
      c = MulMod(c, invs_[A], mod_);

      c = MulMod(c, n1, mod_);

      if (c == 0) {
        break;
      }
      if (d == 0) {
        ret += MulMod(c, bnl_[k1 - i], mod_);
        if (ret >= mod_) ret -= mod_;
      }
    }
    ret = MulMod(ret, invs_[k1], mod_);
    return ret;
  }

 private:
  int64 mod_;
  int64 maxk_;
  std::vector<int64> bnl_;
  std::vector<int64> invs_;
};

// Calculates (1^k + 2^k + ... + n^k) % mod
SL int64 PowerSum(int64 n, int64 k, int64 mod) {
  return PowerSumModerB(mod, k).Cal(n, k);
}

// Calculates (1^k + 2^k + ... + n^k) % mod
SL int64 PowerSumSafe(int64 n, int64 k, int64 mod) {
  return PowerSumModerB(mod, k).CalSafe(n, k);
}

// Calculates (1^k + 2^k + ... + n^k) % mod and stores it in result[k].
// comb[i][j] is Binomial coefficient.
// Complex: O(k^2)
// baihacker pe487
template <typename T, int D>
SL void InitPowerSumMod(int64 n, const int maxk, int64* result, T (*comb)[D],
                        const int64 mod) {
  PE_ASSERT(maxk + 1 < D);
  result[0] = n % mod;
  for (int i = 1; i <= maxk; ++i) {
    int64 tmp = PowerMod(n, i + 1, mod);
    for (int j = 2; j <= i + 1; ++j) {
      if (j & 1) {
        tmp = SubMod(tmp, MulMod(comb[i + 1][j], result[i + 1 - j], mod), mod);
      } else {
        tmp = AddMod(tmp, MulMod(comb[i + 1][j], result[i + 1 - j], mod), mod);
      }
    }
    result[i] = MulMod(tmp, InvOf(comb[i + 1][1], mod), mod);
  }
}

// Calculates (1 + 2 + 3 + ... + n) % mod.
SL int64 P1SumMod(int64 n, int64 mod) {
  if (n == 0) return 0;
  if (n < 0) return Mod(-P1SumMod(-n, mod), mod);
  return n & 1 ? MulMod(((n + 1) >> 1) % mod, n % mod, mod)
               : MulMod((n >> 1) % mod, (n + 1) % mod, mod);
}

// Calculates sum of arithmetic progression modulo mod.
// a <= b, a + delta, a + 2 delta, ..., a + maxk detla <= b for delta >= 0 or
// a >= b, a + delta, a + 2 delta, ..., a + maxk delta >= b for delta < 0
SL int64 P1SumMod(int64 a, int64 b, int64 mod, int64 delta = 1) {
  if (delta == 0) {
    PE_ASSERT(a == b);
    return a;
  }
  if (delta > 0 && a > b) return 0;
  if (delta < 0 && a < b) return 0;
  const int64 maxk = (b - a) / delta;
  PE_ASSERT(maxk >= 0);
  const int64 t0 = MulMod((maxk + 1) % mod, Mod(a, mod), mod);
  // delta, 2 delta, maxk delta
  const int64 t1 = MulMod(Mod(delta, mod), P1SumMod(maxk, mod), mod);
  return AddMod(t0, t1, mod);
}

// Calculates (1^2 + 2^2 + 3^2 + ... + n^2) % mod.
// Assume no overflow for 2 * n + 1.
SL int64 P2SumMod(int64 n, int64 mod) {
  if (n <= 0) return 0;
  // n*(n + 1)*(2 n + 1)/6
  int64 a = n, b = n + 1, c = 2 * n + 1;
  switch (n % 6) {
    case 0:
      a /= 6;
      break;
    case 1:
      b >>= 1, c /= 3;
      break;
    case 2:
      a >>= 1, b /= 3;
      break;
    case 3:
      a /= 3, b >>= 1;
      break;
    case 4:
      a >>= 1, c /= 3;
      break;
    case 5:
      b /= 6;
      break;
  }
  return MulMod(a % mod, MulMod(b % mod, c % mod, mod), mod);
}

// Calculates (1^3 + 2^3 + 3^3 + ... + n^3) % mod.
SL int64 P3SumMod(int64 n, int64 mod) {
  if (n <= 0) return 0;
  // (n*(n + 1)/2)^2
  const int64 a = P1SumMod(n, mod);
  return MulMod(a, a, mod);
}

// Calculates (1^4 + 2^4 + 3^4 + ... + n^4) % mod.
// Assume no overflow for 2 * n.
SL int64 P4SumMod(int64 n, int64 mod) {
  if (n <= 0) return 0;
  // (3*n*(n + 1) - 1)*(2*n + 1)*(n + 1)*n/30
  // Handle (2*n + 1)*(n + 1)*n/6
  int64 a = n, b = n + 1, c = 2 * n + 1;
  switch (n % 6) {
    case 0:
      a /= 6;
      break;
    case 1:
      b >>= 1, c /= 3;
      break;
    case 2:
      a >>= 1, b /= 3;
      break;
    case 3:
      a /= 3, b >>= 1;
      break;
    case 4:
      a >>= 1, c /= 3;
      break;
    case 5:
      b /= 6;
      break;
  }
  int done = 0;
  if (!done && a % 5 == 0) a /= 5, done = 1;
  if (!done && b % 5 == 0) b /= 5, done = 1;
  if (!done && c % 5 == 0) c /= 5, done = 1;
  const int64 d = MulMod(a % mod, MulMod(b % mod, c % mod, mod), mod);
  if (done) {
    const int64 t0 = MulMod(n % mod, (n + 1) % mod, mod);
    const int64 t1 = SubMod(MulMod(3LL, t0, mod), 1, mod);
    return MulMod(d, t1, mod);
  }
  // Handle (3*n*n + 3*n - 1)/5
  switch (n % 5) {
    // 3*n*n + 3*n - 1 =
    // 3*(n - 1)*(n - 1) + 5*n + 4*(n - 1)
    // (n - 1)*(3*(n - 1) + 4) + 5*n
    // (n - 1)*(3 n + 1) + 5*n
    case 1: {
      const int64 t0 = AddMod(MulMod(3LL, n, mod), 1, mod);
      const int64 t1 = AddMod(MulMod((n - 1) / 5 % mod, t0, mod), n % mod, mod);
      return MulMod(d, t1, mod);
    }
    // 3*n*n + 3*n - 1 =
    // 3*(n - 3)*(n - 3) + 7*(3*n - 4)
    // 3*(n - 3)*(n - 3) + 7*(3*(n - 3) + 5)
    // 3*(n - 3)*(n - 3) + 7*3*(n - 3) + 35
    // 3*(n - 3)*(n + 4) + 35
    case 3: {
      const int64 t0 =
          MulMod(3LL, MulMod((n - 3) / 5 % mod, (n + 4) % mod, mod), mod);
      const int64 t1 = AddMod(t0, 7, mod);
      return MulMod(d, t1, mod);
    }
    default:
      PE_ASSERT(0);
  }
  return 0;
}

// Calculates (1^5 + 2^5 + 3^5 + ... + n^5) % mod.
// Assume no overflow for 2 * n.
SL int64 P5SumMod(int64 n, int64 mod) {
  if (n <= 0) return 0;
  // n^2*(n + 1)^2*(2*n^2 + 2*n - 1)/12
  // Handle (n (n + 1))^2/4
  int64 a = n, b = n, c = n + 1, d = n + 1;
  if (n % 2 == 0) {
    a >>= 1, b >>= 1;
  } else {
    c >>= 1, d >>= 1;
  }
  int done = 0;
  if (!done && a % 3 == 0) a /= 3, done = 1;
  if (!done && c % 3 == 0) c /= 3, done = 1;
  const int64 e =
      MulMod(MulMod(a % mod, b % mod, mod), MulMod(c % mod, d % mod, mod), mod);
  if (done) {
    const int64 t0 = AddMod(n, n, mod);
    const int64 t1 = MulMod(t0, n, mod);
    const int64 t2 = SubMod(AddMod(t0, t1, mod), 1, mod);
    return MulMod(e, t2, mod);
  }
  // Handle (2*n^2 + 2*n - 1)/3
  // We have n%3 = 1
  // 2*n^2 + 2*n - 1 = 2*(n-1)^2 + 6n - 3
  const int64 t0 = MulMod((n - 1) / 3 % mod, (n - 1) % mod, mod);
  const int64 t1 = AddMod(AddMod(t0, t0, mod), (2 * n - 1) % mod, mod);
  return MulMod(e, t1, mod);
}

// Calculates (1^6 + 2^6 + 3^6 + ... + n^6) % mod.
// Assume no overflow for 2 * n.
SL int64 P6SumMod(int64 n, int64 mod) {
  if (n <= 0) return 0;
  // n*(1 + n)*(1 + 2*n)*(1 - 3*n + 6*n^3 + 3*n^4)/42
  // Handle n*(1 + n)*(1 + 2*n)/6
  // n*(n + 1)*(2*n + 1)/6
  int64 a = n, b = n + 1, c = 2 * n + 1;
  switch (n % 6) {
    case 0:
      a /= 6;
      break;
    case 1:
      b >>= 1, c /= 3;
      break;
    case 2:
      a >>= 1, b /= 3;
      break;
    case 3:
      a /= 3, b >>= 1;
      break;
    case 4:
      a >>= 1, c /= 3;
      break;
    case 5:
      b /= 6;
      break;
  }
  int done = 0;
  if (!done && a % 7 == 0) a /= 7, done = 1;
  if (!done && b % 7 == 0) b /= 7, done = 1;
  if (!done && c % 7 == 0) c /= 7, done = 1;
  const int64 d = MulMod(a % mod, MulMod(b % mod, c % mod, mod), mod);
  if (done) {
    const int64 n1 = n % mod;
    const int64 n2 = MulMod(n1, n1, mod);
    const int64 n3 = MulMod(n1, n2, mod);
    const int64 n4 = MulMod(n2, n2, mod);
    const int64 t0 = SubMod(AddMod(n4, 2 * n3 % mod, mod), n1, mod);
    const int64 t1 = AddMod(MulMod(3, t0, mod), 1, mod);
    return MulMod(d, t1, mod);
  }
  // Handle (1 - 3*n + 6*n^3 + 3*n^4)/7
  const int64 n1 = n % mod;
  const int64 n2 = MulMod(n1, n1, mod);
  const int64 n3 = MulMod(n1, n2, mod);
  switch (n % 7) {
    // 3*(2 + 3*n + 3*n^2 + n^3)*(n - 1) + 7
    case 1: {
      const int64 t0 = AddMod(2LL, MulMod(3LL, n1, mod), mod);
      const int64 t1 = AddMod(MulMod(3LL, n2, mod), n3, mod);
      const int64 t2 =
          MulMod(MulMod(3LL, AddMod(t0, t1, mod), mod), (n - 1) / 7 % mod, mod);
      const int64 t3 = AddMod(t2, 1, mod);
      return MulMod(d, t3, mod);
    }
    // 3*(15 + 8*n + 4*n^2 + n^3)*(n - 2) + 91
    case 2: {
      const int64 t0 = AddMod(15LL, MulMod(8LL, n1, mod), mod);
      const int64 t1 = AddMod(MulMod(4LL, n2, mod), n3, mod);
      const int64 t2 =
          MulMod(MulMod(3LL, AddMod(t0, t1, mod), mod), (n - 2) / 7 % mod, mod);
      const int64 t3 = AddMod(t2, 13LL, mod);
      return MulMod(d, t3, mod);
    }
    // 3*(-10 + 3 n - n^2 + n^3)*(n + 3) + 91
    case 4: {
      const int64 t0 = SubMod(MulMod(3LL, n1, mod), 10LL, mod);
      const int64 t1 = SubMod(n3, n2, mod);
      const int64 t2 =
          MulMod(MulMod(3LL, AddMod(t0, t1, mod), mod), (n + 3) / 7 % mod, mod);
      const int64 t3 = AddMod(t2, 13LL, mod);
      return MulMod(d, t3, mod);
    }
    // 3*(-1 + n^3)*(n + 2) + 7
    case 5: {
      const int64 t0 = MulMod(3LL, SubMod(n3, 1LL, mod), mod);
      const int64 t1 = MulMod(t0, (n + 2) / 7 % mod, mod);
      const int64 t2 = AddMod(t1, 1LL, mod);
      return MulMod(d, t2, mod);
    }
    default:
      PE_ASSERT(0);
  }
  return 0;
}

// Calculates (1^7 + 2^7 + 3^7 + ... + n^7) % mod.
// Assume no overflow for 2 * n.
SL int64 P7SumMod(int64 n, int64 mod) {
  if (n <= 0) return 0;
  // n^2 * (1 + n)^2 * (2 - 4 n - n^2 + 6 n^3 + 3 n^4)/24
  // Handle (n (n + 1))^2/4
  int64 a = n, b = n, c = n + 1, d = n + 1;
  if (n % 2 == 0) {
    a >>= 1, b >>= 1;
  } else {
    c >>= 1, d >>= 1;
  }
  int done3 = 0;
  if (!done3 && a % 3 == 0) a /= 3, done3 = 1;
  if (!done3 && c % 3 == 0) c /= 3, done3 = 1;
  // Handle (2 - 4 n - n^2 + 6 n^3 + 3 n^4)/6
  // Expand[1/6 (2 - 4 n - n^2 + 6 n^3 + 3 n^4) /. {n -> 6 k + f}]
  // 1/3 - (2 f)/3 - f^2/6 + f^3 + f^4/2 - 4 k - 2 f k + 18 f^2 k +
  // 12 f^3 k - 6 k^2 + 108 f k^2 + 108 f^2 k^2 + 216 k^3 + 432 f k^3 +
  // 648 k^4
  const int64 k = n / 6;
  const int64 k1 = k % mod;
  const int64 k2 = MulMod(k1, k1, mod);
  const int64 k3 = MulMod(k2, k1, mod);
  const int64 k4 = MulMod(k2, k2, mod);
  const int64 f1 = n % 6;
  const int64 f2 = f1 * f1;
  const int64 f3 = f2 * f1;
  const int64 f4 = f2 * f2;
  int64 t0 = SubMod(0LL, MulMod(4LL, k1, mod), mod);
  t0 = SubMod(t0, MulMod(2LL, MulMod(f1, k1, mod), mod), mod);
  t0 = AddMod(t0, MulMod(18LL, MulMod(f2, k1, mod), mod), mod);
  t0 = AddMod(t0, MulMod(12LL, MulMod(f3, k1, mod), mod), mod);
  t0 = SubMod(t0, MulMod(6LL, k2, mod), mod);
  t0 = AddMod(t0, MulMod(108LL, MulMod(f1, k2, mod), mod), mod);
  t0 = AddMod(t0, MulMod(108LL, MulMod(f2, k2, mod), mod), mod);
  t0 = AddMod(t0, MulMod(216LL, k3, mod), mod);
  t0 = AddMod(t0, MulMod(432LL, MulMod(f1, k3, mod), mod), mod);
  t0 = AddMod(t0, MulMod(648LL, k4, mod), mod);
  if (done3) {
    t0 = MulMod(3LL, t0, mod);
  }
  const int64 t1 = (3 * f4 + 6 * f3 - f2 - 4 * f1 + 2) / (done3 ? 2 : 6) % mod;
  const int64 t2 =
      MulMod(MulMod(a % mod, b % mod, mod), MulMod(c % mod, d % mod, mod), mod);
  return MulMod(AddMod(t0, t1, mod), t2, mod);
}

SL int64 ApSumMod(int64 n, int64 mod) { return P1SumMod(n, mod); }

SL int64 ApSumMod(int64 a, int64 b, int64 mod, int64 delta = 1) {
  return P1SumMod(a, b, mod, delta);
}

SL int64 SquareSumMod(int64 n, int64 mod) { return P2SumMod(n, mod); }

SL int64 CubeSumMod(int64 n, int64 mod) { return P3SumMod(n, mod); }

SL int64 QuadSumMod(int64 n, int64 mod) { return P4SumMod(n, mod); }

SL int64 PentSumMod(int64 n, int64 mod) { return P5SumMod(n, mod); }

SL int64 HexaSumMod(int64 n, int64 mod) { return P6SumMod(n, mod); }

SL int64 HeptSumMod(int64 n, int64 mod) { return P7SumMod(n, mod); }

// Sum of geometric progression
// (x^a+x^(a+1)+x^(a+2)+...+x^b) % mod
// a >= 0
// zero_p_zero: 0^0
// if b < a: return 0
SL int64 GpSumMod(int64 x, int64 a, int64 b, int64 mod, int64 zero_p_zero = 1) {
  if (mod == 1 || b < a) return 0;
  if (b < a) return 0;
  x %= mod;
  // |x 0|^(b-a) x^a
  // |x 1|       x^a
  int64 u = x;
  int64 w = x;
  int64 v1 = a == 0 && x == 0 ? zero_p_zero : PowerMod(x, a, mod);
  int64 v2 = v1;
  for (int64 n = b - a; n > 0; n >>= 1) {
    if (n & 1) {
      v2 = AddMod(MulMod(w, v1, mod), v2, mod);
      v1 = MulMod(u, v1, mod);
    }
    if (n > 1) {
      w = AddMod(MulMod(w, u, mod), w, mod);
      u = MulMod(u, u, mod);
    }
  }
  return v2;
}

// Given a prime p, provides method to return
// Comb(n, m), Inv(n), Fac(n), IFac(n)
// The results are converted to type T.
template <typename T = int64>
struct PrimeModer {
  PrimeModer(int64 p, int64 f = 0) { Init(p, f == 0 ? p : f); }

  ~PrimeModer() = default;

  void Init(int64 f) { Init(p_, f); }

  void Init(int64 p, int64 f) {
    p_ = p;
    f_ = std::min(f, p_ - 1);
    storage_.resize((f_ + 1) * 3);
    fac_ = &storage_[0];
    ifac_ = &storage_[f_ + 1];
    invs_ = &storage_[2 * (f_ + 1)];
    InitSeqProd2<int64>(fac_, ifac_, 1, f_, p_);
    InitInverse(invs_, f_, p_);
  }

  T Fac(int64 n) const {
    if (n >= 0 && n <= f_) {
      return fac_[n];
    }
    PE_ASSERT(n >= 0 && n <= f_);
    return 0;
  }

  T IFac(int64 n) const {
    if (n >= 0 && n <= f_) {
      return ifac_[n];
    }
    PE_ASSERT(n >= 0 && n <= f_);
    return 0;
  }

  T Inv(int64 n) const {
    if (n >= 0 && n <= f_) {
      return invs_[n];
    }
    return ModInv(n, p_);
  }

  T Comb(int64 n, int64 m) const {
    if (n < 0 || m > n) return 0;
    if (m == n || m == 0) return 1;
    if (m == 1 || m == n - 1) return n % p_;

    if (n <= f_) {
      return MulMod(MulMod(fac_[n], ifac_[m], p_), ifac_[n - m], p_);
    }

    // It's required that x % p_ <= f_ in the following code.

    int64 pp = 0;
    int64 dist = n - m;

    for (int64 nn = n / p_, mm = m / p_, dd = dist / p_; nn;
         nn /= p_, mm /= p_, dd /= p_) {
      pp += nn - mm - dd;
    }
    if (pp) return 0;
    int64 l = 1, r = 1;
    for (int64 x = n; x; x /= p_) {
      l = MulMod(l, Sign(x / p_), p_);
      l = MulMod(l, fac_[x % p_], p_);
    }
    for (int64 x = m; x; x /= p_) {
      r = MulMod(r, Sign(x / p_), p_);
      r = MulMod(r, fac_[x % p_], p_);
    }
    for (int64 x = dist; x; x /= p_) {
      r = MulMod(r, Sign(x / p_), p_);
      r = MulMod(r, fac_[x % p_], p_);
    }
    return MulMod(InvOf(r, p_), l, p_);
  }

 private:
  int64 Sign(int64 x) const { return x & 1 ? p_ - 1 : 1; }

 private:
  int64 p_, f_;
  int64* fac_;
  int64* ifac_;
  int64* invs_;
  std::vector<int64> storage_;
};

// Calculates the number of square free number no more than n.
// If n is no more than pivot, use a pre-computed table.
struct SFCounter {
  SFCounter(int64 pivot_ = pe::maxp) : pivot_(pivot_) {
    if (pe::maxp > 0) {
      Init(pivot_);
    }
  }

  ~SFCounter() = default;

  void Init(int64 pivot = pe::maxp) {
    pivot_ = pivot;
    pre_.resize(pivot_ + 1);
    pre_[0] = 0;
    for (int64 i = 1; i <= pivot_; ++i) {
      pre_[i] = pre_[i - 1] + IsSquareFree(i);
    }
  }

  int64 operator()(int64 n) { return Cal(n); }

  int64 Cal(int64 n) {
    if (n <= pivot_) return pre_[n];
    auto where = mem_.find(n);
    if (where != mem_.end()) return where->second;
    int64 ret = n;
    for (int64 i = 2;; ++i) {
      int64 i2 = i * i;
      if (i2 > n) break;
      ret -= Cal(n / i2);
    }
    return mem_[n] = ret;
  }

 private:
  int64 pivot_;
  std::vector<int64> pre_;
  std::unordered_map<int64, int64> mem_;
};

// Calculates mu(1) + mu(2) + ... + mu(n).
template <typename T = int64>
struct MuSummer {
  MuSummer(int64 pivot = pe::maxp) : pivot_(pivot) {
    if (pe::maxp > 0) {
      Init(pivot_);
    }
  }

  ~MuSummer() = default;

  void Init(int64 pivot = pe::maxp) {
    pivot_ = pivot;

    PE_ASSERT(pivot_ <= pe::maxp);
    PE_ASSERT(pe::mu != nullptr);

    pre_.resize(pivot_ + 1);
    pre_[0] = 0;
    for (int i = 1; i <= pivot_; ++i) {
      pre_[i] = pe::mu[i] + pre_[i - 1];
    }
  }

  T operator()(int64 n) { return Cal(n); }

  T Cal(int64 n) {
    if (n <= pivot_) return pre_[n];

    auto where = mem_.find(n);
    if (where != mem_.end()) return where->second;

    T ret = 1;
    for (int64 i = 2; i <= n;) {
      int64 v = n / i;
      int64 maxi = n / v;
      ret -= (maxi - i + 1) * Cal(v);
      i = maxi + 1;
    }
    return mem_[n] = ret;
  }

 private:
  int64 pivot_;
  std::vector<T> pre_;
  std::unordered_map<int64, T> mem_;
};

// Calculates mu(1) + mu(2) + ... + mu(n) or phi(1) + phi(2) + ... + phi(n)
template <typename T = int64>
struct MuPhiSummer {
  MuPhiSummer(int64 pivot = pe::maxp) : pivot_(pivot) {
    if (pe::maxp > 0) {
      Init(pivot_);
    }
  }

  ~MuPhiSummer() = default;

  void Init(int64 pivot = pe::maxp) {
    pivot_ = pivot;

    PE_ASSERT(pivot <= pe::maxp);
    PE_ASSERT(pe::mu != nullptr);
    PE_ASSERT(pe::phi != nullptr);

    pre_sum_mu_.resize(pivot + 1);
    pre_sum_phi_.resize(pivot + 1);
    pre_sum_mu_[0] = pre_sum_phi_[0] = 0;
    for (int i = 1; i <= pivot; ++i) {
      pre_sum_mu_[i] = pe::mu[i] + pre_sum_mu_[i - 1];
      pre_sum_phi_[i] = pe::phi[i] + pre_sum_phi_[i - 1];
    }
  }

  T CalSumMu(int64 n) {
    if (n <= pivot_) return pre_sum_mu_[n];

    auto where = mem_sum_mu_.find(n);
    if (where != mem_sum_mu_.end()) return where->second;

    T ret = 1;
    for (int64 i = 2; i <= n;) {
      int64 v = n / i;
      int64 maxi = n / v;
      int64 d = maxi - i + 1;
      ret -= d * CalSumMu(v);
      i = maxi + 1;
    }
    return mem_sum_mu_[n] = ret;
  }

  T CalSumPhi(int64 n) {
    if (n <= pivot_) return pre_sum_phi_[n];

    auto where = mem_sum_phi_.find(n);
    if (where != mem_sum_phi_.end()) return where->second;

    T ret = 0;
    T last = 0;
    for (int64 k = 1; k <= n;) {
      int64 v = n / k;
      int64 maxk = n / v;
      T now = CalSumMu(maxk);

      T x = now - last;
      last = now;

      T s = 0;
      if (v & 1) {
        s = T(v + 1 >> 1) * v;
      } else {
        s = T(v >> 1) * (v + 1);
      }
      ret += s * x;
      k = maxk + 1;
    }
    return mem_sum_phi_[n] = ret;
  }

 private:
  int64 pivot_;

  std::vector<T> pre_sum_mu_;
  std::unordered_map<int64, T> mem_sum_mu_;

  std::vector<T> pre_sum_phi_;
  std::unordered_map<int64, T> mem_sum_phi_;
};

// Calculates sigma0(1) + sigma0(2) + ... + sigma0(n).
// sigma0(i) is the number of the divisors of i.
template <typename T = int64>
struct Sigma0Summer {
  Sigma0Summer(int64 pivot = pe::maxp) : pivot_(pivot) {
    if (pe::maxp > 0) {
      Init(pivot_);
    }
  }

  ~Sigma0Summer() = default;

  void Init(int64 pivot = pe::maxp) {
    pivot_ = pivot;

    PE_ASSERT(pivot <= pe::maxp);

    pre_.resize(pivot + 1);
    std::fill(pre_.begin(), pre_.end(), 0);
    for (int i = 1; i <= pivot; ++i) {
      for (int j = i; j <= pivot; j += i) {
        ++pre_[j];
      }
    }
    for (int i = 1; i <= pivot; ++i) {
      pre_[i] += pre_[i - 1];
    }
  }

  T operator()(int64 n) { return Cal(n); }

  T Cal(int64 n) {
    if (n <= pivot_) return pre_[n];

    auto where = mem_.find(n);
    if (where != mem_.end()) return where->second;

    T ret = 0;
    for (int64 i = 1; i * i <= n; ++i) {
      ret += n / i;
    }
    ret += ret;
    const T t = SqrtI(n);
    return mem_[n] = ret - t * t;
  }

 private:
  int64 pivot_;

  std::vector<T> pre_;
  std::unordered_map<int64, T> mem_;
};

// Calculates (mu(1) + mu(2) + ... + mu(n)) % mod or
// (phi(1) + phi(2) + ... + phi(n)) % mod.
// If n is no more than pivot, use a pre-computed table.
struct MuPhiSumModer {
  MuPhiSumModer(int64 mod, int64 pivot = pe::maxp) : mod_(mod), pivot_(pivot) {
    if (pe::maxp > 0) {
      Init(pivot_);
    }
  }

  ~MuPhiSumModer() = default;

  void Init(int64 pivot = pe::maxp) {
    pivot_ = pivot;

    PE_ASSERT(pivot <= pe::maxp);
    PE_ASSERT(pe::mu != nullptr);
    PE_ASSERT(pe::phi != nullptr);

    pre_sum_mu_.resize(pivot + 1);
    pre_sum_phi_.resize(pivot + 1);
    pre_sum_mu_[0] = pre_sum_phi_[0] = 0;
    for (int i = 1; i <= pivot; ++i) {
      pre_sum_mu_[i] = pe::mu[i] + pre_sum_mu_[i - 1];
      pre_sum_phi_[i] = (pe::phi[i] + pre_sum_phi_[i - 1]) % mod_;
      if (pre_sum_mu_[i] < 0) {
        pre_sum_mu_[i] += mod_;
      } else if (pre_sum_mu_[i] >= mod_) {
        pre_sum_mu_[i] -= mod_;
      }
    }
  }

  int64 CalSumMu(int64 n) {
    if (n <= pivot_) return pre_sum_mu_[n];

    auto where = mem_sum_mu_.find(n);
    if (where != mem_sum_mu_.end()) return where->second;

    int64 ret = 1;
    for (int64 i = 2; i <= n;) {
      int64 v = n / i;
      int64 maxi = n / v;
      ret = SubMod(ret, MulMod((maxi - i + 1) % mod_, CalSumMu(v), mod_), mod_);
      i = maxi + 1;
    }
    return mem_sum_mu_[n] = ret;
  }

  int64 CalSumPhi(int64 n) {
    if (n <= pivot_) return pre_sum_phi_[n];

    auto where = mem_sum_phi_.find(n);
    if (where != mem_sum_phi_.end()) return where->second;

    int64 ret = 0;
    int64 last = 0;
    for (int64 k = 1; k <= n;) {
      int64 v = n / k;
      int64 maxk = n / v;
      int64 now = CalSumMu(maxk);

      int64 x = SubMod(now, last, mod_);
      last = now;

      int64 s = 0;
      if (v & 1) {
        s = MulMod((v + 1) / 2 % mod_, v % mod_, mod_);
      } else {
        s = MulMod(v / 2 % mod_, (v + 1) % mod_, mod_);
      }
      ret = AddMod(ret, MulMod(s, x, mod_), mod_);
      k = maxk + 1;
    }
    return mem_sum_phi_[n] = ret;
  }

 private:
  int64 mod_;
  int64 pivot_;

  std::vector<int64> pre_sum_mu_;
  std::unordered_map<int64, int64> mem_sum_mu_;

  std::vector<int64> pre_sum_phi_;
  std::unordered_map<int64, int64> mem_sum_phi_;
};

// Calculates (sigma0(1) + sigma0(2) + ... + sigma0(n)) % mod.
// sigma0(i) is the number of the divisors of i.
struct Sigma0SumModer {
  Sigma0SumModer(int64 mod, int64 pivot = pe::maxp) : mod_(mod), pivot_(pivot) {
    if (pe::maxp > 0) {
      Init(pivot_);
    }
  }

  ~Sigma0SumModer() = default;

  void Init(int64 pivot = pe::maxp) {
    pivot_ = pivot;

    PE_ASSERT(pivot <= pe::maxp);

    pre_.resize(pivot + 1);
    std::fill(pre_.begin(), pre_.end(), 0);
    for (int i = 1; i <= pivot; ++i) {
      for (int j = i; j <= pivot; j += i) {
        ++pre_[j];
      }
    }
    for (int i = 1; i <= pivot; ++i) {
      pre_[i] = AddMod(pre_[i] % mod_, pre_[i - 1], mod_);
    }
  }

  int64 operator()(int64 n) { return Cal(n); }

  int64 Cal(int64 n) {
    if (n <= pivot_) return pre_[n];

    auto where = mem_.find(n);
    if (where != mem_.end()) return where->second;

    int64 ret = 0;
    for (int64 i = 1; i * i <= n; ++i) {
      ret += n / i;
      if (ret >= mod_) {
        ret -= mod_;
      }
    }
    ret <<= 1;
    if (ret >= mod_) {
      ret -= mod_;
    }
    const int64 t = SqrtI(n) % mod_;
    return mem_[n] = SubMod(ret, MulMod(t, t, mod_), mod_);
  }

 private:
  int64 mod_;
  int64 pivot_;

  std::vector<int64> pre_;
  std::unordered_map<int64, int64> mem_;
};

// A helper data structured used to group i and j if [n/i] = [n/j]
template <typename T>
class DVA {
 public:
  template <typename IT>
  struct DVARange {
    IT first;
    IT last;
    DVARange(IT first, IT last) : first(first), last(last) {}
    IT begin() { return first; }
    IT end() { return last; }
  };

  template <typename IT>
  DVARange<IT> MakeRange(IT first, IT last) const {
    return DVARange<IT>(first, last);
  }

  struct DVAItem {
    T value;
    int64 key;
    int idx;
  };

  struct DVAIteratorBase {
    using reference = DVAItem;
    using value_type = DVAItem;
    const std::vector<int64>& keys;
    const std::vector<T>& values;
    int idx;
    const int key_size;

    DVAIteratorBase(const std::vector<int64>& keys,
                    const std::vector<T>& values, int idx, int key_size)
        : keys(keys), values(values), idx(idx), key_size(key_size) {}

    DVAItem operator*() { return DVAItem{values[idx], keys[idx], idx}; }

    int operator==(const DVAIteratorBase& o) const {
      return idx == o.idx && key_size == o.key_size;
    }

    int operator!=(const DVAIteratorBase& o) const {
      return !(this->operator==(o));
    }
  };

  struct DVAIterator : public DVAIteratorBase {
    using reference = DVAItem;
    using value_type = DVAItem;
    using DVAIteratorBase::DVAIteratorBase;

    DVAIterator& operator++() {
      ++DVAIteratorBase::idx;
      return *this;
    }

    DVAIterator operator++(int) {
      return DVAIterator(DVAIteratorBase::keys, DVAIteratorBase::values,
                         DVAIteratorBase::idx++, DVAIteratorBase::key_size);
    }

    DVAIterator& operator--() {
      --DVAIteratorBase::idx;
      return *this;
    }

    DVAIterator operator--(int) {
      return DVAIterator(DVAIteratorBase::keys, DVAIteratorBase::values,
                         DVAIteratorBase::idx--, DVAIteratorBase::key_size);
    }
  };

  struct DVARIterator : public DVAIteratorBase {
    using reference = DVAItem;
    using value_type = DVAItem;
    using DVAIteratorBase::DVAIteratorBase;

    DVARIterator& operator++() {
      --DVAIteratorBase::idx;
      return *this;
    }

    DVARIterator operator++(int) {
      return DVARIterator(DVAIteratorBase::keys, DVAIteratorBase::values,
                          DVAIteratorBase::idx--, DVAIteratorBase::key_size);
    }

    DVARIterator& operator--() {
      ++DVAIteratorBase::idx;
      return *this;
    }

    DVARIterator operator--(int) {
      return DVARIterator(DVAIteratorBase::keys, DVAIteratorBase::values,
                          DVAIteratorBase::idx++, DVAIteratorBase::key_size);
    }
  };

 public:
  int64 n;
  int64 m;
  int is_perfect_square;

  std::vector<int64> keys;
  std::vector<T> values;
  int64 key_size;

  DVA(int64 n = 1, T element = 0)
      : n(n), m(SqrtI(n)), is_perfect_square(m * m == n) {
    keys.push_back(0);

    for (int64 i = 1; i <= m; ++i) {
      keys.push_back(i);
    }
    for (int64 i = n / m > m ? m : m - 1; i >= 1; --i) {
      keys.push_back(n / i);
    }
    key_size = static_cast<int64>(keys.size());
    values.resize(keys.size());
    Fill(element);
  }

  DVA(const DVA& other) = default;
  DVA(DVA&& other) noexcept = default;
  DVA& operator=(const DVA& other) = default;
  DVA& operator=(DVA&& other) noexcept = default;

  void Resize(int64 n, T element = 0) { *this = std::move(DVA<T>(n, element)); }

  void Fill(T element) { std::fill(values.begin(), values.end(), element); }

  int IdxOfValue(int64 v) const {
    return static_cast<int>(v <= m ? v : key_size - n / v);
  }

  T& operator[](int64 v) { return values[IdxOfValue(v)]; }

  T operator[](int64 v) const { return values[IdxOfValue(v)]; }

  DVARange<std::vector<int64>::const_iterator> FKeys() const {
    return MakeRange(keys.begin() + 1, keys.end());
  }

  DVARange<std::vector<int64>::const_reverse_iterator> BKeys() const {
    return MakeRange(keys.rbegin(), keys.rend() - 1);
  }

  DVARange<DVAIterator> FItems() const { return MakeRange(begin(), end()); }

  DVARange<DVARIterator> BItems() const { return MakeRange(rbegin(), rend()); }

  DVAIterator begin() const { return DVAIterator(keys, values, 1, key_size); }

  DVAIterator end() const {
    return DVAIterator(keys, values, key_size, key_size);
  }

  DVARIterator rbegin() const {
    return DVARIterator(keys, values, key_size - 1, key_size);
  }

  DVARIterator rend() const { return DVARIterator(keys, values, 0, key_size); }
};

struct DVAShape {
 public:
  DVAShape(int64 n)
      : n(n),
        m(SqrtI(n)),
        is_perfect_square(m * m == n),
        key_size(m + 1 + (n / m > m ? m : m - 1)) {}
  int IdxOfValue(int64 v) const {
    return static_cast<int>(v <= m ? v : key_size - n / v);
  }

 public:
  int64 n;
  int64 m;
  int64 is_perfect_square;
  int64 key_size;
};

namespace internal {
template <typename T>
SL REQUIRES((IsNModNumberV<T>)) RETURN(std::vector<T>)
    DVAConvGreaterThanSqrtN(DVAShape shape, const std::vector<T>& psa,
                            const std::vector<T>& psb,
                            const std::vector<T>& a) {
  // a < sqrt(n), b > sqrt(n)
  std::vector<T> result(shape.key_size, T(0));
  // minimal value greater than or equal to sqrt(n).
  const int64 max_no_more_than_sqrt_n = shape.m - shape.is_perfect_square;
  for (int64 i = 1; i <= max_no_more_than_sqrt_n; ++i) {
    const int64 maxk = max_no_more_than_sqrt_n / i;
    for (int64 k = 1; k <= maxk; ++k) {
      const int64 mint = i * k;
      const int64 maxt = i * (k + 1);
      // [mint, maxt)
      const int64 u =
          std::max<int64>(shape.IdxOfValue(shape.n / maxt), shape.m);
      const int64 v = shape.IdxOfValue(shape.n / mint);
      if (v > u) {
        int64 idx = shape.IdxOfValue(shape.n / k);
        result[idx] += (psb[v] - psb[u]) * a[i];
      }
    }
  }
  return result;
}

template <typename T>
SL REQUIRES((!IsNModNumberV<T>)) RETURN(std::vector<T>)
    DVAConvGreaterThanSqrtN(DVAShape shape, const std::vector<T>& psa,
                            const std::vector<T>& psb, const std::vector<T>& a,
                            int64 mod) {
  // a < sqrt(n), b > sqrt(n)
  std::vector<T> result(shape.key_size, T(0));
  // minimal value greater than or equal to sqrt(n).
  const int64 max_no_more_than_sqrt_n = shape.m - shape.is_perfect_square;
  for (int64 i = 1; i <= max_no_more_than_sqrt_n; ++i) {
    const int64 maxk = max_no_more_than_sqrt_n / i;
    for (int64 k = 1; k <= maxk; ++k) {
      const int64 mint = i * k;
      const int64 maxt = i * (k + 1);
      // [mint, maxt)
      const int64 u =
          std::max<int64>(shape.IdxOfValue(shape.n / maxt), shape.m);
      const int64 v = shape.IdxOfValue(shape.n / mint);
      if (v > u) {
        int64 idx = shape.IdxOfValue(shape.n / k);
        result[idx] = AddMod(
            result[idx], MulMod(SubMod(psb[v], psb[u], mod), a[i], mod), mod);
      }
    }
  }
  return result;
}

SL void DVAConvDfsTwoFactorsTwo(int max_idx, int64 maxv, int64 n,
                                std::vector<std::pair<int64, int>>& f,
                                int64 value1, int64 value2,
                                std::vector<std::pair<int64, int64>>& result) {
  if (n / (n / value2) != value2) return;
  result.push_back({value1, value2});
  for (int i = 0; i < max_idx; ++i) {
    const int64 t = maxv / f[i].first;
    int64 tvalue2 = value2;
    for (int j = 1; j <= f[i].second; ++j) {
      if (tvalue2 > t) {
        break;
      }
      tvalue2 *= f[i].first;
      DVAConvDfsTwoFactorsTwo(i, maxv, n, f, value1, tvalue2, result);
    }
  }
}

SL void DVAConvDfsTwoFactorsOne(int max_idx, int64 maxv, int64 n,
                                std::vector<std::pair<int64, int>>& f,
                                int64 value1,
                                std::vector<std::pair<int64, int64>>& result) {
  if (n / (n / value1) != value1) return;
  DVAConvDfsTwoFactorsTwo(static_cast<int>(f.size()), maxv, n, f, value1, 1,
                          result);
  for (int i = 0; i < max_idx; ++i) {
    const int64 t = maxv / f[i].first;
    int64 tvalue1 = value1;
    const int total = f[i].second;
    for (int j = 1; j <= total; ++j) {
      if (tvalue1 > t) {
        break;
      }
      tvalue1 *= f[i].first;
      --f[i].second;
      DVAConvDfsTwoFactorsOne(i, maxv, n, f, tvalue1, result);
    }
    f[i].second = total;
  }
}

#define DVA_CONV_DFS_FACTORS 1

template <typename T, int TN = 8>
SL REQUIRES((IsNModNumberV<T>)) RETURN(void)
    DVAConvAdjust(DVAShape shape, int64 W, const std::vector<T>& a,
                  const std::vector<T>& b, std::vector<T>& tans,
                  std::vector<T>& result) {
  const int64 S = shape.m;
  auto _ = Sieve(W, shape.n);
  auto sieve = std::move(_.first);
  auto factorization = std::move(_.second);
#if ENABLE_OPENMP
  const int64 FINAL_TN = TN;
#else
  const int64 FINAL_TN = 1;
#endif
  if (FINAL_TN == 1) {
    for (int64 i = W; i <= shape.n; ++i) {
#if DVA_CONV_DFS_FACTORS
      std::vector<std::pair<int64, int64>> factors;
      DVAConvDfsTwoFactorsOne(factorization[i - W].size(), shape.m, shape.n,
                              factorization[i - W], 1, factors);
      for (const auto [x, y] : factors) {
        const int64 t = i / (x * y);
        if (shape.n / (shape.n / t) != t) continue;
        const int64 k0 = std::ceil(S * std::log(x));
        const int64 k1 = std::ceil(S * std::log(y));
        if (k0 + k1 > S * std::log(shape.n / t)) {
          const T tmp = a[shape.IdxOfValue(x)] * b[shape.IdxOfValue(y)];
          tans[k0 + k1] -= tmp;
          const int64 idx = shape.IdxOfValue(shape.n / t);
          result[idx] += tmp;
        }
      }
#else
      auto factors =
          GetFactors(FactorizedInteger(i, factorization[i - W]), shape.m);
      for (const int64 x : factors) {
        if (shape.n / (shape.n / x) != x) continue;
        const int64 have = i / x;
        for (const int64 y : factors) {
          if (have % y) continue;
          if (shape.n / (shape.n / y) != y) continue;
          const int64 t = have / y;
          if (shape.n / (shape.n / t) != t) continue;
          const int64 k0 = std::ceil(S * std::log(x));
          const int64 k1 = std::ceil(S * std::log(y));
          if (k0 + k1 > S * std::log(shape.n / t)) {
            T tmp = a[shape.IdxOfValue(x)] * b[shape.IdxOfValue(y)];
            tans[k0 + k1] -= tmp;
            const int64 idx = shape.IdxOfValue(shape.n / t);
            result[idx] += tmp;
          }
        }
      }
#endif
    }
  } else {
    std::vector<std::vector<T>> tans_data(FINAL_TN,
                                          std::vector<T>(tans.size(), T(0)));
    std::vector<std::vector<T>> result_data(
        FINAL_TN, std::vector<T>(result.size(), T(0)));
#if ENABLE_OPENMP
#pragma omp parallel for schedule(dynamic, 1000) num_threads(FINAL_TN)
    for (int64 i = W; i <= shape.n; ++i) {
#if DVA_CONV_DFS_FACTORS
      std::vector<std::pair<int64, int64>> factors;
      DVAConvDfsTwoFactorsOne(factorization[i - W].size(), shape.m, shape.n,
                              factorization[i - W], 1, factors);
      for (const auto [x, y] : factors) {
        const int64 t = i / (x * y);
        if (shape.n / (shape.n / t) != t) continue;
        const int64 k0 = std::ceil(S * std::log(x));
        const int64 k1 = std::ceil(S * std::log(y));
        if (k0 + k1 > S * std::log(shape.n / t)) {
          const T tmp = a[shape.IdxOfValue(x)] * b[shape.IdxOfValue(y)];
          tans_data[tid()][k0 + k1] += tmp;
          const int64 idx = shape.IdxOfValue(shape.n / t);
          result_data[tid()][idx] += tmp;
        }
      }
#else
      auto factors =
          GetFactors(FactorizedInteger(i, factorization[i - W]), shape.m);
      for (const int64 x : factors) {
        if (shape.n / (shape.n / x) != x) continue;
        const int64 have = i / x;
        for (const int64 y : factors) {
          if (have % y) continue;
          if (shape.n / (shape.n / y) != y) continue;
          const int64 t = have / y;
          if (shape.n / (shape.n / t) != t) continue;
          const int64 k0 = std::ceil(S * std::log(x));
          const int64 k1 = std::ceil(S * std::log(y));
          if (k0 + k1 > S * std::log(shape.n / t)) {
            T tmp = a[shape.IdxOfValue(x)] * b[shape.IdxOfValue(y)];
            tans_data[tid()][k0 + k1] += tmp;
            const int64 idx = shape.IdxOfValue(shape.n / t);
            result_data[tid()][idx] += tmp;
          }
        }
      }
#endif
    }
    for (int i = 0; i < FINAL_TN; ++i) {
      for (int j = 0; j < tans.size(); ++j) {
        tans[j] -= tans_data[i][j];
      }
      for (int j = 0; j < result.size(); ++j) {
        result[j] += result_data[i][j];
      }
    }
#endif
  }
}

template <typename T>
SL REQUIRES((IsNModNumberV<T>)) RETURN(std::vector<T>)
    DVAConvNoMoreThanSqrtN(DVAShape shape, const std::vector<T>& a,
                           const std::vector<T>& b) {
  // a <= sqrt(n), b <= sqrt(n)

  const int64 S = shape.m;
  const int64 W = std::max<int64>(int64(shape.n * std::exp(-2. / S) - 10), 1);

  std::vector<T> tans;
  {
    const int64 size = std::ceil(S * std::log(shape.m));
    std::vector<int64> u(size + 1, 0), v(size + 1, 0);
    for (int i = 1; i <= shape.m; ++i) {
      const int64 idx = std::ceil(S * std::log(i));
      u[idx] = a[i].value();
      v[idx] = b[i].value();
    }
    std::vector<int64> t = PolyMul(u, v, T().Mod());
    tans.reserve(t.size());
    for (int i = 0; i < t.size(); ++i) {
      tans.push_back(t[i]);
    }
  }

  std::vector<T> result(shape.key_size, T(0));
  DVAConvAdjust(shape, W, a, b, tans, result);

  for (int i = 0; i < tans.size(); ++i) {
    int64 now = std::exp(1. * i / S);
    if (now <= shape.n) {
      result[shape.IdxOfValue(now)] += tans[i];
    } else {
      break;
    }
  }

  return result;
}

template <typename T, int TN = 8>
SL REQUIRES((!IsNModNumberV<T>)) RETURN(void)
    DVAConvAdjust(DVAShape shape, int64 W, const std::vector<T>& a,
                  const std::vector<T>& b, std::vector<T>& tans,
                  std::vector<T>& result, int64 mod) {
  const int64 S = shape.m;
  auto _ = Sieve(W, shape.n);
  auto sieve = std::move(_.first);
  auto factorization = std::move(_.second);
#if ENABLE_OPENMP
  const int64 FINAL_TN = TN;
#else
  const int64 FINAL_TN = 1;
#endif
  if (FINAL_TN == 1) {
    for (int64 i = W; i <= shape.n; ++i) {
#if DVA_CONV_DFS_FACTORS
      std::vector<std::pair<int64, int64>> factors;
      DVAConvDfsTwoFactorsOne(factorization[i - W].size(), shape.m, shape.n,
                              factorization[i - W], 1, factors);
      for (const auto [x, y] : factors) {
        const int64 t = i / (x * y);
        if (shape.n / (shape.n / t) != t) continue;
        const int64 k0 = std::ceil(S * std::log(x));
        const int64 k1 = std::ceil(S * std::log(y));
        if (k0 + k1 > S * std::log(shape.n / t)) {
          const T tmp =
              MulMod(a[shape.IdxOfValue(x)], b[shape.IdxOfValue(y)], mod);
          tans[k0 + k1] = SubMod(tans[k0 + k1], tmp, mod);
          const int64 idx = shape.IdxOfValue(shape.n / t);
          result[idx] = AddMod(result[idx], tmp, mod);
        }
      }
#else
      auto factors =
          GetFactors(FactorizedInteger(i, factorization[i - W]), shape.m);
      for (const int64 x : factors) {
        if (shape.n / (shape.n / x) != x) continue;
        const int64 have = i / x;
        for (const int64 y : factors) {
          if (have % y) continue;
          if (shape.n / (shape.n / y) != y) continue;
          const int64 t = have / y;
          if (shape.n / (shape.n / t) != t) continue;
          const int64 k0 = std::ceil(S * std::log(x));
          const int64 k1 = std::ceil(S * std::log(y));
          if (k0 + k1 > S * std::log(shape.n / t)) {
            T tmp = MulMod(a[shape.IdxOfValue(x)], b[shape.IdxOfValue(y)], mod);
            tans[k0 + k1] = SubMod(tans[k0 + k1], tmp, mod);
            const int64 idx = shape.IdxOfValue(shape.n / t);
            result[idx] = AddMod(result[idx], tmp, mod);
          }
        }
      }
#endif
    }
  } else {
    std::vector<std::vector<T>> tans_data(FINAL_TN,
                                          std::vector<T>(tans.size(), T(0)));
    std::vector<std::vector<T>> result_data(
        FINAL_TN, std::vector<T>(result.size(), T(0)));
#if ENABLE_OPENMP
#pragma omp parallel for schedule(dynamic, 1000) num_threads(FINAL_TN)
    for (int64 i = W; i <= shape.n; ++i) {
#if DVA_CONV_DFS_FACTORS
      std::vector<std::pair<int64, int64>> factors;
      DVAConvDfsTwoFactorsOne(factorization[i - W].size(), shape.m, shape.n,
                              factorization[i - W], 1, factors);
      for (const auto [x, y] : factors) {
        const int64 t = i / (x * y);
        if (shape.n / (shape.n / t) != t) continue;
        const int64 k0 = std::ceil(S * std::log(x));
        const int64 k1 = std::ceil(S * std::log(y));
        if (k0 + k1 > S * std::log(shape.n / t)) {
          const T tmp =
              MulMod(a[shape.IdxOfValue(x)], b[shape.IdxOfValue(y)], mod);
          tans_data[tid()][k0 + k1] =
              AddMod(tans_data[tid()][k0 + k1], tmp, mod);
          const int64 idx = shape.IdxOfValue(shape.n / t);
          result_data[tid()][idx] = AddMod(result_data[tid()][idx], tmp, mod);
        }
      }
#else
      auto factors =
          GetFactors(FactorizedInteger(i, factorization[i - W]), shape.m);
      for (const int64 x : factors) {
        if (shape.n / (shape.n / x) != x) continue;
        const int64 have = i / x;
        for (const int64 y : factors) {
          if (have % y) continue;
          if (shape.n / (shape.n / y) != y) continue;
          const int64 t = have / y;
          if (shape.n / (shape.n / t) != t) continue;
          const int64 k0 = std::ceil(S * std::log(x));
          const int64 k1 = std::ceil(S * std::(y));
          if (k0 + k1 > S * log(shape.n / t)) {
            T tmp = MulMod(a[shape.IdxOfValue(x)], b[shape.IdxOfValue(y)], mod);
            tans_data[tid()][k0 + k1] =
                AddMod(tans_data[tid()][k0 + k1], tmp, mod);
            const int64 idx = shape.IdxOfValue(shape.n / t);
            result_data[tid()][idx] = AddMod(result_data[tid()][idx], tmp, mod);
          }
        }
      }
#endif
    }
    for (int i = 0; i < FINAL_TN; ++i) {
      for (int j = 0; j < tans.size(); ++j) {
        tans[j] = SubMod(tans[j], tans_data[i][j], mod);
      }
      for (int j = 0; j < result.size(); ++j) {
        result[j] = AddMod(result[j], result_data[i][j], mod);
      }
    }
#endif
  }
}

template <typename T>
SL REQUIRES((!IsNModNumberV<T>)) RETURN(std::vector<T>)
    DVAConvNoMoreThanSqrtN(DVAShape shape, const std::vector<T>& a,
                           const std::vector<T>& b, int64 mod) {
  // a <= sqrt(n), b <= sqrt(n)

  const int64 S = shape.m;
  const int64 W = std::max<int64>(int64(shape.n * std::exp(-2. / S) - 10), 1);

  std::vector<T> tans;
  {
    const int64 size = std::ceil(S * std::log(shape.m));
    std::vector<int64> u(size + 1, 0), v(size + 1, 0);
    for (int i = 1; i <= shape.m; ++i) {
      const int64 idx = std::ceil(S * std::log(i));
      u[idx] = a[i];
      v[idx] = b[i];
    }
    std::vector<int64> t = PolyMul(u, v, mod);
    tans.reserve(t.size());
    for (int i = 0; i < t.size(); ++i) {
      tans.push_back(t[i]);
    }
  }

  std::vector<T> result(shape.key_size, T(0));
  DVAConvAdjust(shape, W, a, b, tans, result, mod);

  for (int i = 0; i < tans.size(); ++i) {
    int64 now = std::exp(1. * i / S);
    if (now <= shape.n) {
      int64 idx = shape.IdxOfValue(now);
      result[idx] = AddMod(result[idx], tans[i], mod);
    } else {
      break;
    }
  }

  return result;
}
}  // namespace internal

// Note that it is required that n <= 3e13.
template <typename T>
SL REQUIRES((IsNModNumberV<T>)) RETURN(DVA<T>)
    DVAConv(const DVA<T>& psa, const DVA<T>& psb) {
  const DVAShape shape(psa.n);

  std::vector<T> a(shape.key_size);
  std::vector<T> b(shape.key_size);
  a[0] = b[0] = T(0);
  for (int i = 1; i < shape.key_size; ++i) {
    a[i] = psa.values[i] - psa.values[i - 1];
    b[i] = psb.values[i] - psb.values[i - 1];
  }

  DVA<T> result(shape.n);
  auto add_to = [=](const std::vector<T>& src, std::vector<T>& target) {
    for (int i = 0; i < shape.key_size; ++i) {
      target[i] += src[i];
    }
  };

  add_to(internal::DVAConvGreaterThanSqrtN(shape, psa.values, psb.values, a),
         result.values);
  add_to(internal::DVAConvGreaterThanSqrtN(shape, psb.values, psa.values, b),
         result.values);
  add_to(internal::DVAConvNoMoreThanSqrtN(shape, a, b), result.values);

  for (int i = 1; i < shape.key_size; ++i) {
    result.values[i] += result.values[i - 1];
  }
  return result;
}

// Note that it is required that n <= 3e13.
template <typename T>
SL REQUIRES((IsNModNumberV<T>)) RETURN(DVA<T>)
    DVAConv(const DVA<T>& psa, const DVA<T>& psb, int64 mod) {
  PE_ASSERT(T().Mod() == mod);
  return DVAConv(psa, psb);
}

// Note that it is required that n <= 3e13.
template <typename T>
SL REQUIRES((!IsNModNumberV<T>)) RETURN(DVA<T>)
    DVAConv(const DVA<T>& psa, const DVA<T>& psb, int64 mod) {
  const DVAShape shape(psa.n);

  std::vector<T> a(shape.key_size);
  std::vector<T> b(shape.key_size);
  a[0] = b[0] = T(0);
  for (int i = 1; i < shape.key_size; ++i) {
    a[i] = SubMod(psa.values[i], psa.values[i - 1], mod);
    b[i] = SubMod(psb.values[i], psb.values[i - 1], mod);
  }

  DVA<T> result(shape.n);
  auto add_to = [=](const std::vector<T>& src, std::vector<T>& target) {
    for (int i = 0; i < shape.key_size; ++i) {
      target[i] = AddMod(target[i], src[i], mod);
    }
  };

  add_to(
      internal::DVAConvGreaterThanSqrtN(shape, psa.values, psb.values, a, mod),
      result.values);
  add_to(
      internal::DVAConvGreaterThanSqrtN(shape, psb.values, psa.values, b, mod),
      result.values);
  add_to(internal::DVAConvNoMoreThanSqrtN(shape, a, b, mod), result.values);

  for (int i = 1; i < shape.key_size; ++i) {
    result.values[i] = AddMod(result.values[i], result.values[i - 1], mod);
  }
  return result;
}

// Calculates sum(1, 1 <= prime i <= j) for j in [1, 2, 3, ..., n/3, n/2, n].
template <typename T>
SL DVA<T> PrimeS0(const int64 n) {
  PE_ASSERT(n >= 1);
  DVA<T> dva(n);

  for (auto& key : dva.FKeys()) dva[key] = key - 1;

  for (int64 p = 2; p <= dva.m; ++p) {
    if (dva[p] != dva[p - 1]) {
      const auto pcnt = dva[p - 1];
      const int64 p2 = p * p;
      for (auto& key : dva.BKeys()) {
        if (key < p2) break;
        dva[key] -= dva[key / p] - pcnt;
      }
    }
  }
  return dva;
}

// Calculates sum(1, 1 <= prime i <= j) for j in [1, 2, 3, ..., n/3, n/2, n] in
// parallel.
template <typename T, int TN = 8>
SL DVA<T> PrimeS0Parallel(const int64 n) {
  PE_ASSERT(n >= 1);
  DVA<T> dva(n);

  const int64 ks = dva.key_size;
  auto* keys = &dva.keys[0];
  auto* values = &dva.values[0];
  std::vector<T> tmpdata(ks);
  auto* tmp = &tmpdata[0];

  for (auto& key : dva.FKeys()) dva[key] = key - 1;

  int idx = 0;
  for (int64 p = 2; p <= dva.m; ++p) {
    if (dva[p] != dva[p - 1]) {
      const auto pcnt = dva[p - 1];
      const int64 p2 = p * p;
      while (idx + 1 < ks && keys[idx + 1] < p2) ++idx;
#if ENABLE_OPENMP
      if (ks - idx > 400000) {
#pragma omp parallel for schedule(dynamic, 100000) num_threads(TN)
        for (int j = idx + 1; j < ks; ++j) {
          const int64 v = keys[j] / p;
          tmp[j] = values[j] - values[v <= dva.m ? v : ks - n / v] + pcnt;
        }
#pragma omp parallel for schedule(dynamic, 100000) num_threads(TN)
        for (int j = idx + 1; j < ks; ++j) {
          values[j] = tmp[j];
        }
      } else {
#endif
        for (int j = static_cast<int>(ks - 1); j > idx; --j) {
          const int64 v = keys[j] / p;
          values[j] -= values[v <= dva.m ? v : ks - n / v] - pcnt;
        }
#if ENABLE_OPENMP
      }
#endif
    }
  }
  return dva;
}

#define PrimePi PrimeS0

// Calculates sum(i, 1 <= prime i <= j) for j in [1, 2, 3, ..., n/3, n/2, n].
template <typename T>
SL DVA<T> PrimeS1(const int64 n) {
  PE_ASSERT(n >= 1);
  DVA<T> dva(n);
  for (auto& key : dva.FKeys()) {
    if (key & 1) {
      T v((key + 1) >> 1);
      dva[key] = v * key - 1;
    } else {
      T v(key >> 1);
      dva[key] = v * (key + 1) - 1;
    }
  }

  for (int64 p = 2; p <= dva.m; ++p) {
    if (dva[p] != dva[p - 1]) {
      const auto psum = dva[p - 1];
      const int64 p2 = p * p;
      for (auto& key : dva.BKeys()) {
        if (key < p2) break;
        dva[key] -= (dva[key / p] - psum) * p;
      }
    }
  }
  return dva;
}

// Calculates sum(i, 1 <= prime i <= j) for j in [1, 2, 3, ..., n/3, n/2, n] in
// parallel.
template <typename T, int TN = 8>
SL DVA<T> PrimeS1Parallel(const int64 n) {
  PE_ASSERT(n >= 1);
  DVA<T> dva(n);

  const int64 ks = dva.key_size;
  auto* keys = &dva.keys[0];
  auto* values = &dva.values[0];
  std::vector<T> tmpdata(ks);
  auto* tmp = &tmpdata[0];

  for (auto& key : dva.FKeys()) {
    if (key & 1) {
      T v((key + 1) >> 1);
      dva[key] = v * key - 1;
    } else {
      T v(key >> 1);
      dva[key] = v * (key + 1) - 1;
    }
  }

  int idx = 0;
  for (int64 p = 2; p <= dva.m; ++p) {
    if (dva[p] != dva[p - 1]) {
      const auto psum = dva[p - 1];
      const int64 p2 = p * p;
      while (idx + 1 < ks && keys[idx + 1] < p2) ++idx;
#if ENABLE_OPENMP
      if (ks - idx > 400000) {
#pragma omp parallel for schedule(dynamic, 100000) num_threads(TN)
        for (int j = idx + 1; j < ks; ++j) {
          const int64 v = keys[j] / p;
          tmp[j] = values[j] - (values[v <= dva.m ? v : ks - n / v] - psum) * p;
        }
#pragma omp parallel for schedule(dynamic, 100000) num_threads(TN)
        for (int j = idx + 1; j < ks; ++j) {
          values[j] = tmp[j];
        }
      } else {
#endif
        for (int j = static_cast<int>(ks - 1); j > idx; --j) {
          const int64 v = keys[j] / p;
          values[j] -= (values[v <= dva.m ? v : ks - n / v] - psum) * p;
        }
#if ENABLE_OPENMP
      }
#endif
    }
  }
  return dva;
}

#define PrimeSum PrimeS1

// Calculates sum(1, 1 <= prime i <= j) for j in [1, 2, 3, ..., n/3, n/2, n].
template <typename T>
SL DVA<T> PrimeS0Ex(const int64 n) {
  PE_ASSERT(n >= 1);
  DVA<T> dva(n);

  const int key_size = static_cast<int>(dva.key_size);
  RUBit<T> tree(key_size);

  for (auto& key : dva.FKeys()) {
    const int id = dva.IdxOfValue(key);
    tree.Update(id, id, key - 1);
  }

  for (int64 p = 2; p <= dva.m; ++p) {
    if (IsPrime(p)) {
      const auto pcnt = tree.Query(static_cast<int>(p - 1));
      const int64 p2 = p * p;
      const int a = key_size - 1;
      const int b = dva.IdxOfValue(p2);
      for (int i = a; i >= b;) {
        const auto delta = tree.Query(dva.IdxOfValue(dva.keys[i] / p)) - pcnt;
        const int mini = std::max(dva.IdxOfValue(dva.keys[i] / p * p), b);
        tree.Update(mini, i, -delta);
        i = mini - 1;
      }
    }
  }
  for (int i = 1; i < key_size; ++i) dva[dva.keys[i]] = tree.Query(i);
  return dva;
}

// Calculates sum(i, 1 <= prime i <= j) for j in [1, 2, 3, ..., n/3, n/2, n].
template <typename T>
SL DVA<T> PrimeS1Ex(const int64 n) {
  PE_ASSERT(n >= 1);
  DVA<T> dva(n);

  const int key_size = static_cast<int>(dva.key_size);
  RUBit<T> tree(key_size);

  for (auto& key : dva.FKeys()) {
    const int id = dva.IdxOfValue(key);

    if (key & 1) {
      T v((key + 1) >> 1);
      tree.Update(id, id, v * key - 1);
    } else {
      T v(key >> 1);
      tree.Update(id, id, v * (key + 1) - 1);
    }
  }

  for (int64 p = 2; p <= dva.m; ++p) {
    if (IsPrime(p)) {
      const auto psum = tree.Query(static_cast<int>(p - 1));
      const int64 p2 = p * p;
      const int a = key_size - 1;
      const int b = dva.IdxOfValue(p2);
      for (int i = a; i >= b;) {
        const auto delta = tree.Query(dva.IdxOfValue(dva.keys[i] / p)) - psum;
        const int mini = std::max(dva.IdxOfValue(dva.keys[i] / p * p), b);
        tree.Update(mini, i, -delta * p);
        i = mini - 1;
      }
    }
  }

  for (int i = 1; i < key_size; ++i) dva[dva.keys[i]] = tree.Query(i);
  return dva;
}

template <typename TreeType>
SL void PrimeSkExImpl(const int64 /*n*/, int k, int64* PK, TreeType& tree,
                      DVA<int64>& dva, int64 mod) {
  const int key_size = static_cast<int>(dva.key_size);
  int pid = 0;
  for (int64 p = 2; p <= dva.m; ++p) {
    if (IsPrime(p)) {
      const int64 pk = PK ? PK[pid] : PowerMod(p, k, mod);
      const auto psum = tree.Query(static_cast<int>(p - 1)).value();
      const int64 p2 = p * p;
      const int a = key_size - 1;
      const int b = dva.IdxOfValue(p2);
      for (int i = a; i >= b;) {
        const auto delta = SubMod(
            tree.Query(dva.IdxOfValue(dva.keys[i] / p)).value(), psum, mod);
        const int mini = std::max(dva.IdxOfValue(dva.keys[i] / p * p), b);
        tree.Update(mini, i, SubMod(0, MulMod(delta, pk, mod), mod));
        i = mini - 1;
      }
      ++pid;
    }
  }

  for (int i = 1; i < key_size; ++i) dva[dva.keys[i]] = tree.Query(i).value();
}

// Calculates sum(i^k, 1 <= prime i <= j) for j in [1, 2, 3, ..., n/3, n/2, n].
// PK[x] is the kth power of the xth prime (0 based).
SL DVA<int64> PrimeSkEx(const int64 n, int k, int64* PK, int64 mod) {
  PowerSumModerB psm(mod);

  PE_ASSERT(DefaultMod::Mod() != 1);
  PE_ASSERT(n >= 1);
  DVA<int64> dva(n);

  const int key_size = static_cast<int>(dva.key_size);
  RUBit<NModNumber<DefaultMod>> tree(key_size);

  for (auto& key : dva.FKeys()) {
    const int id = dva.IdxOfValue(key);
    const int64 val = SubMod(psm.Cal(key, k), 1, mod);
    tree.Update(id, id, val);
  }

  PrimeSkExImpl(n, k, PK, tree, dva, mod);

  return dva;
}

// Calculates sum(i^k, 1 <= prime i <= j) for j in [1, 2, 3, ..., n/3, n/2, n].
// PK[x] is the kth power of the xth prime (0 based).
template <int64 mod>
SL DVA<int64> PrimeSkEx(const int64 n, int k, int64* PK = nullptr) {
  PowerSumModerB psm(mod);

  PE_ASSERT(n >= 1);
  DVA<int64> dva(n);

  const int key_size = static_cast<int>(dva.key_size);
  RUBit<NModNumber<CCMod64<mod>>> tree(key_size);

  for (auto& key : dva.FKeys()) {
    const int id = dva.IdxOfValue(key);
    const int64 val = SubMod(psm.Cal(key, k), 1, mod);
    tree.Update(id, id, val);
  }

  PrimeSkExImpl(n, k, PK, tree, dva, mod);

  return dva;
}

template <typename T>
SL std::vector<DVA<T>> PrimeS0PModEven(int64 n, int pmod) {
  std::vector<DVA<T>> result;
  result.reserve(pmod);
  for (int i = 0; i < pmod; ++i) result.emplace_back(n);

  for (int i = 1; i < pmod; i += 2) {
    auto& target = result[i];
    const int dec = i == 1;
    for (auto key : result[0].FKeys()) {
      target[key] = (key + pmod - i) / pmod - dec;
    }
  }
  for (int i = 1;; ++i) {
    const int64 p = plist[i];
    const int64 p2 = p * p;
    if (p2 > n) break;
    for (auto key : result[0].BKeys()) {
      if (key < p2) break;
      const int rp = p % pmod;
      for (int j = 1; j < pmod; j += 2) {
        const int next = rp * j % pmod;
        result[next][key] -= result[j][key / p] - result[j][p - 1];
      }
    }
  }

  auto& target = result[2 % pmod];
  for (auto key : result[0].FKeys()) {
    target[key] += key >= 2 ? 1 : 0;
  }
  return result;
}

template <typename T>
SL std::vector<DVA<T>> PrimeS0PModOdd(int64 n, int pmod) {
  std::vector<DVA<T>> result;
  result.reserve(pmod);
  for (int i = 0; i < pmod; ++i) result.emplace_back(n);

  for (int i = 0; i < pmod; ++i) {
    const int dec = (i == 1 % pmod) + (i == 0);
    for (auto key : result[0].FKeys()) {
      result[i][key] = (key + pmod - i) / pmod - dec;
    }
  }
  for (int i = 0;; ++i) {
    const int64 p = plist[i];
    const int64 p2 = p * p;
    if (p2 > n) break;
    for (auto key : result[0].BKeys()) {
      if (key < p2) break;
      const int rp = p % pmod;
      for (int j = 0; j < pmod; ++j) {
        const int next = rp * j % pmod;
        result[next][key] -= result[j][key / p] - result[j][p - 1];
      }
    }
  }
  return result;
}

// Calculates sum(1, 1 <= prime i <= j) for j in [1, 2, 3, ..., n/3, n/2, n].
// result[x] is for the prime where p % pmod = x.
template <typename T>
SL std::vector<DVA<T>> PrimeS0PMod(int64 n, int pmod) {
  return pmod & 1 ? PrimeS0PModOdd<T>(n, pmod) : PrimeS0PModEven<T>(n, pmod);
}

template <typename T>
SL std::vector<DVA<T>> PrimeS1PmodEven(int64 n, int pmod) {
  std::vector<DVA<T>> result;
  for (int i = 0; i < pmod; ++i) result.emplace_back(n);

  for (int i = 1; i < pmod; i += 2) {
    auto& target = result[i];
    const int dec = i == 1;
    for (auto key : result[0].FKeys()) {
#if PE_HAS_INT128
      const int128 c = (key + pmod - i) / pmod;
#else
      const int64 c = (key + pmod - i) / pmod;
#endif
      target[key] = c * (c - 1) / 2 * pmod + c * i - dec;
    }
  }
  for (int i = 1;; ++i) {
    const int64 p = plist[i];
    const int64 p2 = p * p;
    if (p2 > n) break;
    for (auto key : result[0].BKeys()) {
      if (key < p2) break;
      const int rp = p % pmod;
      for (int j = 1; j < pmod; j += 2) {
        const int next = rp * j % pmod;
        result[next][key] -= (result[j][key / p] - result[j][p - 1]) * p;
      }
    }
  }

  auto& target = result[2 % pmod];
  for (auto key : result[0].FKeys()) {
    target[key] += key >= 2 ? 2 : 0;
  }
  return result;
}

template <typename T>
SL std::vector<DVA<T>> PrimeS1PModOdd(int64 n, int pmod) {
  std::vector<DVA<T>> result;
  for (int i = 0; i < pmod; ++i) result.emplace_back(n);

  for (int i = 0; i < pmod; ++i) {
    auto& target = result[i];
    const int dec = i == 1 % pmod;
    for (auto key : result[0].FKeys()) {
#if PE_HAS_INT128
      const int128 c = (key + pmod - i) / pmod;
#else
      const int64 c = (key + pmod - i) / pmod;
#endif
      target[key] = c * (c - 1) / 2 * pmod + c * i - dec;
    }
  }

  for (int i = 0;; ++i) {
    const int64 p = plist[i];
    const int64 p2 = p * p;
    if (p2 > n) break;
    for (auto key : result[0].BKeys()) {
      if (key < p2) break;
      const int rp = p % pmod;
      for (int j = 0; j < pmod; ++j) {
        const int next = rp * j % pmod;
        result[next][key] -= (result[j][key / p] - result[j][p - 1]) * p;
      }
    }
  }

  return result;
}

// Calculates sum(i, 1 <= prime i <= j) for j in [1, 2, 3, ..., n/3, n/2, n].
// result[x] is for the prime where p % pmod = x.
template <typename T>
SL std::vector<DVA<T>> PrimeS1PMod(int64 n, int pmod) {
  return pmod & 1 ? PrimeS1PModOdd<T>(n, pmod) : PrimeS1PmodEven<T>(n, pmod);
}

template <int64 mod>
SL std::vector<DVA<NModNumber<CCMod64<mod>>>> PrimeSkPMod(const int64 n, int k,
                                                          int pmod) {
  using MT = NModNumber<CCMod64<mod>>;
  std::vector<DVA<MT>> result;
  for (int i = 0; i < pmod; ++i) result.emplace_back(n);

  PowerSumModerB psm(mod);

  PE_ASSERT(n >= 1);
  DVA<int64> dva(n);

  const int key_size = static_cast<int>(dva.key_size);
  RUBit<MT> tree(key_size);

  std::vector<int64> vec;
  MT power_pmod = 1;
  // Expand (pmod * x + i) ^ k
  for (int c = 0; c <= k; ++c, power_pmod *= pmod) {
    // C(k, c) (pmod * x)^c i^(k - c)
    MT coe = 1;
    if (c > 0) {
      vec.push_back(k - c + 1);
      int64 it = c;
      const int size = static_cast<int>(vec.size());
      for (int i = 0; i < size; ++i) {
        if (it > 1 && vec[i] > 1) {
          auto t = Gcd(it, vec[i]);
          vec[i] /= t;
          it /= t;
        }
        if (vec[i] > 1) {
          coe *= vec[i];
        }
      }
    }
    for (int i = 1; i < pmod; ++i) {
      auto t = coe * power_pmod * PowerMod(i, k - c, mod);
      // psm.cal() doesn't count x == 0, i.e x^c is 0.
      // If c = 0, we need i^k, so 1 is added.
      // If c > 0, the behavior is expected.
      const int inc = c == 0;
      for (auto& key : dva.FKeys()) {
        if (key >= i) {
          result[i][key] += t * (psm.Cal((key - i) / pmod, c) + inc);
        }
      }
    }
  }
  MT y = PowerMod(pmod, k, mod);
  for (auto& key : dva.FKeys()) {
    result[0][key] += y * psm.Cal(key / pmod, k);
  }
  for (int i = 0; i < pmod; ++i) {
    if (1 % pmod == i) {
      for (auto& key : dva.FKeys()) {
        result[i][key] -= 1;
      }
      break;
    }
  }

  for (int i = 0;; ++i) {
    const int64 p = plist[i];
    const int64 p2 = p * p;
    if (p2 > n) break;
    for (auto key : result[0].BKeys()) {
      if (key < p2) break;
      const int64 coe = PowerMod(p, k, mod);
      const int rp = p % pmod;
      for (int j = 0; j < pmod; ++j) {
        const int next = rp * j % pmod;
        result[next][key] -= (result[j][key / p] - result[j][p - 1]) * coe;
      }
    }
  }

  return result;
}

// A helper class used to calculate pi(n) with cache.
struct CachedPi {
  CachedPi(int pivot_ = pe::maxp) : pivot_(pivot_) {
    if (pe::maxp > 0) {
      Init(pivot_);
    }
  }

  ~CachedPi() { Release(); }

  void Release() {
    if (prepi_ != nullptr) {
      delete[] prepi_;
      prepi_ = nullptr;
    }
  }

  void Init(int pivot) {
    Release();
    pivot_ = pivot;
    prepi_ = new int[pivot_ + 1];
    prepi_[0] = 0;
    for (int i = 1; i <= pivot_; ++i) {
      prepi_[i] = prepi_[i - 1] + IsPrime(i);
    }
  }

  int64 operator()(int64 n) { return Cal(n); }

  int64 Cal(int64 n) {
    if (n <= pivot_) return prepi_[n];
    auto where = pi_cache_.find(n);
    if (where != pi_cache_.end()) return where->second;
    return pi_cache_[n] = PrimeS0Ex<int64>(n)[n];
  }

 private:
  int* prepi_{nullptr};
  int pivot_;
  std::unordered_map<int64, int64> pi_cache_;
};

#if PE_HAS_INT128
// Counts the number in the pattern of p1^e1 p2^e2 p3^e3... no more than n.
struct PatternNumberCounter {
  PatternNumberCounter() = default;

  ~PatternNumberCounter() { Release(); }

  void Release() {
    if (is_prime_used_ != nullptr) {
      delete[] is_prime_used_;
      is_prime_used_ = nullptr;
    }
  }

  // prime_cnt: int a given pattern, we only consider the first prime_cnt
  // primes.
  // pi_pivot: use pre-computed results in an array, if m <= pi_pivot.
  void Init(int prime_cnt, int pi_pivot = 0) {
    PE_ASSERT(prime_cnt > 0);
    Release();

    prime_cnt_ = prime_cnt;
    is_prime_used_ = new char[prime_cnt];
    if (pi_pivot == 0) {
      PE_ASSERT(pe::plist != nullptr);
      pi_pivot = pe::plist[prime_cnt - 1];
    }
    cached_pi_.Init(pi_pivot);
  }

  int128 DfsPattern(const int start, const int id, const int pattern_length,
                    const vi& pattern, const int128 remain) {
    int128 ret = 0;
    if (id == pattern_length - 1) {
      const int64 t = RootI(remain, pattern[pattern_length - 1]);
      const int64 how_many = cached_pi_(t);
      const int64 idx = how_many - 1;
      if (idx < start) return 0;
      int64 have = idx - start + 1;
      for (int i = 0; i < top_; ++i) {
        if (used_prime_idx_[i] >= start && used_prime_idx_[i] <= idx) {
          --have;
        }
      }
      return have > 0 ? have : 0;
    }

    int e = pattern[id];
    for (int j = id + 1; j < pattern_length; ++j) {
      if (pattern[j] == pattern[id]) {
        e += pattern[id];
      } else {
        break;
      }
    }

    for (int i = start;; ++i) {
      if (is_prime_used_[i] == 0) {
        int128 tmp = remain;
        for (int j = 0; j < e; ++j) tmp /= plist[i];
        if (tmp == 0) break;

        is_prime_used_[i] = 1;
        used_prime_idx_[top_++] = i;
        const int128 v = Power<int128, int>(plist[i], pattern[id]);
        ret += DfsPattern(pattern[id + 1] == pattern[id] ? i + 1 : 0, id + 1,
                          pattern_length, pattern, remain / v);
        --top_;
        is_prime_used_[i] = 0;
      }
    }
    return ret;
  }

  int128 operator()(const vi& pattern, int64 k) { return Cal(pattern, k); }

  int128 Cal(vi pattern, int128 n) {
    std::sort(all(pattern));
    std::reverse(all(pattern));

    top_ = 0;
    return DfsPattern(0, 0, sz(pattern), pattern, n);
  }

  int prime_cnt_;
  int used_prime_idx_[1024];      // the index of used primes.
  char* is_prime_used_{nullptr};  // is the ith prime used
  int top_;
  CachedPi cached_pi_;
};
#endif

struct MVVHistory {
  int64 p;  // value of a prime factor.
  int ip;   // index of a prime factor.
  int e;    // exponential of a prime rfactor.
};

// Visit all values of x / (max primer factor of x) for x no more than n.
// auto compute = [&](int64 val, int imp, int64 vmp, MVVHistory* his,
//                    int top) -> int64 { return 1; };
template <typename RT = int64>
struct MValueVisitor {
  using VisitorType = std::function<RT(int64, int, int64, MVVHistory*, int)>;

  MValueVisitor(const VisitorType& visitor) : visitor_(visitor), top_(0) {}

  RT Dfs(int limit, int64 n, int64 val, int imp, int64 vmp) {
    RT ret = visitor_(val, imp, vmp, history_, top_);
    for (int i = 0; i < limit; ++i) {
      const int64 p = plist[i];
      const int next_imp = imp == -1 ? i : imp;
      const int64 next_vmp = imp == -1 ? p : vmp;
      const int64 val_limit = n / p / next_vmp;
      if (val > val_limit) break;
      history_[top_].ip = i;
      history_[top_].p = p;
      history_[top_].e = 1;
      int& e = history_[top_++].e;
      for (int64 nextval = val * p;; ++e) {
        ret += Dfs(i, n, nextval, next_imp, next_vmp);
        if (nextval > val_limit) break;
        nextval *= p;
      }
      --top_;
    }
    return ret;
  }

  RT Cal(int64 n) { return Dfs(FindPrimeIdxSg(n), n, 1, -1, 0); }

 private:
  VisitorType visitor_;
  MVVHistory history_[128];
  int top_;
};

template <typename RT>
RT ForMValues(
    int64 n,
    const std::function<RT(int64, int, int64, MVVHistory*, int)>& visitor) {
  return MValueVisitor<RT>(visitor).Cal(n);
}

template <typename D, typename RT = int64, int TN = 1,
          bool small_to_large = false>
struct MValueBaseEx;

// See example/multiplicative_function_prefix_sum.c
template <typename D, typename RT, int TN>
struct MValueBaseEx<D, RT, TN, false> {
  RT Batch(int64 n, int64 val, int imp, int64 vmp, int emp, RT now, RT now1) {
    RT ret = 0;
    int64 remain = n / val;
    // we have remain >= vmp
    // handle val * q where q > vmp
    if (remain > vmp) {
      ret += now * static_cast<D&>(*this).BatchF(imp, vmp, remain);
    }
    if (val > 1) {
      // handle val * vmp
      ret += now1 * static_cast<D&>(*this).F(vmp, emp + 1);
    } else {
      // handle f(1)
      ret += 1;
    }
    return ret;
  }

  RT Dfs(int limit, int64 n, int64 val, int imp, int64 vmp, int emp, RT now,
         RT now1) {
    RT ret = static_cast<D&>(*this).Batch(n, val, imp, vmp, emp, now, now1);
#if ENABLE_OPENMP
    if (val == 1 && TN > 1) {
      PSum<RT> sum_helper;
#pragma omp parallel for schedule(dynamic, 1) num_threads(TN)
      for (int i = 0; i < limit; ++i) {
        const int64 p = plist[i];
        const int next_imp = imp == -1 ? i : imp;
        const int64 next_vmp = imp == -1 ? p : vmp;
        const int64 val_limit = n / (p * next_vmp);
        int e = 1;
        for (int64 nextval = val * p;; ++e) {
          RT t = static_cast<D&>(*this).F(p, e);
          sum_helper +=
              Dfs(i, n, nextval, next_imp, next_vmp, imp == -1 ? e : emp,
                  now * t, imp == -1 ? 1 : now1 * t);
          if (nextval > val_limit) break;
          nextval *= p;
        }
      }
      ret += sum_helper.value();
    } else {
#endif
      for (int i = 0; i < limit; ++i) {
        const int64 p = plist[i];
        const int next_imp = imp == -1 ? i : imp;
        const int64 next_vmp = imp == -1 ? p : vmp;
        const int64 val_limit = n / (p * next_vmp);
        if (val > val_limit) break;
        int e = 1;
        for (int64 nextval = val * p;; ++e) {
          RT t = static_cast<D&>(*this).F(p, e);
          ret += Dfs(i, n, nextval, next_imp, next_vmp, imp == -1 ? e : emp,
                     now * t, imp == -1 ? 1 : now1 * t);
          if (nextval > val_limit) break;
          nextval *= p;
        }
      }
#if ENABLE_OPENMP
    }
#endif
    return ret;
  }

  RT F(int64 /*p*/, int64 /*e*/) { return 1; }
  RT BatchF(int /*imp*/, int64 /*vmp*/, int64 /*remain*/) { return 1; }
  void Init(int64 n) {}
  void Done() {}
  RT Cal(int64 n) {
    static_cast<D&>(*this).Init(n);
    RT ret = Dfs(FindPrimeIdxSg(n), n, 1, -1, 1, 0, 1, 1);
    static_cast<D&>(*this).Done();
    return ret;
  }
};

template <typename D, typename RT, int TN>
struct MValueBaseEx<D, RT, TN, true> {
  RT Batch(int64 n, int64 val, int imp, int64 vmp, int emp, RT now, RT now1) {
    RT ret = 0;
    int64 remain = n / val;
    // we have remain >= vmp
    // handle val * q where q > vmp
    if (remain > vmp) {
      ret += now * static_cast<D&>(*this).BatchF(imp, vmp, remain);
    }
    if (val > 1) {
      // handle val * vmp
      ret += now1 * static_cast<D&>(*this).F(vmp, emp + 1);
    } else {
      // handle f(1)
      ret += 1;
    }
    return ret;
  }

  RT Dfs(int start, int limit, int64 n, int64 val, int imp, int64 vmp, int emp,
         RT now, RT now1) {
    RT ret = static_cast<D&>(*this).Batch(n, val, imp, vmp, emp, now, now1);
#if ENABLE_OPENMP
    if (val == 1 && TN > 1) {
      PSum<RT> sum_helper;
#pragma omp parallel for schedule(dynamic, 1) num_threads(TN)
      for (int i = start; i < limit; ++i) {
        const int64 p = plist[i];
        const int64 val_limit = n / (p * p);
        int e = 1;
        for (int64 nextval = val * p;; ++e) {
          RT t = static_cast<D&>(*this).F(p, e);
          sum_helper += Dfs(i + 1, limit, n, nextval, i, p, e, now * t, now);
          if (nextval > val_limit) break;
          nextval *= p;
        }
      }
      ret += sum_helper.value();
    } else {
#endif
      for (int i = start; i < limit; ++i) {
        const int64 p = plist[i];
        const int64 val_limit = n / (p * p);
        if (val > val_limit) break;
        int e = 1;
        for (int64 nextval = val * p;; ++e) {
          RT t = static_cast<D&>(*this).F(p, e);
          ret += Dfs(i + 1, limit, n, nextval, i, p, e, now * t, now);
          if (nextval > val_limit) break;
          nextval *= p;
        }
      }
#if ENABLE_OPENMP
    }
#endif
    return ret;
  }

  RT F(int64 /*p*/, int64 /*e*/) { return 1; }
  RT BatchF(int /*imp*/, int64 /*vmp*/, int64 /*remain*/) { return 1; }
  void Init(int64 n) {}
  void Done() {}
  RT Cal(int64 n) {
    static_cast<D&>(*this).Init(n);
    RT ret = Dfs(0, FindPrimeIdxSg(n), n, 1, -1, 1, 0, 1, 1);
    static_cast<D&>(*this).Done();
    return ret;
  }
};

// The lite version assumes that F(p, e) is only related to e.
// In other words, F(p1, e) = F(p2, e) for two different primes p1, p2.
template <typename D, typename RT = int64, int TN = 1,
          bool small_to_large = false>
struct MValueBaseExLite : public MValueBaseEx<D, RT, TN, small_to_large> {
  RT BatchF(int imp, int64 /*vmp*/, int64 remain) {
    return static_cast<D&>(*this).F(2, 1) * RT(dva[remain] - (imp + 1));
  }
  void Init(int64 n) { dva = PrimeS0Ex<int64>(n); }
  DVA<int64> dva;
};

// Returns the number of integer solutions of
// x^2+y^2=z^2 where 0 < x < y, 0 < z <= n.
// See https://oeis.org/A101930
int64 CountPythagoreanTriple(int64 n) {
  // f(i) = 4 prod(e_i + 1, p_i%4==1) #(write i as sum of two squares)
  // s = sum(f(i^2), i=1..n)
  // return (s - 4 * n) / 8
  auto _ = PrimeS0PMod<int64>(n, 4);
  auto ps1 = _[1];
  auto ps3 = _[3];
  auto compute = [&](int64 val, int /*imp*/, int64 vmp, MVVHistory* his,
                     int top) -> int64 {
    if (val == 1) {
      return 3 * ps1[n] + ps3[n] + 2;  // 2 is for 1 and 2.
    }
    int64 ret = 0;
    int64 t = 1;
    for (int i = 0; i < top; ++i) {
      if (his[i].p % 4 == 1) t *= 2 * his[i].e + 1;
    }
    if (his[0].p % 4 == 1) {
      ret += t / (2 * his[0].e + 1) * (2 * his[0].e + 3);
    } else {
      ret += t;
    }
    ret += (ps1[n / val] - ps1[vmp]) * t * 3;
    ret += (ps3[n / val] - ps3[vmp]) * t;
    return ret;
  };

  return (ForMValues<int64>(n, compute) - n) >> 1;
}

// Returns the number of integer solutions of
// x^2+y^2=z^2 where 0 < x < y, 0 < z <= n.
// See https://oeis.org/A101930
int64 CountPythagoreanTripleEx(int64 n) {
  auto _ = PrimeS0PMod<int64>(n, 4);
  auto ps1 = std::move(_[1]);
  auto ps3 = std::move(_[3]);
  std::function<int64(int, int64, int64, int64, int, int64)> dfs =
      [&](int limit, int64 n, int64 val, int64 c, int evmp,
          int64 vmp) -> int64 {
    int64 ret = 0;
    if (val == 1) {
      ret = 3 * ps1[n] + ps3[n] + 2;  // 2 is for 1 and 2.
    } else {
      ret += (ps1[n / val] - ps1[vmp]) * c * 3;
      ret += (ps3[n / val] - ps3[vmp]) * c;
      if (vmp % 4 == 1) {
        ret += c / (2 * evmp + 1) * (2 * evmp + 3);
      } else {
        ret += c;
      }
    }
    for (int i = 0; i < limit; ++i) {
      const int64 p = plist[i];
      const int64 next_vmp = vmp == 0 ? p : vmp;
      const int64 val_limit = n / p / next_vmp;
      if (val > val_limit) break;
      int e = 1;
      int should = p % 4 == 1;
      for (int64 nextval = val * p;; ++e) {
        ret += dfs(i, n, nextval, should ? c * (2 * e + 1) : c,
                   next_vmp == p ? e : evmp, next_vmp);
        if (nextval > val_limit) break;
        nextval *= p;
      }
    }
    return ret;
  };
  return (dfs(pcnt, n, 1, 1, 0, 0) - n) >> 1;
}

// Counts the perfect power no more than n.
template <typename T>
struct PerfectPowerCounter {
  PerfectPowerCounter(int pivot = 1000000) : pivot_(pivot) { Init(); }

  ~PerfectPowerCounter() { delete[] pre_; }

  void Init() {
    PE_ASSERT(pivot_ < (1 << 20));
    pre_ = new int[pivot_][20];
    std::fill(pre_[0], pre_[0] + 20, 0);
    pre_[0][0] = 1;
    for (int i = 2; i <= pivot_; ++i) {
      int d = 0;
      for (auto& iter : Factorize(i)) d = Gcd(d, iter.second);
      for (int j = 0; j <= 19; ++j) pre_[i][j] = pre_[i - 1][j];
      pre_[i][d]++;
    }
  }

  // Use f(x) to denote Gcd of exponentions of x.
  // i.e if x = p1^e1 * p2^e2 * p3^e3, then f(x) = Gcd(e1, e2, e3).
  // f(1) = 1
  // This method returns # {x | f(x) = d, 1 <= x <= n}
  // n < 2^128, d >= 0
  T Cal(T n, int d) {
    if (n <= pivot_) {
      if (d < 20) {
        return pre_[n][d];
      } else {
        return 0;
      }
    }
    if (d == 0) return n >= 1 ? 1 : 0;
    if (d > 128) return 0;

    std::pair<T, int> key{n, d};
    auto where = mem_.find(key);
    if (where != mem_.end()) return where->second;

    if (d == 1) {
      T ret = n - 1;
      for (int i = 2; i < 128; ++i) {
        ret -= Cal(n, i);
      }
      return mem_[key] = ret;
    }

    return mem_[key] = Cal(RootI<T>(n, d), 1);
  }

 private:
  int pivot_;
  int (*pre_)[20];
  std::map<std::pair<T, int>, T> mem_;
};

// Counts #{i | i  L[j] and 1 <= i <= n}.
// It's NOT required that the integers in L are pairwise coprime.
// See pe466, Lucy_Hedgehog's post.
template <typename T>
struct NotDivCounter {
  T NotDivCoprimeImpl(T n, const std::vector<int64>& L, int i) {
    T ret = n;
    for (int j = 0; j < i; ++j) {
      const auto x = L[j];
      if (x > n) break;
      ret -= NotDivCoprimeImpl(n / x, L, j);
    }
    return ret;
  }

  // Counts #{i | i  L[j] and 1 <= i <= n}.
  // It's required that the integers in L are pairwise coprime.
  T NotDivCoprime(T n, const std::vector<int64>& L) {
    const int size = sz(L);
    if (size == 0) return n;
    if (CheckSorted(L)) return NotDivCoprimeImpl(n, L, size);

    std::vector<int64> LL(L);
    std::sort(LL.begin(), LL.end());
    return NotDivCoprimeImpl(n, LL, size);
  }

  T NotDivImpl(T n, const std::vector<int64>& L) {
    const int size = sz(L);
    if (size == 0) return n;

    std::vector<int> flag(size, 0);
    for (int i = 0; i < size; ++i) {
      for (int j = i + 1; j < size; ++j) {
        if (L[j] % L[i] == 0) flag[j] = 1;
      }
    }
    std::vector<int64> R;
    for (int i = 0; i < size; ++i) {
      if (flag[i] == 0) R.push_back(L[i]);
    }

    for (int i = 0; i < pcnt; ++i) {
      const int64 p = plist[i];
      if (p > L[size - 1]) break;

      std::vector<int64> D;
      for (auto& iter : R) {
        if (iter % p == 0) D.push_back(iter);
      }
      if (sz(D) < 2) continue;
      std::vector<int64> C;
      for (auto& iter : R) {
        if (iter % p) C.push_back(iter);
      }
      std::vector<int64> B(C);
      for (auto& iter : D) B.push_back(iter / p);
      std::sort(B.begin(), B.end());
      return NotDivImpl(n, C) - NotDivImpl(n / p, C) + NotDivImpl(n / p, B);
    }

    std::pair<T, std::vector<int64>> key{n, R};
    auto where = mem_.find(key);
    if (where != mem_.end()) return where->second;
    return mem_[key] = NotDivCoprime(n, R);
  }

  // Counts #{i | i  L[j] and 1 <= i <= n}.
  // It's NOT required that the integers in L are pairwise coprime.
  T NotDiv(T n, const std::vector<int64>& L) {
    const int size = sz(L);
    if (size == 0) return n;
    if (CheckSorted(L)) return NotDivImpl(n, L);

    std::vector<int64> LL(L);
    std::sort(LL.begin(), LL.end());
    return NotDivImpl(n, LL);
  }

  int CheckSorted(const std::vector<int64>& L) {
    const int size = sz(L);
    for (int i = 0; i + 1 < size; ++i) {
      if (L[i] > L[i + 1]) {
        return 0;
      }
    }
    return 1;
  }

 private:
  std::map<std::pair<T, std::vector<int64>>, T> mem_;
};

namespace internal {
// Counts #{i | i  L[j] and 1 <= i <= n}.
// It's required that the integers in L are pairwise coprime.
template <typename T>
SL T CountNotDivImpl(T n, const std::vector<T>& L, T* mask, int* bc) {
  if (n <= 0) return 0;
  const int size = sz(L);
  if (size == 0) return n;

  const int limit = 1 << size;
  T ret = 0;
  for (int i = 0; i < limit; ++i) {
    if (bc[i] & 1) {
      ret -= n / mask[i];
    } else {
      ret += n / mask[i];
    }
  }

  return ret;
}
}  // namespace internal

// Counts #{i | i  L[j] and 1 <= i <= n}.
// It's required that the integers in L are pairwise coprime.
template <typename T>
SL T CountNotDiv(T n, const std::vector<T>& L, int* bc) {
  if (n <= 0) return n;
  const int size = sz(L);
  if (size == 0) return n;

  const int limit = 1 << size;
  std::vector<T> mask(limit);
  mask[0] = 1;
  for (int i = 0; i < size; ++i) {
    mask[1 << i] = L[i];
  }
  for (int i = 1; i < limit; ++i) {
    if (i & (i - 1)) {
      const int f = i & -i;
      mask[i] = mask[i ^ f] * mask[f];
    }
  }
  return internal::CountNotDivImpl<T>(n, L, &mask[0], bc);
}

// Counts #{i | i  L[j] and 1 <= i <= n}.
// It's required that the integers in L are pairwise coprime.
template <typename T>
SL T CountNotDiv(T n, const std::vector<T>& L) {
  if (n <= 0) return n;
  const int size = sz(L);
  if (size == 0) return n;

  const int limit = 1 << size;
  std::vector<T> mask(limit);
  std::vector<int> bc(limit);
  mask[0] = 1;
  for (int i = 0; i < size; ++i) {
    mask[1 << i] = L[i];
  }
  bc[0] = 0;
  for (int i = 1; i < limit; ++i) {
    if (i & (i - 1)) {
      const int f = i & -i;
      mask[i] = mask[i ^ f] * mask[f];
    }
    bc[i] = bc[i >> 1] + (i & 1);
  }
  return internal::CountNotDivImpl(n, L, &mask[0], &bc[0]);
}

// Counts the number of integers accepted by a DFA.
// Case 1. Counts the numbers which are no more than a given upper bound.
// Case 2. Finds the kth number.
//
// DfaCounter<Count type> dc;
//
// Build DFA:
// dc.Init(state count, number base, max len);
// dc.AddTrans(src, dig, dest);
//
// Mark acepted status:
// dc.MarkTargetState(state);
//
// Build internal helper data structures.
// [optional] dc.Prepare();
//
// Calcuate the result:
// dc.Cal(upper bound);
// dc.FindKth(k, upper bound);
//
// Example: examples/dfa_counter.c
template <typename CT>
struct DfaCounter {
  // Call set_count_each_len(1) if the dfa doesn't count the numbers with
  // leading zeros.
  DfaCounter& set_count_each_len(int count_each_len) {
    count_each_len_ = count_each_len;
    return *this;
  }

  DfaCounter& Init(int state_count, int number_base, int max_len) {
    state_count_ = state_count;
    number_base_ = number_base;
    max_len_ = max_len;

    dfa_.Reset({state_count, number_base_});

    dp_.Reset({max_len + 1, state_count});
    acc_.resize(max_len + 1);

    target_state_.resize(state_count);
    std::fill(target_state_.begin(), target_state_.end(), 0);

    prepared_ = 0;

    return *this;
  }

  DfaCounter& AddTrans(int s, int d, int t) {
    dfa_[s][d] = t;
    return *this;
  }

  DfaCounter& MarkTargetState(int s, int v = 1) {
    target_state_[s] = v;
    return *this;
  }

  void Prepare() {
    for (int i = 0; i < state_count_; ++i) {
      dp_[0][i] = target_state_[i];
    }

    acc_[0] = 0;
    for (int i = 1; i <= max_len_; ++i) {
      for (int j = 0; j < state_count_; ++j) {
        auto to = dfa_[j];
        CT tmp = 0;
        for (int k = 0; k < number_base_; ++k) {
          tmp += dp_[i - 1][to[k]];
        }
        dp_[i][j] = tmp;
      }
      acc_[i] = dp_[i][0] + acc_[i - 1];
    }

    prepared_ = 1;
  }

  template <typename U>
  CT Cal(U n) {
    std::vector<int> dig;
    for (auto x = n; !IsZero(x); x /= number_base_) {
      dig.push_back(ToInt<int>(x % number_base_));
    }
    return Cal(dig);
  }

  CT Cal(const std::vector<int>& dig) {
    if (prepared_ == 0) {
      Prepare();
      prepared_ = 1;
    }

    const int len = dig.size();
    PE_ASSERT(len <= max_len_);

    CT result = 0;
    if (count_each_len_) {
      for (int i = 1; i < len; ++i) {
        result += dp_[i][0];
      }
    }

    int state = 0;
    for (int curr = len - 1; curr >= 0; --curr) {
      const int me = dig[curr];
      for (int i = 0; i < me; ++i) {
        result += dp_[curr][dfa_[state][i]];
      }
      state = dfa_[state][me];
    }
    if (target_state_[state]) {
      result += 1;
    }
    return result;
  }

  int FindLen(CT k) {
    int len = 0;
    if (count_each_len_ == 0) {
      while (dp_[len][0] < k && len + 1 <= max_len_) {
        ++len;
      }
      PE_ASSERT(dp_[len][0] >= k);
    } else {
      while (acc_[len] < k && len + 1 <= max_len_) {
        ++len;
      }
      PE_ASSERT(acc_[len] >= k);
    }
    return len;
  }

  template <typename U>
  U CalKth(CT k, U unused = 0) {
    if (prepared_ == 0) {
      Prepare();
      prepared_ = 1;
    }

    U l = 1, r = 0;
    for (int len = FindLen(k); len--;) {
      r = r * number_base_ + number_base_ - 1;
    }
    while (l <= r) {
      U mid = (l + r) / 2;
      if (Cal(mid) >= k) {
        r = mid - 1;
      } else {
        l = mid + 1;
      }
    }
    return l;
  }

  template <typename U>
  U CalKthEx(CT k, U unused = 0) {
    if (prepared_ == 0) {
      Prepare();
      prepared_ = 1;
    }

    int len = FindLen(k);
    if (count_each_len_) {
      k -= acc_[len - 1];
    }

    U result = 0;
    for (int state = 0; len > 0; --len) {
      for (int i = 0; i < number_base_; ++i) {
        int now = dfa_[state][i];
        CT cnt = dp_[len - 1][now];
        if (cnt >= k) {
          result = result * number_base_ + i;
          state = now;
          break;
        } else {
          k -= cnt;
        }
      }
    }
    return result;
  }

 private:
  int count_each_len_ = 0;
  int state_count_ = 0;
  int number_base_ = 0;
  int prepared_ = 0;
  int max_len_ = 0;
  DArray<int, 2> dfa_;
  DArray<CT, 2> dp_;
  std::vector<CT> acc_;
  std::vector<int> target_state_;
};

// Calculates the sum of the power of the integers accepted by a DFA.
// See DfaCounter for more details.
// Example: examples/dfa_summer.c
template <typename CT>
struct DfaSummer {
  DfaSummer& set_count_each_len(int count_each_len) {
    count_each_len_ = count_each_len;
    return *this;
  }

  DfaSummer& Init(int state_count, int max_power, int number_base,
                  int max_len) {
    state_count_ = state_count;
    max_power_ = max_power;
    max_len_ = max_len;
    number_base_ = number_base;

    dfa_.Reset({state_count, number_base_});

    dp_.Reset({max_power_ + 1, max_len + 1, state_count});

    target_state_.resize(state_count);
    std::fill(target_state_.begin(), target_state_.end(), 0);

    base_power_.resize(max_len + 1);
    base_power_[0] = 1;
    for (int i = 1; i <= max_len; ++i) {
      base_power_[i] = base_power_[i - 1] * number_base_;
    }

    choose.Reset({max_power_ + 1, max_power_ + 1});
    for (int i = 0; i <= max_power_; ++i) {
      for (int j = 0; j <= max_power_; ++j) {
        if (j == 0 || i == j) {
          choose[i][j] = 1;
        } else {
          choose[i][j] = j > i ? 0 : choose[i - 1][j - 1] + choose[i - 1][j];
        }
      }
    }

    prepared_ = 0;

    return *this;
  }

  DfaSummer& AddTrans(int s, int d, int t) {
    dfa_[s][d] = t;
    return *this;
  }

  DfaSummer& MarkTargetState(int s, int v = 1) {
    target_state_[s] = v;
    return *this;
  }

  void Prepare() {
    for (int i = 0; i < state_count_; ++i) {
      dp_[0][0][i] = target_state_[i];
    }
    for (int i = 1; i <= max_len_; ++i) {
      for (int j = 0; j < state_count_; ++j) {
        auto to = dfa_[j];
        CT tmp = 0;
        for (int k = 0; k < number_base_; ++k) {
          tmp += dp_[0][i - 1][to[k]];
        }
        dp_[0][i][j] = tmp;
        for (int p = 1; p <= max_power_; ++p) {
          CT tmp = 0;
          for (int k = 0; k < number_base_; ++k) {
            CT a = 1;
            CT each = k * base_power_[i - 1];
            int state = to[k];
            for (int t = 0; t <= p; ++t) {
              tmp += choose[p][t] * a * dp_[p - t][i - 1][state];
              a *= each;
            }
          }
          dp_[p][i][j] = tmp;
        }
      }
    }
    prepared_ = 1;
  }

  template <typename U>
  CT Cal(U n, int target_power = 0) {
    std::vector<int> dig;
    for (auto x = n; !IsZero(x); x /= number_base_) {
      dig.push_back(ToInt<int>(x % number_base_));
    }

    return Cal(dig, target_power);
  }

  CT Cal(const std::vector<int>& dig, int target_power = 0) {
    if (prepared_ == 0) {
      Prepare();
      prepared_ = 1;
    }
    if (target_power == 0) {
      target_power = max_power_;
    }

    PE_ASSERT(target_power <= max_power_);

    const int len = dig.size();
    PE_ASSERT(len <= max_len_);

    CT result = 0;
    if (count_each_len_) {
      for (int i = 1; i < len; ++i) {
        result += dp_[target_power][i][0];
      }
    }

    int state = 0;
    CT val = 0;
    for (int curr = len - 1; curr >= 0; --curr) {
      const int me = dig[curr];
      for (int i = 0; i < me; ++i) {
        const int next_state = dfa_[state][i];
        CT a = 1;
        CT each = (val * number_base_ + i) * base_power_[curr];
        for (int j = 0; j <= target_power; ++j) {
          result += choose[target_power][j] * a *
                    dp_[target_power - j][curr][next_state];
          a *= each;
        }
      }
      state = dfa_[state][me];
      val = val * number_base_ + me;
    }
    if (target_state_[state]) {
      CT t = 1;
      for (int i = 0; i < target_power; ++i) {
        t *= val;
      }
      result += t;
    }
    return result;
  }

 private:
  int count_each_len_ = 0;
  int state_count_ = 0;
  int max_power_ = 0;
  int number_base_ = 0;
  int prepared_ = 0;
  int max_len_ = 0;
  DArray<int, 2> dfa_;
  DArray<CT, 3> dp_;
  std::vector<int> target_state_;
  std::vector<CT> base_power_;
  DArray<CT, 2> choose;
};

// Counts the number of different words where the number of each letter is given
// by vec[0], vec[1], ...
//
// Reference: Counting words with Laguerre series
// https://arxiv.org/pdf/1306.6232.pdf
struct CarlitzWordsCounter {
  CarlitzWordsCounter(int64 mod, int64 maxf) { Init(mod, maxf); }

  void Init(const int64 mod, const int64 maxf) {
    mod_ = mod;
    maxf_ = maxf;
    fac_.resize(maxf_ + 1);
    ifac_.resize(maxf_ + 1);
    InitSeqProd2<int64>(&fac_[0], &ifac_[0], 1, maxf_, mod_);
  }

  int64 Comb(int64 a, int64 b) {
    if (a < 0 || b < 0 || b > a) return 0;
    int64 t = MulMod(fac_[a], ifac_[b], mod_);
    return MulMod(t, ifac_[a - b], mod_);
  }

  int64 Cal(std::vector<int64> vec) {
    if (vec.size() == 1) {
      return vec[0] == 1 ? 1 : 0;
    }
    vec = ToInternal(vec);
    auto where = cache_.find(vec);
    if (where != cache_.end()) {
      return where->second;
    }
    std::vector<int64> it{1};
    const int64 vsize = sz(vec);
    for (int64 i = 0; i < vsize; i += 2) {
      auto L = MakeLaguerrePoly(vec[i], IsEven(vec[i]) ? 1 : -1);
      for (int j = 0; j < vec[i + 1]; ++j) it = PolyMul(it, L, mod_);
    }
    int64 ret = 0;
    const int64 size = sz(it);
    for (int64 i = 0; i < size; ++i) {
      ret = AddMod(ret, MulMod(fac_[i], it[i], mod_), mod_);
    }
    return cache_[vec] = ret;
  }

  std::vector<int64> MakeLaguerrePoly(int64 n, int sgn = 1) {
    std::vector<int64> ret(n + 1, 0);
    for (int i = 1; i <= n; ++i) {
      int64 curr = Mod(IsEven(i) ? sgn : -sgn, mod_);
      curr = MulMod(curr, Comb(n - 1, n - i), mod_);
      curr = MulMod(curr, ifac_[i], mod_);
      ret[i] = curr;
    }
    return ret;
  }

  std::vector<int64> ToInternal(const std::vector<int64>& v) {
    std::map<int64, int64> m;
    for (auto& iter : v) m[iter]++;
    std::vector<int64> t;
    for (auto& iter : m) t.push_back(iter.first), t.push_back(iter.second);
    return t;
  }

 private:
  int64 maxf_;
  int64 mod_;
  std::map<std::vector<int64>, int64> cache_;
  std::vector<int64> fac_;
  std::vector<int64> ifac_;
};

namespace internal {
// Let P(i, x) = sum(C(i, d) x^d, 0 <= d <= deg)
//
// It is assumted that
// P(order, n) A(n) + P(order-1, n-1) A(n-1) + ... + P(0, n-order) A(n-order)= 0
//
// The minimal order for a given deg is automatically determined.
//
// Source (unavailable now):
// https://min-25.hatenablog.com/entry/2018/05/10/212805
SL std::optional<std::vector<std::vector<int64>>> FindRecurrenceWithDegree(
    Span<const int64> terms, int deg, int64 mod) {
  const int64 n = static_cast<int64>(terms.size());
  const int64 B = (n + 2) / (deg + 2);
  const int64 C = B * (deg + 1);
  const int64 R = n - (B - 1);

  if (B < 2 || R < C - 1) {
    return std::nullopt;
  }

  // P(0, 0) A(0) + P(1, 1) A(1) + ... + P(B-1, B-1) A(B-1) = 0
  // P(0, 1) A(1) + P(1, 2) A(2) + ... + P(B-1, B) A(B) = 0
  // ...
  // P(0, R-1) A(R-1) + P(1, R) A(R) + ... + P(B-1, R+B-2) A(R+B-2) = 0
  std::vector<std::vector<int64>> mat(R, std::vector<int64>(C));
  for (int y = 0; y < R; ++y) {
    for (int b = 0; b < B; ++b) {
      int64 v = Mod(terms[y + b], mod);
      for (int d = 0; d <= deg; ++d) {
        mat[y][b * (deg + 1) + d] = v;
        v = MulMod(v, y + b, mod);
      }
    }
  }

  int rank = 0;
  for (int x = 0; x < C; ++x) {
    int pivot = -1;
    for (int y = rank; y < R; ++y)
      if (mat[y][x] != 0) {
        pivot = y;
        break;
      }
    if (pivot < 0) break;
    if (pivot != rank) {
      swap(mat[rank], mat[pivot]);
    }
    const int64 inv = ModInv(mat[rank][x], mod);
    for (int x2 = x; x2 < C; ++x2) {
      mat[rank][x2] = MulMod(mat[rank][x2], inv, mod);
    }
    for (int y = rank + 1; y < R; ++y)
      if (mat[y][x]) {
        const int64 c = mod - mat[y][x];
        for (int x2 = x; x2 < C; ++x2) {
          mat[y][x2] = AddMod(mat[y][x2], MulMod(c, mat[rank][x2], mod), mod);
        }
      }
    ++rank;
  }

  // If the rank of the coefficient matrix is full, it has 0 solution.
  if (rank == C) {
    return std::nullopt;
  }

  for (int y = rank - 1; y >= 0; --y)
    if (mat[y][rank]) {
      if (mat[y][y] != 1) return std::nullopt;
      const int64 c = mod - mat[y][rank];
      for (int y2 = 0; y2 < y; ++y2) {
        mat[y2][rank] = AddMod(mat[y2][rank], MulMod(c, mat[y2][y], mod), mod);
      }
    }

  int order = rank / (deg + 1);
  std::vector<std::vector<int64>> ret(order + 1, std::vector<int64>(deg + 1));
  // The equation has infinity solution.
  // The highest degree of P(0, x) is dertermined and the coefficient is set
  // to 1.
  ret[0][rank % (deg + 1)] = 1;
  for (int y = rank - 1; y >= 0; --y) {
    const int k = order - y / (deg + 1);
    const int d = y % (deg + 1);
    ret[k][d] = (mod - mat[y][rank]) % mod;
  }

  return ret;
}
}  // namespace internal

SL int64 ApplyRecurrenceNext(const std::vector<std::vector<int64>>& recurrence,
                             Span<const int64> terms, int64 m, int64 mod) {
  const int order = static_cast<int>(recurrence.size()) - 1;
  const int deg = static_cast<int>(recurrence[0].size()) - 1;
  assert(static_cast<int>(terms.size()) >= order);

  int64 s = 0;
  for (int i = 1; i <= order; ++i) {
    const int64 k = SubMod(Mod(m, mod), Mod(i, mod), mod);
    int64 t = terms[terms.size() - i];
    for (int d = 0; d <= deg; ++d) {
      s = AddMod(s, MulMod(t, recurrence[i][d], mod), mod);
      t = MulMod(t, k, mod);
    }
  }

  int64 denom = 0;
  int64 mpow = 1;
  for (int d = 0; d <= deg; ++d) {
    denom = AddMod(denom, MulMod(mpow, recurrence[0][d], mod), mod);
    mpow = MulMod(mpow, m, mod);
  }

  return MulMod(SubMod(0, s, mod), ModInv(denom, mod), mod);
}

SL int VerifyRecurrence(Span<const int64> terms,
                        const std::vector<std::vector<int64>>& recurrence,
                        int64 mod) {
  const int64 n = static_cast<int64>(terms.size());
  const int order = static_cast<int>(recurrence.size()) - 1;
  for (int64 i = order; i < n; ++i) {
    int64 value = ApplyRecurrenceNext(recurrence,
                                      terms.subspan(i - order, order), i, mod);
    if (value != Mod(terms[i], mod)) {
      return 0;
    }
  }
  return 1;
}

SL std::optional<std::vector<std::vector<int64>>> FindRecurrence(
    Span<const int64> terms, int64 mod, int64 min_deg = 0, int64 max_deg = -1) {
  const int64 n = static_cast<int64>(terms.size());
  for (int64 deg = min_deg; max_deg == -1 || deg <= max_deg; ++deg) {
    const int64 B = (n + 2) / (deg + 2);
    const int64 C = B * (deg + 1);
    const int64 R = n - (B - 1);

    if (B < 2 || R < C - 1) {
      break;
    }

    auto recurrence =
        internal::FindRecurrenceWithDegree(terms, static_cast<int>(deg), mod);
    if (!recurrence.has_value()) {
      continue;
    }

    if (!VerifyRecurrence(terms, *recurrence, mod)) {
      continue;
    }

    return recurrence;
  }

  return std::nullopt;
}

SL std::optional<int64> RecurrenceValueAtN(Span<const int64> terms, int64 n,
                                           int64 mod, int min_deg = 0,
                                           int max_deg = -1) {
  if (n < static_cast<int64>(terms.size())) {
    return terms[n];
  }

  auto recurrence = FindRecurrence(terms, mod, min_deg, max_deg);
  if (!recurrence.has_value()) {
    return std::nullopt;
  }

  const int64 m = static_cast<int64>(terms.size());
  const int order = static_cast<int>(recurrence->size()) - 1;
  std::vector<int64> data(order);
  for (int i = 0; i < order; ++i) {
    data[i] = terms[m - order + i];
  }
  for (int64 i = m; i <= n; ++i) {
    int64 value = ApplyRecurrenceNext(*recurrence, data, i, mod);
    data.push_back(value);
  }

  return data.back();
}

SL std::optional<std::vector<int64>> RecurrenceValues(Span<const int64> terms,
                                                      int64 n, int64 mod,
                                                      int min_deg = 0,
                                                      int max_deg = -1) {
  auto recurrence = FindRecurrence(terms, mod, min_deg, max_deg);
  if (!recurrence.has_value()) {
    return std::nullopt;
  }

  const int64 m = static_cast<int64>(terms.size());
  std::vector<int64> data(m);
  for (int i = 0; i < m; ++i) {
    data[i] = terms[i];
  }
  for (int64 i = m; i <= n; ++i) {
    int64 value = ApplyRecurrenceNext(*recurrence, data, i, mod);
    data.push_back(value);
  }

  return data;
}

// https://en.wikipedia.org/wiki/Surreal_number
// https://www.infinitelymore.xyz/p/surreal-numbers
// https://math.uchicago.edu/~may/REU2016/REUPapers/Cronin.pdf
// https://web.mit.edu/sp.268/www/2010/surreal.pdf
// https://zhuanlan.zhihu.com/p/205154262
// https://kewth.github.io/2020/05/09/%E4%B8%80%E7%B1%BB%E4%B8%8D%E5%85%AC%E5%B9%B3%E5%8D%9A%E5%BC%88%E6%80%BB%E7%BB%93/
template <typename T>
std::optional<Fraction<T>> FindSurrealNumber(std::optional<Fraction<T>> u,
                                             std::optional<Fraction<T>> v) {
  if (!u.has_value() && !v.has_value()) {
    return Fraction<T>(0);
  }
  if (!v.has_value()) {
    if (u->a < 0) {
      return Fraction<T>(0);
    } else {
      return Fraction<T>(u->a / u->b + 1);
    }
  }
  if (!u.has_value()) {
    if (v->a > 0) {
      return Fraction<T>(0);
    } else {
      return Fraction<T>(u->a / u->b - 1);
    }
  }
  if (u->a < 0 && v->a > 0) {
    return Fraction<T>(0);
  }
  if (*u >= *v) {
    return std::nullopt;
  }
  if (u->a >= 0) {
    for (T d = 1;; d *= 2) {
      T tmp = u->a * d / u->b + 1;
      if (tmp < *v * d) return Fraction<T>(tmp, d);
    }
  }
  if (v->a <= 0) {
    for (T d = 1;; d *= 2) {
      T tmp = v->a * d / v->b - 1;
      if (tmp > *u * d) return Fraction<T>(tmp);
    }
  }
  PE_ASSERT(0);
  return 0;
}
}  // namespace pe
#endif