#ifndef PE_SYM_POLY_
#define PE_SYM_POLY_

#include "pe_base"

namespace pe {
// TermKey.size() == 0, constant term.
// The elements are sorted.
using TermKey = std::vector<std::pair<std::string, int>>;

template <typename CT>
struct SymPoly;

template <typename CT>
SL SymPoly<CT> ParseSymPoly(const std::string& s);

template <typename CT>
SL std::ostream& ToString(const SymPoly<CT>& sp, std::ostream& o,
                          int cstyle = 0, int show_mul = 0);

template <typename CT>
struct SymPoly {
  SymPoly() = default;

  SymPoly(const std::map<TermKey, CT>& terms) : terms_(terms) {
    FixCoefficient();
  }

  SymPoly(std::map<TermKey, CT>&& terms) : terms_(terms) { FixCoefficient(); }

  SymPoly(const SymPoly& o) : terms_(o.terms_) {}

  SymPoly(SymPoly&& o) noexcept : terms_(std::move(o.terms_)) {}

  SymPoly(const std::string& str) : terms_(ParseSymPoly<CT>(str)) {
    FixCoefficient();
  }

  SymPoly(CT v) {
    if (v != 0) {
      terms_[{}] = v;
    }
  }

  SymPoly& operator=(const SymPoly& o) {
    terms_ = o.terms_;
    return *this;
  }

  SymPoly& operator=(SymPoly&& o) noexcept {
    terms_ = std::move(o.terms_);
    return *this;
  }

  void FixCoefficient() {
    auto now = std::begin(terms_);
    auto end = std::end(terms_);
    while (now != end) {
      if (now->second == 0) {
        terms_.erase(now++);
      } else {
        ++now;
      }
    }
  }

  SymPoly Power(int n) const {
    PE_ASSERT(n >= 0);
    SymPoly<CT> t;
    t.terms_[{}] = 1;
    SymPoly<CT> x(this->terms_);
    for (; n; n >>= 1) {
      if (n & 1) t = t * x;
      if (n > 1) x = x * x;
    }
    return t;
  }

  SymPoly Replace(std::string var, const SymPoly<CT>& target) const {
    std::map<TermKey, CT> resultTerms;
    for (const auto& iter : terms_) {
      int found = 0;
      const int size = sz(iter.first);
      for (int i = 0; i < size; ++i) {
        if (iter.first[i].first == var) {
          SymPoly t = target.Power(iter.first[i].second);
          SymPoly k;
          TermKey others;
          for (int j = 0; j < size; ++j) {
            if (j != i) {
              others.push_back(iter.first[j]);
            }
          }
          k.terms_[others] = iter.second;
          for (const auto& i : (k * t).terms_) {
            resultTerms[i.first] += i.second;
          }
          found = 1;
          break;
        }
      }
      if (!found) {
        resultTerms[iter.first] += iter.second;
      }
    }
    return SymPoly(resultTerms);
  }

  SymPoly Replace(std::string var, const std::string& target) const {
    return Replace(var, SymPoly(target));
  }

  void MakeNeg() {
    for (auto& [key, value] : terms_) {
      value = -value;
    }
  }

  std::string ToString(int cstyle = 1, int show_mul = 0) const {
    std::stringstream ss;
    pe::ToString(*this, ss, cstyle, show_mul);
    return ss.str();
  }

  std::string to_string(int cstyle = 1, int show_mul = 0) const {
    return ToString(cstyle, show_mul);
  }

  const std::map<TermKey, CT>& terms() const { return terms_; }

  friend SymPoly<CT> operator+(const SymPoly<CT>& a, const SymPoly<CT>& b) {
    auto terms = a.terms_;
    for (const auto& iter : b.terms_) {
      terms[iter.first] += iter.second;
    }
    return SymPoly<CT>(terms);
  }
  friend SymPoly<CT> operator-(const SymPoly<CT>& a, const SymPoly<CT>& b) {
    auto terms = a.terms_;
    for (const auto& iter : b.terms_) {
      terms[iter.first] -= iter.second;
    }
    return SymPoly<CT>(terms);
  }
  static TermKey MergeTermKey(const TermKey& a, const TermKey& b) {
    if (a.size() == 0) return b;
    if (b.size() == 0) return a;
    std::map<std::string, int> terms;
    for (const auto& iter : a) terms[iter.first] += iter.second;
    for (const auto& iter : b) terms[iter.first] += iter.second;
    TermKey result;
    result.reserve(terms.size());
    for (const auto& iter : terms) result.emplace_back(iter.first, iter.second);
    return result;
  }
  friend SymPoly<CT> operator*(const SymPoly<CT>& a, const SymPoly<CT>& b) {
    std::map<TermKey, CT> terms;
    for (const auto& iter1 : a.terms()) {
      for (const auto& iter2 : b.terms()) {
        terms[MergeTermKey(iter1.first, iter2.first)] +=
            iter1.second * iter2.second;
      }
    }
    return SymPoly<CT>(terms);
  }

 private:
  // TermKey -> coefficient.
  // terms_.size() == 0: value
  std::map<TermKey, CT> terms_;
};

using SymPoly64 = SymPoly<int64>;

template <typename CT>
SL SymPoly<CT> ParseSymPolyPower(const std::string& s, int& i);

template <typename CT>
SL SymPoly<CT> ParseSymPolyMul(const std::string& s, int& i);

template <typename CT>
SL SymPoly<CT> ParseSymPolyAddOrSubstract(const std::string& s, int& i);

template <typename CT>
SL SymPoly<CT> ParseSymPolyAtomic(const std::string& s, int& i) {
  const int size = sz(s);
  SymPoly<CT> poly;
  while (i < size && std::isspace(s[i])) ++i;
  if (i == size) {
    std::cerr << "ParseSymPolyAtomic Unknown: " << s.substr(i) << std::endl;
    return poly;
  }
  if (std::isdigit(s[i])) {
    CT now = 0;
    while (i < size && std::isdigit(s[i])) now = now * 10 + s[i++] - '0';
    return SymPoly<CT>(now);
  } else if (std::isalpha(s[i]) || s[i] == '_') {
    int j = i + 1;
    while (j < size && (std::isalpha(s[j]) || s[j] == '_')) ++j;
    std::map<TermKey, CT> terms;
    terms[{{s.substr(i, j - i), 1}}] = 1;
    i = j;
    return terms;
  } else if (s[i] == '+') {
    ++i;
    return ParseSymPolyMul<CT>(s, i);
  } else if (s[i] == '+') {
    ++i;
    auto t = ParseSymPolyMul<CT>(s, i);
    t.MakeNeg();
    return t;
  } else if (s[i] == '(') {
    ++i;
    auto t = ParseSymPolyAddOrSubstract<CT>(s, i);
    while (i < size && std::isspace(s[i])) ++i;
    if (i == size || s[i] != ')') {
      std::cerr << ") is expected";
      if (i < size) {
        std::cerr << ": " << s.substr(i);
      }
      std::cerr << std::endl;
      return t;
    }
    ++i;
    return t;
  } else {
    std::cerr << "ParseSymPolyAtomic Unknown: " << s.substr(i) << std::endl;
    return poly;
  }
  return poly;
}

template <typename CT>
SL SymPoly<CT> ParseSymPolyPower(const std::string& s, int& i) {
  const int size = sz(s);
  SymPoly<CT> poly = ParseSymPolyAtomic<CT>(s, i);
  while (i < size && std::isspace(s[i])) ++i;
  if (i == size) {
    return poly;
  }
  if (s[i] == '^') {
    ++i;

    while (i < size && std::isspace(s[i])) ++i;
    if (i == s || !std::isdigit(s[i])) {
      std::cerr << "ParseSymPolyPower Unknown: " << s.substr(i) << std::endl;
      return poly;
    }
    int64 now = 0;
    while (i < size && std::isdigit(s[i])) now = now * 10 + s[i++] - '0';
    return poly.Power(now);
  }
  return poly;
}

template <typename CT>
SL SymPoly<CT> ParseSymPolyMul(const std::string& s, int& i) {
  const int size = sz(s);
  SymPoly<CT> poly = ParseSymPolyPower<CT>(s, i);
  for (;;) {
    while (i < size && std::isspace(s[i])) ++i;
    if (i == size) break;
    if (s[i] == '*') {
      ++i;
      while (i < size && std::isspace(s[i])) ++i;
      if (i == size) {
        std::cerr << "ParseSymPolyMul Unknown 0: " << s.substr(i) << std::endl;
        break;
      }
    }
    if (std::isdigit(s[i]) || std::isalpha(s[i]) || s[i] == '_' ||
        s[i] == '(') {
      SymPoly<CT> t = ParseSymPolyPower<CT>(s, i);
      poly = poly * t;
    } else {
      break;
    }
  }
  return poly;
}

template <typename CT>
SL SymPoly<CT> ParseSymPolyAddOrSubstract(const std::string& s, int& i) {
  const int size = sz(s);
  SymPoly<CT> poly = ParseSymPolyMul<CT>(s, i);
  for (;;) {
    while (i < size && std::isspace(s[i])) ++i;
    if (i == size) break;
    char ope = s[i];
    if (ope != '+' && ope != '-') {
      break;
    } else {
      ++i;
      while (i < size && std::isspace(s[i])) ++i;
    }
    int j = i;
    SymPoly<CT> t = ParseSymPolyMul<CT>(s, j);
    if (j == i) {
      if (i < size) {
        std::cerr << "Unknown: " << s.substr(i) << std::endl;
      }
      break;
    }
    i = j;
    if (ope == '+') {
      poly = poly + t;
    } else {
      poly = poly - t;
    }
  }
  return poly;
}

template <typename CT>
SL SymPoly<CT> ParseSymPoly(const std::string& s) {
  int i = 0;
  return ParseSymPolyAddOrSubstract<CT>(s, i);
}

SL std::ostream& ToString(const TermKey& vpv, std::ostream& o, int cstyle = 1,
                          int show_mul = 0) {
  int idx = 0;
  for (const auto& iter : vpv) {
    if (++idx > 1) {
      o << (show_mul ? " * " : " ");
    }
    if (iter.second == 1) {
      o << iter.first;
    } else {
      if (cstyle) {
        o << "Power(" << iter.first << ", " << iter.second << ")";
      } else {
        o << iter.first << "^" << iter.second;
      }
    }
  }
  return o;
}

template <typename CT>
SL std::ostream& ToString(const SymPoly<CT>& sp, std::ostream& o, int cstyle,
                          int show_mul) {
  if (cstyle) show_mul = 1;
  int idx = 0;
  for (const auto& iter : sp.terms()) {
    if (iter.second == 0) continue;
    ++idx;
    int out = idx == 1 ? 0 : 1;
    int hasNum = 0;
    if (iter.second > 0) {
      if (idx > 1) {
        if (out) o << " ";
        o << "+";
        out = 1;
      }
    } else {
      if (out) o << " ";
      o << "-";
      out = 1;
    }
    if (Abs(iter.second) != 1 || iter.first.empty()) {
      if (out) o << " ";
      o << Abs(iter.second);
      out = 1;
      hasNum = 1;
    }
    if (iter.first.size() > 0) {
      if (out) o << (show_mul && hasNum ? " * " : " ");
      ToString(iter.first, o, cstyle, show_mul);
      out = 1;
    }
  }
  if (idx == 0) {
    o << "0";
  }
  return o;
}

template <typename CT>
SL std::ostream& operator<<(std::ostream& o, const SymPoly<CT>& sp) {
  return ToString(sp, o);
}

}  // namespace pe
#endif