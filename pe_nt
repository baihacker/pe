#ifndef PE_NT_
#define PE_NT_

#include "pe_base"
#include "pe_type_traits"
#include "pe_mod"
#include "pe_int"
#include "pe_span"
#include "pe_nt_base"

namespace pe {
#if defined(COMPILER_MSVC) || !OS_TYPE_WIN
template <typename T>
SL REQUIRES((is_builtin_integer_v<T>)) RETURN(T) SqrtI(T d) {
  const T result = static_cast<T>(std::sqrt(static_cast<long double>(d)));
  return result * result > d ? result - 1 : result;
}
#else
template <typename T>
SL REQUIRES((is_builtin_integer_v<T>)) RETURN(T) SqrtI(T v) {
  return static_cast<T>(std::sqrt(static_cast<long double>(v)));
}
#endif

namespace internal {
template <typename T>
SL REQUIRES((is_builtin_integer_v<T>)) RETURN(T) RootIImpl(T v, int n) {
  // n > 2 && v > 1
  T r = static_cast<T>(
      std::pow(static_cast<long double>(v), static_cast<long double>(1.) / n));
#if defined(COMPILER_MSVC)
  // Avoid floating round error when the compiler is msvc.
  if (r > 2) {
    --r;
  }
#endif
  // If r is 0, the for loop may take a long time.
  if (r < 1) {
    r = 1;
  }
  for (T nextr = r + 1;; ++nextr) {
    T t = v;
    for (int i = 0; i < n; ++i) {
      t /= nextr;
      if (t == 0) {
        return r;
      }
    }
    r = nextr;
  }
}
}  // namespace internal

template <typename T>
SL REQUIRES((is_builtin_integer_v<T>)) RETURN(T) RootI(T v, int n) {
  PE_ASSERT(n >= 0);
  if (n == 0) {
    return 1;
  }
  if (n == 1) {
    return v;
  }
  if (v == 0 || v == 1) {
    return v;
  }
  if (v == -1) {
    PE_ASSERT(n % 2 == 1);
    return v;
  }
  if (n == 2) {
    PE_ASSERT(v > 0);
    return SqrtI(v);
  }
  return v > 0 ? internal::RootIImpl(v, n) : -internal::RootIImpl(-v, n);
}

// Returns the maximum idx where Power(v, idx) <= n.
// Returns -1 if v == 1 and n > 1.
template <typename T1, typename T2>
SL REQUIRES((is_general_integer_v<T1> && is_general_integer_v<T2>)) RETURN(int)
    LogI(T1 v, T2 n) {
  PE_ASSERT(v >= 1);
  PE_ASSERT(n >= 1);
  if (n == 1) {
    return 0;
  }

  if (v == 1) {
    return -1;
  }

  using T = int_promotion_t<T1, T2>;
  const T limit = n / v;
  int idx = 0;
  for (T now = 1; now <= limit; now *= v, ++idx) {
  }

  return idx;
}

template <typename T1, typename T2>
SL std::tuple<T1, int64> ExtractFactor(T1 A, T2 B) {
  int64 c = 0;
  while (!IsZero(A) && A % B == 0) {
    A = static_cast<T1>(A / B), ++c;
  }
  return {A, c};
}

// Greatest common divisor
template <typename T>
SL REQUIRES((is_builtin_or_extended_integer_v<T>)) RETURN(T) Gcd(T m, T n) {
  while (!IsZero(n)) {
    T t = m % n;
    m = n;
    n = t;
  }
  return m;
}

// #if !defined(COMPILER_MSVC) && !PE_HAS_CPP17
template <typename T0, typename T1>
SL REQUIRES((is_general_integer_v<T0> && is_general_integer_v<T1>))
    RETURN(int_promotion_t<T0, T1>) Gcd(const T0& m, const T1& n) {
  using ResultType = int_promotion_t<T0, T1>;
  return Gcd(static_cast<ResultType>(m), static_cast<ResultType>(n));
}
// #endif

template <typename T>
SL REQUIRES((is_general_integer_v<T>)) RETURN(T) Gcd(const T& m) {
  return m;
}

template <typename TH, typename... TT>
SL REQUIRES((sizeof...(TT) >= 2 &&
             predicate_all_v<is_general_integer, TH, TT...>))
    RETURN(int_promotion_t<TH, TT...>) Gcd(TH a, TT... b) {
  return Gcd(a, Gcd(b...));
}

template <typename T>
SL REQUIRES((is_general_integer_v<T>)) RETURN(T)
    Gcd(std::initializer_list<T> init) {
  T ret = 0;
  for (const T& v : init) {
    if (IsZero(ret)) {
      ret = v;
    } else {
      ret = Gcd(ret, v);
    }
  }
  return ret;
}

template <typename T>
SL REQUIRES((is_general_integer_v<T>)) RETURN(T)
    Gcd(const std::vector<T>& init) {
  T ret = 0;
  for (const T& v : init) {
    if (IsZero(ret)) {
      ret = v;
    } else {
      ret = Gcd(ret, v);
    }
  }
  return ret;
}

template <typename T>
SL REQUIRES((is_general_integer_v<T>)) RETURN(T) Lcm(const T& m, const T& n) {
  return m / Gcd(m, n) * n;
}

template <typename T0, typename T1>
SL REQUIRES((is_general_integer_v<T0> && is_general_integer_v<T1>))
    RETURN(int_promotion_t<T0, T1>) Lcm(const T0& m, const T1& n) {
  using ResultType = int_promotion_t<T0, T1>;
  return Lcm(static_cast<ResultType>(m), static_cast<ResultType>(n));
}

template <typename T>
SL REQUIRES((is_general_integer_v<T>)) RETURN(T) Lcm(const T& a) {
  return a;
}

template <typename TH, typename... TT>
SL REQUIRES((sizeof...(TT) >= 2 &&
             predicate_all_v<is_general_integer, TH, TT...>))
    RETURN(int_promotion_t<TH, TT...>) Lcm(TH a, TT... b) {
  return Lcm(a, Lcm(b...));
}

template <typename T>
SL REQUIRES((is_general_integer_v<T>)) RETURN(T)
    Lcm(std::initializer_list<T> init) {
  T ret = 0;
  for (const T& v : init) {
    if (IsZero(ret)) {
      ret = v;
    } else {
      ret = ret / Gcd(ret, v) * v;
    }
  }
  return ret;
}

template <typename T>
SL REQUIRES((is_general_integer_v<T>)) RETURN(T)
    Lcm(const std::vector<T>& init) {
  T ret = 0;
  for (const T& v : init) {
    if (IsZero(ret)) {
      ret = v;
    } else {
      ret = ret / Gcd(ret, v) * v;
    }
  }
  return ret;
}

// Extended greatest common divisor
namespace internal {
template <typename T>
SL REQUIRES((is_builtin_integer_v<T> && pe_is_signed_v<T>)) RETURN(T)
    ExGcdImpl(T a, T b, T& x, T& y) {
  /*
    if (b == 0) {
      x = 1;
      y = 0;
      return a;
    }

    T x1 = 0, y1 = 0;
    const T ret = ExGcdImpl(b, a % b, x1, y1);
    // b * x1 + (a%b) * y1 = ret
    // b * x1 + (a - a / b * b) * y1 = ret
    // b * x1 + a * y1 - a / b * b * y1 = ret
    // y1 * a + (x1 - a / b * y1) b = ret
    x = y1;
    y = x1 - a / b * y1;
    // const T ret = ExGcdImpl1(b, a % b, y, x);
    // y -= a / b * x;
  */
  T s = 1, t = 0;
  T u = 0, v = 1;
  while (b != 0) {
    const T tmp = a / b;
    std::swap(s -= t * tmp, t);
    std::swap(u -= v * tmp, v);
    std::swap(a -= b * tmp, b);
  }
  x = s;
  y = u;
  return a;
}

template <typename T>
SL REQUIRES((is_builtin_integer_v<T> && pe_is_signed_v<T>)) RETURN(T)
    ExGcdImpl(T a, T b, T& x) {
  T s = 1, t = 0;
  while (b != 0) {
    const T tmp = a / b;
    std::swap(s -= t * tmp, t);
    std::swap(a -= b * tmp, b);
  }
  x = s;
  return a;
}
}  // namespace internal

template <typename T>
SL REQUIRES((is_builtin_integer_v<T> && pe_is_signed_v<T>)) RETURN(T)
    ExGcd(T a, T b, T& x, T& y) {
  PE_ASSERT(a != 0 || b != 0);
  const T r = internal::ExGcdImpl(a, b, x, y);
  PE_ASSERT(a * x + b * y == r);
  return r;
}

template <typename T>
SL REQUIRES((is_builtin_integer_v<T> && pe_is_signed_v<T>))
    RETURN(std::tuple<T, T, T>) ExGcd(T a, T b) {
  PE_ASSERT(a != 0 || b != 0);
  T x = 0, y = 0;
  const T r = internal::ExGcdImpl(a, b, x, y);
  PE_ASSERT(a * x + b * y == r);
  return {r, x, y};
}

template <typename T>
SL REQUIRES((is_builtin_integer_v<T> && pe_is_signed_v<T>)) RETURN(T)
    ExGcd(T a, T b, T& x) {
  PE_ASSERT(a != 0 || b != 0);
  return internal::ExGcdImpl(a, b, x);
}

template <typename T>
SL REQUIRES((is_builtin_integer_v<T> && pe_is_signed_v<T>)) RETURN(T)
    ModInv(T a, T mod) {
  T b = mod, s = 1, t = 0, old_a = a;
  while (b > 0) {
    std::swap(s -= t * (a / b), t);
    std::swap(a %= b, b);
  }
  if (a > 1) {
    std::cerr << "mod inv error: " << old_a << " " << mod << std::endl;
    exit(1);
  }
  return T(s) < 0 ? s + mod : s;
}

// p is prime
SL int64 InvOf(int64 x, int64 p) { return PowerMod(x, p - 2, p); }

// Solves equation a x = b (mod m)
template <typename T>
SL REQUIRES((is_builtin_integer_v<T> && pe_is_signed_v<T>)) RETURN(ModValue<T>)
    SolveLinearEquation(T a, T b, T m) {
  PE_ASSERT(m);

  if (m < 0) m = -m;

  if (sizeof(T) <= 8) {
    PE_ASSERT(m <= PE_SOI63);
  }

  a %= m;
  b %= m;

  if (a < 0) a += m;
  if (b < 0) b += m;

  T xx = 0, d = ExGcd(a, m, xx);

  if (b % d) return ModValue<T>{0};

  xx = (xx % m + m) % m;
  xx = xx * (b / d) % m;

  T mod = m / d;
  T value = xx % mod;

  return {1, value, mod};
}

// Solves equation x = a (mod m1) x = b (mod m2)
template <typename T>
SL REQUIRES((is_builtin_integer_v<T> && pe_is_signed_v<T>)) RETURN(ModValue<T>)
    Crt2(T a, T m1, T b, T m2) {
  PE_ASSERT(m1 != 0 && m2 != 0);
  if (m1 < 0) m1 = -m1;
  if (m2 < 0) m2 = -m2;
  // x = a (mod m1)
  // x = b (mod m2)
  // x = k0 m1 + a
  // k0 m1 + a = b (mod m2)
  // k0 m1 = b - a (mod m2)
  a %= m1;
  b %= m2;
  if (a < 0) a += m1;
  if (b < 0) b += m2;

  ModValue<T> mod_value = SolveLinearEquation(m1, b - a, m2);
  if (!mod_value.ok) {
    return ModValue<T>{0};
  }
  // k0 = k1 * s + t
  // x = (k1 * s + t) * m1 + a
  // x = k1 * s * m1 + (a + t * m1)

  T mod = mod_value.mod * m1;
  T value = ((a + mod_value.value * m1) % mod + mod) % mod;

  return {1, value, mod};
}

template <typename T>
SL REQUIRES((is_builtin_integer_v<T> && pe_is_signed_v<T>)) RETURN(ModValue<T>)
    CrtN(const T* val, const T* mod, int n) {
  PE_ASSERT(val != nullptr && mod != nullptr);
  ModValue<T> ret{1, 0, 1};
  for (int i = 0; i < n; ++i) {
    ret = Crt2(ret.value, ret.mod, val[i], mod[i]);
    if (!ret.ok) {
      return ModValue<T>{0};
    }
  }
  return ret;
}

template <typename T>
SL REQUIRES((is_builtin_integer_v<T> && pe_is_signed_v<T>)) RETURN(ModValue<T>)
    CrtN(const std::vector<T>& val, const std::vector<T>& mod) {
  return CrtN<T>(std::data(val), std::data(mod), std::size(val));
}

// Returns the number of x in the range [1, n] such that x is a multiple of d.
template <typename T = int64>
SL T CountMultiple(const int64 n, const int64 d) {
  return n / d;
}

// Returns the sum of x in the range [1, n] such that x is a multiple of d.
template <typename T = int64>
SL REQUIRES((!IsNModNumberV<T>)) RETURN(T)
    SumMultiple(const int64 n, const int64 d) {
  const T t0 = n / d;
  const T t1 = t0 & 1 ? ((t0 + 1) >> 1) * t0 : (t0 >> 1) * (t0 + 1);
  return t1 * d;
}

template <typename T = int64>
SL REQUIRES((IsNModNumberV<T>)) RETURN(T)
    SumMultiple(const int64 n, const int64 d) {
  const auto t0 = ExtractValue(T(n / d));
  const T t1 = t0 & 1 ? T((t0 + 1) >> 1) * t0 : T(t0 >> 1) * (t0 + 1);
  return t1 * d;
}

// Returns the number of x in the range [1, n] such that x = remain mod(mod).
template <typename T = int64>
SL T CountModValue(const int64 n, int64 remain, int64 mod) {
  if (remain == 0) {
    return CountMultiple<T>(n, mod);
  } else {
    return CountMultiple<T>(n + mod - remain, mod);
  }
}

namespace internal {
// The sum of i, i + d, i + 2d, ..., i + (n-1) * d
template <typename T = int64>
SL REQUIRES((!IsNModNumberV<T>)) RETURN(T)
    ApSum(const int64 i, const int64 d, const int64 n) {
  const T t0 = n & 1 ? ((n - 1) >> 1) * n : (n >> 1) * (n - 1);
  return n * i + t0 * d;
}

template <typename T = int64>
SL REQUIRES((IsNModNumberV<T>)) RETURN(T)
    ApSum(const int64 i, const int64 d, const int64 n) {
  const T t0 = n & 1 ? T((n - 1) >> 1) * n : T(n >> 1) * (n - 1);
  return T(n) * i + t0 * d;
}
}  // namespace internal

// Returns the sum of x in the range [1, n] such that x = remain mod(mod).
template <typename T = int64>
SL T SumModValue(const int64 n, int64 remain, int64 mod) {
  if (remain == 0) {
    return SumMultiple<T>(n, mod);
  } else {
    return internal::ApSum(remain, mod, (n + mod - remain) / mod);
  }
}

// Returns the number of x in the range [1, n] such that x = remain0 mod(mod0),
// and x = remain1 mod(mod1).
template <typename T = int64>
SL T CountModValue(const int64 n, int64 remain0, int64 mod0, int64 remain1,
                   int64 mod1) {
  ModValue<int64> t = Crt2<int64>(remain0, mod0, remain1, mod1);
  if (!t.ok) return 0;
  return CountModValue<T>(n, t.value, t.mod);
}

// Returns the sum of x in the range [1, n] such that x = remain0 mod(mod0),
// and x = remain1 mod(mod1).
template <typename T = int64>
SL T SumModValue(const int64 n, int64 remain0, int64 mod0, int64 remain1,
                 int64 mod1) {
  ModValue<int64> t = Crt2<int64>(remain0, mod0, remain1, mod1);
  if (!t.ok) return 0;
  return SumModValue<T>(n, t.value, t.mod);
}

// Returns the number of x in the range [1, n] such that gcd(x, a) = 1.
// The rad factors with mu are given by rad_factors_with_mu.
template <typename T = int64>
SL T CountCoprime(
    int64 n, const std::vector<std::pair<int64, int>>& rad_factors_with_mu) {
  if (n == 0) {
    return 0;
  }
  T ret = 0;
  for (const auto [rad_factor, mu] : rad_factors_with_mu) {
    ret += CountMultiple<T>(n, rad_factor) * mu;
  }
  return ret;
}

template <typename T = int64>
SL T CountCoprime(int64 n, const IntegerFactorization& f) {
  if (n == 0) {
    return 0;
  }
  T ret = 0;
  for (const auto [rad_factor, mu] : GetRadFactorsWithMu(f, n)) {
    ret += CountMultiple<T>(n, rad_factor) * mu;
  }
  return ret;
}

template <typename T = int64>
SL T CountCoprime(int64 n, int64 a) {
  if (n == 0) {
    return 0;
  }
  T ret = 0;
  for (const auto [rad_factor, mu] : GetRadFactorsWithMu(a, n)) {
    ret += CountMultiple<T>(n, rad_factor) * mu;
  }
  return ret;
}

// Returns the number x in the range [1, n] such that gcd(x, a) = 1 and x =
// remain mod(mod). The rad factors with mu are given by rad_factors_with_mu.
template <typename T = int64>
SL T CountCoprime(int64 n,
                  const std::vector<std::pair<int64, int>>& rad_factors_with_mu,
                  int64 remain, int64 mod) {
  if (n == 0) {
    return 0;
  }
  T ret = 0;
  for (const auto [rad_factor, mu] : rad_factors_with_mu) {
    ret += CountModValue<T>(n, remain, mod, 0, rad_factor) * mu;
  }
  return ret;
}

template <typename T = int64>
SL T CountCoprime(int64 n, const IntegerFactorization& f, int64 remain,
                  int64 mod) {
  if (n == 0) {
    return 0;
  }
  T ret = 0;
  for (const auto [rad_factor, mu] : GetRadFactorsWithMu(f, n)) {
    ret += CountModValue<T>(n, remain, mod, 0, rad_factor) * mu;
  }
  return ret;
}

template <typename T = int64>
SL T CountCoprime(int64 n, int64 a, int64 remain, int64 mod) {
  if (n == 0) {
    return 0;
  }
  T ret = 0;
  for (const auto [rad_factor, mu] : GetRadFactorsWithMu(a, n)) {
    ret += CountModValue<T>(n, remain, mod, 0, rad_factor) * mu;
  }
  return ret;
}

// Returns the sum x in the range [1, n] such that gcd(x, a) = 1.
// The rad factors with mu are given by rad_factors_with_mu.
template <typename T = int64>
SL T SumCoprime(int64 n,
                const std::vector<std::pair<int64, int>>& rad_factors_with_mu) {
  if (n == 0) {
    return 0;
  }
  T ret = 0;
  for (const auto [rad_factor, mu] : rad_factors_with_mu) {
    ret += SumMultiple<T>(n, rad_factor) * mu;
  }
  return ret;
}

template <typename T = int64>
SL T SumCoprime(int64 n, const IntegerFactorization& f) {
  if (n == 0) {
    return 0;
  }
  T ret = 0;
  for (const auto [rad_factor, mu] : GetRadFactorsWithMu(f, n)) {
    ret += SumMultiple<T>(n, rad_factor) * mu;
  }
  return ret;
}

template <typename T = int64>
SL T SumCoprime(int64 n, int64 a) {
  if (n == 0) {
    return 0;
  }
  T ret = 0;
  for (const auto [rad_factor, mu] : GetRadFactorsWithMu(a, n)) {
    ret += SumMultiple<T>(n, rad_factor) * mu;
  }
  return ret;
}

// Returns the sum x in the range [1, n] such that gcd(x, a) = 1 and x =
// remain mod(mod) The rad factors with mu are given by rad_factors_with_mu.
// The rad factors with mu are given by rad_factors_with_mu.
template <typename T = int64>
SL T SumCoprime(int64 n,
                const std::vector<std::pair<int64, int>>& rad_factors_with_mu,
                int64 remain, int64 mod) {
  if (n == 0) {
    return 0;
  }
  T ret = 0;
  for (const auto [rad_factor, mu] : rad_factors_with_mu) {
    ret += SumModValue<T>(n, remain, mod, 0, rad_factor) * mu;
  }
  return ret;
}

template <typename T = int64>
SL T SumCoprime(int64 n, const IntegerFactorization& f, int64 remain,
                int64 mod) {
  if (n == 0) {
    return 0;
  }
  T ret = 0;
  for (const auto [rad_factor, mu] : GetRadFactorsWithMu(f, n)) {
    ret += SumModValue<T>(n, remain, mod, 0, rad_factor) * mu;
  }
  return ret;
}

template <typename T = int64>
SL T SumCoprime(int64 n, int64 a, int64 remain, int64 mod) {
  if (n == 0) {
    return 0;
  }
  T ret = 0;
  for (const auto [rad_factor, mu] : GetRadFactorsWithMu(a, n)) {
    ret += SumModValue<T>(n, remain, mod, 0, rad_factor) * mu;
  }
  return ret;
}

// dest[0] = 0
// dest[1] = 1
// dest[2] = 1 / 2
// dest[maxn-1] = 1 / (maxn-1)
// dest[maxn] = 1 / maxn
//
// maxn can be greater than or equal to mod
template <typename IT, typename TM>
SL REQUIRES((!IsNModNumberV<typename std::iterator_traits<IT>::value_type>))
    RETURN(void) InitInverse(IT dest, int64 maxn, TM mod) {
  PE_ASSERT(maxn >= 0);
  IT start = dest;
  *dest++ = 0;
  if (maxn >= 1) {
    *dest++ = 1;
  }
  using T = typename std::iterator_traits<IT>::value_type;
  int64 maxi = std::min(maxn, static_cast<int64>(mod) - 1);
  for (int64 i = 2; i <= maxi; ++i) {
    const auto t = mod / i;
    const auto k = mod % i;
    const auto v = MulMod(t, t, mod);
    const auto u = MulMod(start[k], start[k], mod);
    *dest++ = static_cast<T>(MulMod(i, MulMod(v, u, mod), mod));
  }
  for (auto i = mod; i <= maxn; ++i) {
    *dest++ = start[i - mod];
  }
}

template <typename T, typename TM>
SL REQUIRES((!IsNModNumberV<T>)) RETURN(void)
    InitInverse(Span<T> dest, TM mod) {
  InitInverse<T*, TM>(std::data(dest), std::size(dest) - 1, mod);
}

template <typename IT>
SL REQUIRES((IsNModNumberV<typename std::iterator_traits<IT>::value_type>))
    RETURN(void) InitInverse(IT dest, int64 maxn) {
  PE_ASSERT(maxn >= 0);
  IT start = dest;
  *dest++ = 0;
  if (maxn >= 1) {
    *dest++ = 1;
  }
  using T = typename std::iterator_traits<IT>::value_type;
  using ModType = typename T::ints;
  const ModType mod = T().Mod();
  int64 maxi = std::min(maxn, static_cast<int64>(mod) - 1);
  for (int64 i = 2; i <= maxi; ++i) {
    const auto t = mod / i;
    const auto k = mod % i;
    const auto v = MulMod(t, t, mod);
    const auto u = start[k] * start[k];
    *dest++ = u * v * i;
  }
  for (auto i = mod; i <= maxn; ++i) {
    *dest++ = start[i - mod];
  }
}

template <typename T>
SL REQUIRES((IsNModNumberV<T>)) RETURN(void) InitInverse(Span<T> dest) {
  InitInverse<T*>(std::data(dest), std::size(dest) - 1);
}

// 1 <= s <= e
//
// dest[0] = 1
// dest[1] = s
// dest[2] = s(s+1)
// dest[e-s+1]=s(s+1)...e
// idest[0] = 1
// idest[1] = 1/s
// idest[2] = 1/(s(s+1))
// idest[e-s+1]=1/(s(s+1)...e)
template <typename T>
SL REQUIRES((!IsNModNumberV<T>)) RETURN(void)
    InitSeqProd2(T* dest, T* idest, int64 s, int64 e, T mod) {
  if (dest == nullptr && idest == nullptr) {
    return;
  }

  const int64 cnt = static_cast<int64>(e - s + 1);
  if (mod == 1) {
    if (dest != nullptr) {
      std::fill(dest, dest + cnt + 1, 0);
    }
    if (idest != nullptr) {
      std::fill(idest, idest + cnt + 1, 0);
    }
    return;
  }

  T lastv = 1;
  if (dest == nullptr) {
    T v = s % mod;
    for (int64 i = s; i <= e; ++i) {
      lastv = MulMod(lastv, v, mod);
      v = v == mod - 1 ? 0 : v + 1;
    }
  } else {
    dest[0] = lastv;
    T v = s % mod;
    for (int64 i = s, j = 1; i <= e; ++i, ++j) {
      dest[j] = lastv = MulMod(lastv, v, mod);
      v = v == mod - 1 ? 0 : v + 1;
    }
  }
  if (idest == nullptr) {
    return;
  }

  // Assumption 1: mod is a prime number
  // Assumption 2: lastv != 0
  lastv = PowerMod(lastv, mod - 2, mod);
  idest[0] = 1;
  idest[cnt] = lastv;

  T v = e % mod;
  for (int64 j = cnt - 1; j > 0; --j) {
    idest[j] = MulMod(idest[j + 1], v, mod);
    v = v == 0 ? mod - 1 : v - 1;
  }
}

template <typename T>
SL REQUIRES((!IsNModNumberV<T>)) RETURN(void)
    InitSeqProd2(T* dest, T* idest, int64 e, T mod) {
  InitSeqProd2<T>(dest, idest, 1, e, mod);
}

template <typename T>
SL REQUIRES((!IsNModNumberV<T>)) RETURN(void)
    InitSeqProd2(Span<T> dest, Span<T> idest, T mod) {
  const int64 size1 = std::size(dest);
  const int64 size2 = std::size(idest);
  PE_ASSERT(size1 == size2);
  InitSeqProd2<T>(std::data(dest), std::data(idest), 1, size1 - 1, mod);
}

template <typename T>
SL REQUIRES((IsNModNumberV<T>)) RETURN(void)
    InitSeqProd2(T* dest, T* idest, int64 s, int64 e) {
  if (dest == nullptr && idest == nullptr) {
    return;
  }

  using ModType = typename T::ints;
  const ModType mod = T().Mod();
  const int64 cnt = static_cast<int64>(e - s + 1);
  if (mod == 1) {
    return;
  }

  ModType lastv = 1;
  if (dest == nullptr) {
    ModType v = s % mod;
    for (int64 i = s; i <= e; ++i) {
      lastv = MulMod(lastv, v, mod);
      v = v == mod - 1 ? 0 : v + 1;
    }
  } else {
    dest[0].SetValue(lastv);
    ModType v = s % mod;
    for (int64 i = s, j = 1; i <= e; ++i, ++j) {
      lastv = MulMod(lastv, v, mod);
      dest[j].SetValue(lastv);
      v = v == mod - 1 ? 0 : v + 1;
    }
  }
  if (idest == nullptr) {
    return;
  }

  // Assumption 1: mod is a prime number
  // Assumption 2: lastv != 0
  lastv = PowerMod(lastv, mod - 2, mod);
  idest[0] = 1;
  idest[cnt].SetValue(lastv);

  ModType v = e % mod;
  for (int64 j = cnt - 1; j > 0; --j) {
    idest[j].SetValue(MulMod(idest[j + 1].value(), v, mod));
    v = v == 0 ? mod - 1 : v - 1;
  }
}

template <typename T>
SL REQUIRES((IsNModNumberV<T>)) RETURN(void)
    InitSeqProd2(T* dest, T* idest, int64 e) {
  InitSeqProd2<T>(dest, idest, 1, e);
}

template <typename T>
SL REQUIRES((IsNModNumberV<T>)) RETURN(void)
    InitSeqProd2(Span<T> dest, Span<T> idest) {
  const int64 size1 = std::size(dest);
  const int64 size2 = std::size(idest);
  PE_ASSERT(size1 == size2);
  InitSeqProd2<T>(std::data(dest), std::data(idest), 1, size1 - 1);
}

template <typename IT, typename T, typename G>
SL void GenerateSequence(IT first, int64 maxn, T init, const G& gen) {
  if (maxn < 0) {
    return;
  }

  T value = init;
  *first++ = init;

  for (int64 i = 1; i <= maxn; ++i) {
    value = gen(value);
    *first++ = value;
  }
}

template <typename T, typename G>
SL void GenerateSequence(Span<T> target, T init, const G& gen) {
  GenerateSequence(std::data(target), static_cast<int64>(std::size(target)) - 1,
                   init, gen);
}

template <typename T, int D>
SL REQUIRES((!IsNModNumberV<T>)) RETURN(void)
    InitComb(T (*comb)[D], int maxn, int64 mod) {
  const int64 ONE = 1 % mod;
  for (int i = 0; i <= maxn; ++i) {
    for (int j = 1; j < i; ++j) {
      comb[i][j] = AddMod(comb[i - 1][j - 1], comb[i - 1][j], mod);
    }
    comb[i][0] = comb[i][i] = ONE;
  }
}

template <typename T, int D>
SL REQUIRES((!IsNModNumberV<T>)) RETURN(void)
    InitComb(T (*comb)[D], int64 mod) {
  InitComb(comb, D - 1, mod);
}

template <typename T, int D>
SL REQUIRES((IsNModNumberV<T>)) RETURN(void) InitComb(T (*comb)[D], int maxn) {
  const T ONE = 1;
  for (int i = 0; i <= maxn; ++i) {
    for (int j = 1; j < i; ++j) {
      comb[i][j] = comb[i - 1][j - 1] + comb[i - 1][j];
    }
    comb[i][0] = comb[i][i] = ONE;
  }
}

template <typename T, int D>
SL REQUIRES((IsNModNumberV<T>)) RETURN(void) InitComb(T (*comb)[D]) {
  InitComb(comb, D - 1);
}

// Checks whether x is the primitive root of p while  the factorization of p -1
// is f.
SL bool IsPrimitiveRoot(int64 x, int64 p, const IntegerFactorization& f) {
  return std::none_of(std::begin(f), std::end(f),
                      [=](const std::pair<int64, int>& it) {
                        return PowerMod(x, (p - 1) / it.first, p) == 1;
                      });
}

// Checks whether x is the primitive root of p.
SL bool IsPrimitiveRoot(int64 x, int64 p) {
  return IsPrimitiveRoot(x, p, Factorize(p - 1));
}

SL int64 FindPrimitiveRoot(int64 p) {
  if (p <= 1) return -1;
  if (p == 2) return 1;
  IntegerFactorization fp1 = Factorize(p - 1);
  for (int64 i = 2;; ++i) {
    if (IsPrimitiveRoot(i, p, fp1)) return i;
  }
  return -1;
}

SL int64 FindPrimitiveRoot(int64 p, const IntegerFactorization& fp1) {
  if (p <= 1) return -1;
  if (p == 2) return 1;
  for (int64 i = 2;; ++i) {
    if (IsPrimitiveRoot(i, p, fp1)) return i;
  }
  return -1;
}

SL int64 Ind(int64 a, int64 pr, int64 p) {
  using map_t = std::unordered_map<int64, int>;
  PE_ASSERT(a > 0);
  int64 inv_pr = ModInv(pr, p);
  int64 mx = static_cast<int64>(std::sqrt(double(p - 1) + 0.5));
  if (mx * mx != p - 1) ++mx;
  map_t mem;
  int64 t1 = 1, t2 = a;
  for (int i = 0; i <= mx - 1; ++i) {
    mem[t2] = i;
    t2 = t2 * inv_pr % p;
  }
  const int64 temp = PowerMod(pr, mx, p);
  for (int i = 0; i <= mx - 1; ++i) {
    auto where = mem.find(t1);
    if (where != mem.end()) {
      return i * mx + where->second;
    }
    t1 = t1 * temp % p;
  }
  return -1;
}

class IndSolver {
  static int64 SquareRootForInd(int64 x) {
    int64 ret = static_cast<int64>(std::sqrt(double(x)));
    if (ret * ret < x) ++ret;
    PE_ASSERT(ret * ret >= x);
    return ret;
  }

 public:
  IndSolver(const int64 p, int64 pr = -1)
      : p_(p),
        pr_(pr < 0 ? FindPrimitiveRoot(p) : pr),
        mx_(SquareRootForInd(p_ - 1)) {
    const int64 inv_pr = ModInv(pr_, p);
    int64 t = 1;
    for (int i = 0; i <= mx_ - 1; ++i) {
      mem_[t] = i;
      t = t * inv_pr % p_;
    }
  }

  int64 operator()(int64 a) const { return Cal(a); }

  int64 Cal(int64 a) const {
    PE_ASSERT(a > 0);
    a %= p_;

    const int64 temp = PowerMod(pr_, mx_, p_);
    const int64 inv_a = ModInv(a, p_);
    int64 t = 1;

    for (int i = 0; i <= mx_ - 1; ++i) {
      auto where = mem_.find(MulMod(t, inv_a, p_));
      if (where != mem_.end()) {
        return i * mx_ + where->second;
      }
      t = t * temp % p_;
    }

    return -1;
  }

  int64 pr() const { return pr_; }

 private:
  const int64 p_;
  const int64 pr_;
  const int64 mx_;
  std::unordered_map<int64, int> mem_;
};

namespace flint {
#if ENABLE_FLINT && GMP_LIMB_BITS == 64
std::vector<int64> SquareRootMod(int64 n, const IntegerFactorization& mod_f) {
  const int size = static_cast<int>(std::size(mod_f));
  n_factor_t ff;
  for (int i = 0; i < size; ++i) {
    ff.p[i] = mod_f[i].first;
    ff.exp[i] = mod_f[i].second;
  }
  ff.num = size;

  ulong* ans;
  int cnt = static_cast<int>(n_sqrtmodn(&ans, n, &ff));
  if (cnt == 0) return {};

  std::vector<int64> ret(ans, ans + cnt);
  flint_free(ans);

  return ret;
}

std::vector<int64> SquareRootMod(int64 n, int64 mod) {
  return SquareRootMod(n, Factorize(mod));
}

namespace pmod {
std::vector<int64> SquareRootMod(int64 n, int64 p, int e = 1) {
  ulong* ans;
  int cnt = static_cast<int>(n_sqrtmod_primepow(&ans, n, p, e));
  if (cnt == 0) return {};

  std::vector<int64> ret(ans, ans + cnt);
  flint_free(ans);

  return ret;
}
}  // namespace pmod
#define HAS_SQUARE_ROOT_MOD_FLINT 1
#else
#define HAS_SQUARE_ROOT_MOD_FLINT 0
#endif
}  // namespace flint

namespace pmod {
namespace internal {
// returns x where x^2 = n mod p
// if no solution, return -1.
// https://en.wikipedia.org/wiki/Tonelli%E2%80%93Shanks_algorithm
SL int64 SquareRootModImpl(int64 n, int64 p) {
  if (p == 2) {
    return n & 1;
  }
  if (n == 0) {
    return 0;
  }
  if (n == 1) {
    return 1;
  }
  if (PowerMod(n, (p - 1) / 2, p) == p - 1) {
    return -1;
  }
  if (p % 4 == 3) {
    return PowerMod(n, (p + 1) >> 2, p);
  }
  int64 Q = p - 1, S = 0;
  while (Q % 2 == 0) Q >>= 1, ++S;
  int64 z = 1;
  while (PowerMod(z, (p - 1) >> 1, p) == 1) ++z;
  int64 M = S, c = PowerMod(z, Q, p);
  int64 t = PowerMod(n, Q, p), R = PowerMod(n, (Q + 1) >> 1, p);
  for (;;) {
    if (t == 0) return -1;
    if (t == 1) return R;
    int64 i = 0, tt = t;
    while (tt != 1) tt = MulMod(tt, tt, p), ++i;
    const int64 b = PowerMod(c, 1 << (M - i - 1), p);
    M = i;
    c = MulMod(b, b, p);
    t = MulMod(t, c, p);
    R = MulMod(R, b, p);
  }
}
}  // namespace internal

SL std::vector<int64> SquareRootMod(int64 n, int64 p) {
  const int64 x = internal::SquareRootModImpl(n, p);
  if (x != -1) {
    const int64 y = x == 0 ? 0 : p - x;
    if (x == y) {
      return {x};
    } else {
      return {x, y};
    }
  } else {
    return {};
  }
}

SL std::vector<int64> RootMod(int64 a, int64 n, int64 p,
                              const int64 returned_count = -1) {
  if (p == 2) {
    return {a};
  }
  if (a == 0) {
    return {0};
  }
  IndSolver sv(p);
  const int64 r = sv(a);
  if (r == -1) return {};
  // x^n = a mod p
  // n log_x = r mod q
  const int64 q = p - 1;
  ModValue<int64> t = SolveLinearEquation(n % q, r % q, q);
  if (!t.ok) {
    return {};
  }
  std::vector<int64> result;
  int64 coe = PowerMod(sv.pr(), t.mod, p);
  int64 x = PowerMod(sv.pr(), t.value, p);
  int64 oldx = x;
  do {
    if (returned_count < 0 ||
        static_cast<int64>(std::size(result)) < returned_count) {
      result.push_back(x);
    } else {
      break;
    }
    x = MulMod(x, coe, p);
  } while (oldx != x);
  return result;
}
}  // namespace pmod

// (x+yi)(a+bi)
SL void GaussMul(int64& x, int64& y, int64 a, int64 b) {
  const int64 xx = x * a - b * y;
  const int64 yy = x * b + a * y;
  x = xx, y = yy;
}

#if PE_HAS_INT128
namespace internal {
SL void FactorizeForTwoSquaresByPmask(int64 n, IntegerFactorization& ret) {
  while (n != 1) {
    int now = pmask[n];
    int c = 0;
    while (n % now == 0) n /= now, ++c;
    if (c) {
      if ((now & 3) == 3) {
        if (IsOdd(c)) {
          IntegerFactorization{}.swap(ret);
          return;
        }
      }
      ret.emplace_back(static_cast<int64>(now), c);
    }
  }
}

// n > 2
SL IntegerFactorization FactorizeForTwoSquares(int64 n) {
  IntegerFactorization ret;

  int p2 = 0;
  while (IsEven(n)) n >>= 1, ++p2;
  if (p2 > 0) {
    ret.emplace_back(2LL, p2);
  }

  for (int i = 1; i < pcnt; ++i) {
    if (n <= maxp) {
      FactorizeForTwoSquaresByPmask(n, ret);
      return ret;
    }
    const int64 p = plist[i];
    const int64 test = p * p;
    if (test > n) break;
    int c = 0;
    while (n % p == 0) n /= p, ++c;
    if (c) {
      if ((p & 3) == 3) {
        if (IsOdd(c)) {
          return IntegerFactorization();
        }
      }
      ret.emplace_back(p, c);
    }
  }
  if (n != 1) {
    if ((n & 3) == 3) {
      return IntegerFactorization();
    }
    ret.emplace_back(n, 1);
  }
  return ret;
}
}  // namespace internal

// 4k+1 primes p = x^2+y^2 (x >= 0, y >= 0)
// 2 = 1^2 + 1^2
// 0, 1 are handled as special case.
SL std::vector<std::pair<int64, int64>> PrimeTwoSquares(const int64 p) {
  if (p == 0) {
    return {{0LL, 0LL}};
  } else if (p == 1) {
    return {{0LL, 1LL}};
  } else if (p == 2) {
    return {{1LL, 1LL}};
  }
  if ((p & 3) != 1) {
    return {};
  }
  int128 y = 1, x = 2;
  for (x = 2; PowerMod(x, (p - 1) >> 1, p) != p - 1; ++x) {
    ;
  }
  x = PowerMod(x, (p - 1) >> 2, p);

  for (int128 s = x * x + y * y; s != p;) {
    const int128 k = s / p, k2 = k >> 1;
    int128 a = (x % k + k) % k, b = (y % k + k) % k;
    if (a > k2) a = k - a;
    if (b > k2) b = k - b;
    if ((x * a + y * b) % k) std::swap(a, b);
    const int128 u = (x * a + y * b) / k, v = (b * x - a * y) / k;
    x = u, y = v;
    s = x * x + y * y;
  }
  if (y < 0) y = -y;
  if (x < 0) x = -x;
  if (x > y) std::swap(x, y);
  return {{x, y}};
}

namespace internal {
SL void TwoSquaresImpl(int now, const IntegerFactorization& f, int64 u, int64 v,
                       std::vector<std::pair<int64, int64>>& result) {
  if (now == static_cast<int>(std::size(f))) {
    u = Abs(u), v = Abs(v);
    if (u > v) std::swap(u, v);
    result.emplace_back(u, v);
  } else {
    const std::pair<int64, int>& item = f[now];
    if (item.first == 2) {
      for (int i = 0; i < item.second; ++i) {
        GaussMul(u, v, 1, 1);
      }
      TwoSquaresImpl(now + 1, f, u, v, result);
    } else if ((item.first & 3) == 3) {
      const int64 t = item.first;
      int64 me = 1;
      for (int i = 0, j = item.second >> 1; i < j; ++i) me *= t;
      TwoSquaresImpl(now + 1, f, u * me, v * me, result);
    } else {
      std::vector<std::pair<int64, int64>> t = PrimeTwoSquares(item.first);
      const int64 a = t[0].first, b = t[0].second;
      std::vector<std::pair<int64, int64>> U, V;
      {
        int64 x = 1, y = 0;
        for (int i = 0; i <= item.second; ++i) {
          U.emplace_back(x, y);
          GaussMul(x, y, a, b);
        }
        x = 1, y = 0;
        for (int i = 0; i <= item.second; ++i) {
          V.emplace_back(x, y);
          GaussMul(x, y, a, -b);
        }
      }
      for (int i = 0, j = item.second; i <= item.second; ++i, --j) {
        int64 uu = u, vv = v;
        GaussMul(uu, vv, U[i].first, U[i].second);
        GaussMul(uu, vv, V[j].first, V[j].second);
        TwoSquaresImpl(now + 1, f, uu, vv, result);
      }
    }
  }
}

SL std::vector<std::pair<int64, int64>> TwoSquaresImpl(
    const IntegerFactorization& f) {
  std::vector<std::pair<int64, int64>> ret;
  TwoSquaresImpl(0, f, 1, 0, ret);
  std::sort(std::begin(ret), std::end(ret));
  ret.resize(unique(ret.begin(), ret.end()) - ret.begin());
  return ret;
}
}  // namespace internal

SL std::vector<std::pair<int64, int64>> TwoSquares(
    const IntegerFactorization& f) {
  for (const std::pair<int64, int>& iter : f) {
    if ((iter.first & 3) == 3) {
      if (IsOdd(iter.second)) {
        return {};
      }
    }
  }
  return internal::TwoSquaresImpl(f);
}

// Represent n as two squares: n = x^2 + y^2 where 0 <= x <= y.
SL std::vector<std::pair<int64, int64>> TwoSquares(const int64 n) {
  if (n == 0) {
    return {{0LL, 0LL}};
  } else if (n == 1) {
    return {{0LL, 1LL}};
  } else if (n == 2) {
    return {{1LL, 1LL}};
  }
  IntegerFactorization f = internal::FactorizeForTwoSquares(n);
  if (std::empty(f)) {
    return {};
  }
  return internal::TwoSquaresImpl(f);
}

SL void ExpandTwoSquares(std::vector<std::pair<int64, int64>>& ret,
                         std::pair<int64, int64> p) {
  ret.emplace_back(p.first, p.second);
  if (p.first != 0) {
    ret.emplace_back(-p.first, p.second);
  }
  if (p.second != 0) {
    ret.emplace_back(p.first, -p.second);
  }
  if (p.first != 0 && p.second != 0) {
    ret.emplace_back(-p.first, -p.second);
  }
}

SL std::vector<std::pair<int64, int64>> TwoSquaresFull(const int64 n) {
  if (n == 0) {
    return {{0LL, 0LL}};
  }
  std::vector<std::pair<int64, int64>> tmp = TwoSquares(n);
  std::vector<std::pair<int64, int64>> ret;
  ret.reserve(std::size(tmp) * 4);
  for (const std::pair<int64, int64>& iter : tmp) {
    ExpandTwoSquares(ret, iter);
    if (iter.first != iter.second) {
      ExpandTwoSquares(ret, {iter.second, iter.first});
    }
  }
  return ret;
}
#endif

template <typename T>
SL std::vector<int> ToBaseK(T n, int k, int width = 0) {
  if (n == 0) {
    return width <= 1 ? std::vector<int>{0} : std::vector<int>(width, 0);
  }
  PE_ASSERT(n >= 0 || k < 0);
  PE_ASSERT(Abs(k) >= 2);
  if (width <= 0) {
    std::vector<int> ret;
    while (n != 0) {
      int m = n % k;
      n /= k;
      if (m < 0) {
        m -= k;
        ++n;
      }
      ret.push_back(m);
    }
    return ret;
  } else {
    std::vector<int> ret(width, 0);
    for (int i = 0; i < width; ++i) {
      int m = n % k;
      n /= k;
      if (m < 0) {
        m -= k;
        ++n;
      }
      ret[i] = m;
    }
    return ret;
  }
}

template <typename T>
SL T FromBaseK(const std::vector<int>& vec, int k) {
  T ret = 0;
  const int size = static_cast<int>(std::size(vec));
  for (int i = size - 1; i >= 0; --i) ret = ret * k + vec[i];
  return ret;
}

SL std::pair<std::vector<int64>,
             std::vector<std::vector<std::pair<int64, int>>>>
Sieve(int64 start, int64 end) {
  std::vector<int64> sieve(end - start + 1);
  std::vector<std::vector<std::pair<int64, int>>> factorization(
      end - start + 1, std::vector<std::pair<int64, int>>());
  for (int64 i = start; i <= end; ++i) {
    sieve[i - start] = i;
  }

  int64 sqrt_n = SqrtI(end);

  for (int i = 0; i < pcnt; ++i) {
    const int64 p = plist[i];
    if (p > sqrt_n) {
      break;
    }
    int64 pos = start / p * p;
    while (pos < start) pos += p;
    for (;; pos += p) {
      if (pos > end) {
        break;
      }
      int c = 0;
      while (sieve[pos - start] % p == 0) {
        sieve[pos - start] /= p, ++c;
      }
      if (c > 0) {
        factorization[pos - start].push_back({p, c});
      }
    }
  }

  for (int64 i = start; i <= end; ++i) {
    if (i > 1 && sieve[i - start] != 1) {
      factorization[i - start].push_back({sieve[i - start], 1});
    }
  }
  return {std::move(sieve), std::move(factorization)};
}

namespace internal {
template <typename ST = int64, typename TT = ST>
struct OperationTraitsWithMod {
  using RetType = TT;
  using SourceArgT = make_const_arg_type_t<ST>;
  using TargetArgT = make_const_arg_type_t<TT>;

  OperationTraitsWithMod(TargetArgT mod) : mod_(mod) {}

  static TT Cast(SourceArgT a) { return TT(ExtractValue(a)); }

  TT Value(SourceArgT a) const { return Mod(Cast(a), mod_); }
  TT Value(TargetArgT a) const { return Mod(a, mod_); }

  TT Add(SourceArgT a, SourceArgT b) const {
    return AddMod(Value(a), Value(b), mod_);
  }
  TT Add(TargetArgT a, SourceArgT b) const {
    return AddMod(Value(a), Value(b), mod_);
  }
  TT Add(SourceArgT a, TargetArgT b) const {
    return AddMod(Value(a), Value(b), mod_);
  }
  TT Add(TargetArgT a, TargetArgT b) const {
    return AddMod(Value(a), Value(b), mod_);
  }

  TT Sub(SourceArgT a, SourceArgT b) const {
    return SubMod(Value(a), Value(b), mod_);
  }
  TT Sub(TargetArgT a, SourceArgT b) const {
    return SubMod(Value(a), Value(b), mod_);
  }
  TT Sub(SourceArgT a, TargetArgT b) const {
    return SubMod(Value(a), Value(b), mod_);
  }
  TT Sub(TargetArgT a, TargetArgT b) const {
    return SubMod(Value(a), Value(b), mod_);
  }

  TT Mul(SourceArgT a, SourceArgT b) const {
    return MulMod(Value(a), Value(b), mod_);
  }
  TT Mul(TargetArgT a, SourceArgT b) const {
    return MulMod(Value(a), Value(b), mod_);
  }
  TT Mul(SourceArgT a, TargetArgT b) const {
    return MulMod(Value(a), Value(b), mod_);
  }
  TT Mul(TargetArgT a, TargetArgT b) const {
    return MulMod(Value(a), Value(b), mod_);
  }

 private:
  const TT mod_;
};

template <typename TT>
struct OperationTraitsWithMod<TT, TT> {
  using RetType = TT;
  using SourceArgT = make_const_arg_type_t<TT>;
  using TargetArgT = make_const_arg_type_t<TT>;

  OperationTraitsWithMod(TargetArgT mod) : mod_(mod) {}

  static TT Cast(TargetArgT a) { return a; }

  TT Value(TargetArgT a) const { return Mod(a, mod_); }

  TT Add(TargetArgT a, TargetArgT b) const {
    return AddMod(Value(a), Value(b), mod_);
  }
  TT Sub(TargetArgT a, TargetArgT b) const {
    return SubMod(Value(a), Value(b), mod_);
  }
  TT Mul(TargetArgT a, TargetArgT b) const {
    return MulMod(Value(a), Value(b), mod_);
  }

 private:
  const TT mod_;
};

template <typename ST = int64, typename TT = ST>
struct OperationTraits {
  using RetType = TT;
  using SourceArgT = make_const_arg_type_t<ST>;
  using TargetArgT = make_const_arg_type_t<TT>;

  static TT Cast(SourceArgT a) { return TT(ExtractValue(a)); }
  static TT Value(SourceArgT a) { return Cast(a); }
  static TT Value(TargetArgT a) { return a; }

  static TT Add(SourceArgT a, SourceArgT b) { return Value(a) + Value(b); }
  static TT Add(TargetArgT a, SourceArgT b) { return Value(a) + Value(b); }
  static TT Add(SourceArgT a, TargetArgT b) { return Value(a) + Value(b); }
  static TT Add(TargetArgT a, TargetArgT b) { return Value(a) + Value(b); }

  static TT Sub(SourceArgT a, SourceArgT b) { return Value(a) - Value(b); }
  static TT Sub(TargetArgT a, SourceArgT b) { return Value(a) - Value(b); }
  static TT Sub(SourceArgT a, TargetArgT b) { return Value(a) - Value(b); }
  static TT Sub(TargetArgT a, TargetArgT b) { return Value(a) - Value(b); }

  static TT Mul(SourceArgT a, SourceArgT b) { return Value(a) * Value(b); }
  static TT Mul(TargetArgT a, SourceArgT b) { return Value(a) * Value(b); }
  static TT Mul(SourceArgT a, TargetArgT b) { return Value(a) * Value(b); }
  static TT Mul(TargetArgT a, TargetArgT b) { return Value(a) * Value(b); }
};

template <typename TT>
struct OperationTraits<TT, TT> {
  using RetType = TT;
  using SourceArgT = make_const_arg_type_t<TT>;
  using TargetArgT = make_const_arg_type_t<TT>;

  static TT Cast(TargetArgT a) { return a; }
  static TT Value(TargetArgT a) { return a; }

  static TT Add(TargetArgT a, TargetArgT b) { return a + b; }
  static TT Sub(TargetArgT a, TargetArgT b) { return a - b; }
  static TT Mul(TargetArgT a, TargetArgT b) { return a * b; }
};
}  // namespace internal

// Calculates (1 + 2 + 3 + ... + n) % mod.
SL int64 P1SumMod(int64 n, int64 mod) {
  if (n == 0) return 0;
  if (n < 0) return Mod(-P1SumMod(-n, mod), mod);
  return n & 1 ? MulMod(((n + 1) >> 1) % mod, n % mod, mod)
               : MulMod((n >> 1) % mod, (n + 1) % mod, mod);
}

// Calculates sum of arithmetic progression modulo mod.
// a <= b, a + delta, a + 2 delta, ..., a + maxk detla <= b for delta >= 0 or
// a >= b, a + delta, a + 2 delta, ..., a + maxk delta >= b for delta < 0
SL int64 P1SumModEx(int64 a, int64 b, int64 mod, int64 delta = 1) {
  if (delta == 0) {
    PE_ASSERT(a == b);
    return a;
  }
  if (delta > 0 && a > b) return 0;
  if (delta < 0 && a < b) return 0;
  const int64 maxk = (b - a) / delta;
  PE_ASSERT(maxk >= 0);
  const int64 t0 = MulMod((maxk + 1) % mod, Mod(a, mod), mod);
  // delta, 2 delta, maxk delta
  const int64 t1 = MulMod(Mod(delta, mod), P1SumMod(maxk, mod), mod);
  return AddMod(t0, t1, mod);
}

template <typename T = int64>
SL T P1Sum(int64 n) {
  return n & 1 ? T((n + 1) >> 1) * n : T(n >> 1) * (n + 1);
}

namespace internal {
template <typename AP>
SL typename AP::RetType P2SumImpl(int64 n, const AP& ap) {
  if (n <= 0) return 0;
  // n*(n + 1)*(2 n + 1)/6
  int64 a = n, b = n + 1, c = 2 * n + 1;
  switch (n % 6) {
    case 0:
      a /= 6;
      break;
    case 1:
      b >>= 1, c /= 3;
      break;
    case 2:
      a >>= 1, b /= 3;
      break;
    case 3:
      a /= 3, b >>= 1;
      break;
    case 4:
      a >>= 1, c /= 3;
      break;
    case 5:
      b /= 6;
      break;
  }
  return ap.Mul(a, ap.Mul(b, c));
}
}  // namespace internal

// Calculates (1^2 + 2^2 + 3^2 + ... + n^2) % mod.
// Assume no overflow for 2 * n + 1.
SL int64 P2SumMod(int64 n, int64 mod) {
  return internal::P2SumImpl(
      n, internal::OperationTraitsWithMod<int64, int64>(mod));
}

template <typename T = int64>
SL T P2Sum(int64 n) {
  return internal::P2SumImpl(n, internal::OperationTraits<int64, T>());
}

// Calculates (1^3 + 2^3 + 3^3 + ... + n^3) % mod.
SL int64 P3SumMod(int64 n, int64 mod) {
  if (n <= 0) return 0;
  // (n*(n + 1)/2)^2
  const int64 a = P1SumMod(n, mod);
  return MulMod(a, a, mod);
}

template <typename T = int64>
SL T P3Sum(int64 n) {
  if (n <= 0) return 0;
  const T t = P1Sum<T>(n);
  return t * t;
}

namespace internal {
template <typename AP>
SL typename AP::RetType P4SumImpl(int64 n, const AP& ap) {
  using RetType = typename AP::RetType;

  if (n <= 0) return 0;
  // (3*n*(n + 1) - 1)*(2*n + 1)*(n + 1)*n/30
  // Handle (2*n + 1)*(n + 1)*n/6
  int64 a = n, b = n + 1, c = 2 * n + 1;
  switch (n % 6) {
    case 0:
      a /= 6;
      break;
    case 1:
      b >>= 1, c /= 3;
      break;
    case 2:
      a >>= 1, b /= 3;
      break;
    case 3:
      a /= 3, b >>= 1;
      break;
    case 4:
      a >>= 1, c /= 3;
      break;
    case 5:
      b /= 6;
      break;
  }
  int done = 0;
  if (!done && a % 5 == 0) a /= 5, done = 1;
  if (!done && b % 5 == 0) b /= 5, done = 1;
  if (!done && c % 5 == 0) c /= 5, done = 1;
  const RetType d = ap.Mul(a, ap.Mul(b, c));
  if (done) {
    const RetType t0 = ap.Mul(n, n + 1);
    const RetType t1 =
        ap.Sub(ap.Mul(static_cast<int64>(3), t0), static_cast<int64>(1));
    return ap.Mul(d, t1);
  }
  // Handle (3*n*n + 3*n - 1)/5
  switch (n % 5) {
    // 3*n*n + 3*n - 1 =
    // 3*(n - 1)*(n - 1) + 5*n + 4*(n - 1)
    // (n - 1)*(3*(n - 1) + 4) + 5*n
    // (n - 1)*(3 n + 1) + 5*n
    case 1: {
      const RetType t0 =
          ap.Add(ap.Mul(static_cast<int64>(3), n), static_cast<int64>(1));
      const RetType t1 = ap.Add(ap.Mul((n - 1) / 5, t0), n);
      return ap.Mul(d, t1);
    }
    // 3*n*n + 3*n - 1 =
    // 3*(n - 3)*(n - 3) + 7*(3*n - 4)
    // 3*(n - 3)*(n - 3) + 7*(3*(n - 3) + 5)
    // 3*(n - 3)*(n - 3) + 7*3*(n - 3) + 35
    // 3*(n - 3)*(n + 4) + 35
    case 3: {
      const RetType t0 =
          ap.Mul(static_cast<int64>(3), ap.Mul((n - 3) / 5, n + 4));
      const RetType t1 = ap.Add(t0, static_cast<int64>(7));
      return ap.Mul(d, t1);
    }
    default:
      PE_ASSERT(0);
  }
  return 0;
}
}  // namespace internal

// Calculates (1^4 + 2^4 + 3^4 + ... + n^4) % mod.
// Assume no overflow for 2 * n.
SL int64 P4SumMod(int64 n, int64 mod) {
  return internal::P4SumImpl(
      n, internal::OperationTraitsWithMod<int64, int64>(mod));
}

template <typename T = int64>
SL T P4Sum(int64 n) {
  return internal::P4SumImpl(n, internal::OperationTraits<int64, T>());
}

namespace internal {
template <typename AP>
SL typename AP::RetType P5SumImpl(int64 n, const AP& ap) {
  using RetType = typename AP::RetType;

  if (n <= 0) return 0;
  // n^2*(n + 1)^2*(2*n^2 + 2*n - 1)/12
  // Handle (n (n + 1))^2/4
  int64 a = n, b = n, c = n + 1, d = n + 1;
  if (n % 2 == 0) {
    a >>= 1, b >>= 1;
  } else {
    c >>= 1, d >>= 1;
  }
  int done = 0;
  if (!done && a % 3 == 0) a /= 3, done = 1;
  if (!done && c % 3 == 0) c /= 3, done = 1;
  const RetType e = ap.Mul(ap.Mul(a, b), ap.Mul(c, d));
  if (done) {
    const RetType t0 = ap.Add(n, n);
    const RetType t1 = ap.Mul(t0, n);
    const RetType t2 = ap.Sub(ap.Add(t0, t1), static_cast<int64>(1));
    return ap.Mul(e, t2);
  }
  // Handle (2*n^2 + 2*n - 1)/3
  // We have n%3 = 1
  // 2*n^2 + 2*n - 1 = 2*(n-1)^2 + 6n - 3
  const RetType t0 = ap.Mul((n - 1) / 3, n - 1);
  const RetType t1 = ap.Add(ap.Add(t0, t0), 2 * n - 1);
  return ap.Mul(e, t1);
}
}  // namespace internal

// Calculates (1^5 + 2^5 + 3^5 + ... + n^5) % mod.
// Assume no overflow for 2 * n.
SL int64 P5SumMod(int64 n, int64 mod) {
  return internal::P5SumImpl(
      n, internal::OperationTraitsWithMod<int64, int64>(mod));
}

template <typename T = int64>
SL T P5Sum(int64 n) {
  return internal::P5SumImpl(n, internal::OperationTraits<int64, T>());
}

namespace internal {
template <typename AP>
SL typename AP::RetType P6SumImpl(int64 n, const AP& ap) {
  using RetType = typename AP::RetType;

  if (n <= 0) return 0;
  // n*(1 + n)*(1 + 2*n)*(1 - 3*n + 6*n^3 + 3*n^4)/42
  // Handle n*(1 + n)*(1 + 2*n)/6
  // n*(n + 1)*(2*n + 1)/6
  int64 a = n, b = n + 1, c = 2 * n + 1;
  switch (n % 6) {
    case 0:
      a /= 6;
      break;
    case 1:
      b >>= 1, c /= 3;
      break;
    case 2:
      a >>= 1, b /= 3;
      break;
    case 3:
      a /= 3, b >>= 1;
      break;
    case 4:
      a >>= 1, c /= 3;
      break;
    case 5:
      b /= 6;
      break;
  }
  int done = 0;
  if (!done && a % 7 == 0) a /= 7, done = 1;
  if (!done && b % 7 == 0) b /= 7, done = 1;
  if (!done && c % 7 == 0) c /= 7, done = 1;
  const RetType d = ap.Mul(a, ap.Mul(b, c));
  if (done) {
    const RetType n1 = ap.Add(n, static_cast<int64>(0));
    const RetType n2 = ap.Mul(n1, n1);
    const RetType n3 = ap.Mul(n1, n2);
    const RetType n4 = ap.Mul(n2, n2);
    const RetType t0 = ap.Sub(ap.Add(n4, 2 * n3), n1);
    const RetType t1 =
        ap.Add(ap.Mul(static_cast<int64>(3), t0), static_cast<int64>(1));
    return ap.Mul(d, t1);
  }
  // Handle (1 - 3*n + 6*n^3 + 3*n^4)/7
  const RetType n1 = ap.Add(n, static_cast<int64>(0));
  const RetType n2 = ap.Mul(n1, n1);
  const RetType n3 = ap.Mul(n1, n2);
  switch (n % 7) {
    // 3*(2 + 3*n + 3*n^2 + n^3)*(n - 1) + 7
    case 1: {
      const RetType t0 =
          ap.Add(static_cast<int64>(2), ap.Mul(static_cast<int64>(3), n1));
      const RetType t1 = ap.Add(ap.Mul(static_cast<int64>(3), n2), n3);
      const RetType t2 =
          ap.Mul(ap.Mul(static_cast<int64>(3), ap.Add(t0, t1)), (n - 1) / 7);
      const RetType t3 = ap.Add(t2, static_cast<int64>(1));
      return ap.Mul(d, t3);
    }
    // 3*(15 + 8*n + 4*n^2 + n^3)*(n - 2) + 91
    case 2: {
      const RetType t0 =
          ap.Add(static_cast<int64>(15), ap.Mul(static_cast<int64>(8), n1));
      const RetType t1 = ap.Add(ap.Mul(static_cast<int64>(4), n2), n3);
      const RetType t2 =
          ap.Mul(ap.Mul(static_cast<int64>(3), ap.Add(t0, t1)), (n - 2) / 7);
      const RetType t3 = ap.Add(t2, static_cast<int64>(13));
      return ap.Mul(d, t3);
    }
    // 3*(-10 + 3 n - n^2 + n^3)*(n + 3) + 91
    case 4: {
      const RetType t0 =
          ap.Sub(ap.Mul(static_cast<int64>(3), n1), static_cast<int64>(10));
      const RetType t1 = ap.Sub(n3, n2);
      const RetType t2 =
          ap.Mul(ap.Mul(static_cast<int64>(3), ap.Add(t0, t1)), (n + 3) / 7);
      const RetType t3 = ap.Add(t2, static_cast<int64>(13));
      return ap.Mul(d, t3);
    }
    // 3*(-1 + n^3)*(n + 2) + 7
    case 5: {
      const RetType t0 =
          ap.Mul(static_cast<int64>(3), ap.Sub(n3, static_cast<int64>(1)));
      const RetType t1 = ap.Mul(t0, (n + 2) / 7);
      const RetType t2 = ap.Add(t1, static_cast<int64>(1));
      return ap.Mul(d, t2);
    }
    default:
      PE_ASSERT(0);
  }
  return 0;
}
}  // namespace internal

// Calculates (1^6 + 2^6 + 3^6 + ... + n^6) % mod.
// Assume no overflow for 2 * n.
SL int64 P6SumMod(int64 n, int64 mod) {
  return internal::P6SumImpl(
      n, internal::OperationTraitsWithMod<int64, int64>(mod));
}

template <typename T = int64>
SL T P6Sum(int64 n) {
  return internal::P6SumImpl(n, internal::OperationTraits<int64, T>());
}

namespace internal {
template <typename AP>
SL typename AP::RetType P7SumImpl(int64 n, const AP& ap) {
  using RetType = typename AP::RetType;

  if (n <= 0) return 0;
  // n^2 * (1 + n)^2 * (2 - 4 n - n^2 + 6 n^3 + 3 n^4)/24
  // Handle (n (n + 1))^2/4
  int64 a = n, b = n, c = n + 1, d = n + 1;
  if (n % 2 == 0) {
    a >>= 1, b >>= 1;
  } else {
    c >>= 1, d >>= 1;
  }
  int done3 = 0;
  if (!done3 && a % 3 == 0) a /= 3, done3 = 1;
  if (!done3 && c % 3 == 0) c /= 3, done3 = 1;
  // Handle (2 - 4 n - n^2 + 6 n^3 + 3 n^4)/6
  // Expand[1/6 (2 - 4 n - n^2 + 6 n^3 + 3 n^4) /. {n -> 6 k + f}]
  // 1/3 - (2 f)/3 - f^2/6 + f^3 + f^4/2 - 4 k - 2 f k + 18 f^2 k +
  // 12 f^3 k - 6 k^2 + 108 f k^2 + 108 f^2 k^2 + 216 k^3 + 432 f k^3 +
  // 648 k^4
  const int64 k = n / 6;
  const RetType k1 = ap.Add(k, static_cast<int64>(0));
  const RetType k2 = ap.Mul(k1, k1);
  const RetType k3 = ap.Mul(k2, k1);
  const RetType k4 = ap.Mul(k2, k2);
  const int64 f1 = n % 6;
  const int64 f2 = f1 * f1;
  const int64 f3 = f2 * f1;
  const int64 f4 = f2 * f2;
  RetType t0 = ap.Sub(static_cast<int64>(0), ap.Mul(static_cast<int64>(4), k1));
  t0 = ap.Sub(t0, ap.Mul(static_cast<int64>(2), ap.Mul(f1, k1)));
  t0 = ap.Add(t0, ap.Mul(static_cast<int64>(18), ap.Mul(f2, k1)));
  t0 = ap.Add(t0, ap.Mul(static_cast<int64>(12), ap.Mul(f3, k1)));
  t0 = ap.Sub(t0, ap.Mul(static_cast<int64>(6), k2));
  t0 = ap.Add(t0, ap.Mul(static_cast<int64>(108), ap.Mul(f1, k2)));
  t0 = ap.Add(t0, ap.Mul(static_cast<int64>(108), ap.Mul(f2, k2)));
  t0 = ap.Add(t0, ap.Mul(static_cast<int64>(216), k3));
  t0 = ap.Add(t0, ap.Mul(static_cast<int64>(432), ap.Mul(f1, k3)));
  t0 = ap.Add(t0, ap.Mul(static_cast<int64>(648), k4));
  if (done3) {
    t0 = ap.Mul(static_cast<int64>(3), t0);
  }
  const RetType t1 =
      ap.Add((3 * f4 + 6 * f3 - f2 - 4 * f1 + 2) / (done3 ? 2 : 6),
             static_cast<int64>(0));
  const RetType t2 = ap.Mul(ap.Mul(a, b), ap.Mul(c, d));
  return ap.Mul(ap.Add(t0, t1), t2);
}
}  // namespace internal

// Calculates (1^7 + 2^7 + 3^7 + ... + n^7) % mod.
// Assume no overflow for 2 * n.
SL int64 P7SumMod(int64 n, int64 mod) {
  return internal::P7SumImpl(
      n, internal::OperationTraitsWithMod<int64, int64>(mod));
}

template <typename T = int64>
SL T P7Sum(int64 n) {
  return internal::P7SumImpl(n, internal::OperationTraits<int64, T>());
}

SL int64 ApSumMod(int64 n, int64 mod) { return P1SumMod(n, mod); }

SL int64 ApSumModEx(int64 a, int64 b, int64 mod, int64 delta = 1) {
  return P1SumModEx(a, b, mod, delta);
}

SL int64 SquareSumMod(int64 n, int64 mod) { return P2SumMod(n, mod); }

SL int64 CubeSumMod(int64 n, int64 mod) { return P3SumMod(n, mod); }

SL int64 QuadSumMod(int64 n, int64 mod) { return P4SumMod(n, mod); }

SL int64 PentSumMod(int64 n, int64 mod) { return P5SumMod(n, mod); }

SL int64 HexaSumMod(int64 n, int64 mod) { return P6SumMod(n, mod); }

SL int64 HeptSumMod(int64 n, int64 mod) { return P7SumMod(n, mod); }

// Sum of geometric progression
// (x^a+x^(a+1)+x^(a+2)+...+x^b) % mod
// a >= 0
// zero_p_zero: 0^0
// if b < a: return 0
SL int64 GpSumMod(int64 x, int64 a, int64 b, int64 mod, int64 zero_p_zero = 1) {
  if (mod == 1 || b < a) return 0;
  if (b < a) return 0;
  x %= mod;
  // |x 0|^(b-a) x^a
  // |x 1|       x^a
  int64 u = x;
  int64 w = x;
  int64 v1 = a == 0 && x == 0 ? zero_p_zero : PowerMod(x, a, mod);
  int64 v2 = v1;
  for (int64 n = b - a; n > 0; n >>= 1) {
    if (n & 1) {
      v2 = AddMod(MulMod(w, v1, mod), v2, mod);
      v1 = MulMod(u, v1, mod);
    }
    if (n > 1) {
      w = AddMod(MulMod(w, u, mod), w, mod);
      u = MulMod(u, u, mod);
    }
  }
  return v2;
}

// Given a prime p, provides method to return
// Comb(n, m), Inv(n), Fac(n), IFac(n)
// The results are converted to type T.
template <typename T = int64>
struct PrimeModer {
  PrimeModer(int64 p, int64 f = 0) { Init(p, f == 0 ? p : f); }

  ~PrimeModer() = default;

  void Init(int64 p, int64 f) {
    p_ = p;
    f_ = std::min(f, p_ - 1);
    storage_.resize((f_ + 1) * 3);
    fac_ = &storage_[0];
    ifac_ = &storage_[f_ + 1];
    invs_ = &storage_[2 * (f_ + 1)];
    InitSeqProd2<int64>(fac_, ifac_, 1, f_, p_);
    InitInverse(invs_, f_, p_);
  }

  T fac(int64 n) const { return Fac(n); }

  T Fac(int64 n) const {
    if (n >= 0 && n <= f_) {
      return fac_[n];
    }
    PE_ASSERT(n >= 0 && n <= f_);
    return 0;
  }

  T ifac(int64 n) const { return IFac(n); }

  T IFac(int64 n) const {
    if (n >= 0 && n <= f_) {
      return ifac_[n];
    }
    PE_ASSERT(n >= 0 && n <= f_);
    return 0;
  }

  T inv(int64 n) const { return Inv(n); }

  T Inv(int64 n) const {
    if (n >= 0 && n <= f_) {
      return invs_[n];
    }
    return ModInv(n, p_);
  }

  T comb(int64 n, int64 m) const { return Comb(n, m); }

  T Comb(int64 n, int64 m) const {
    if (n < 0 || m > n) return 0;
    if (m == n || m == 0) return 1;
    if (m == 1 || m == n - 1) return n % p_;

    if (n <= f_) {
      return MulMod(MulMod(fac_[n], ifac_[m], p_), ifac_[n - m], p_);
    }

    // It's required that x % p_ <= f_ in the following code.

    int64 pp = 0;
    int64 dist = n - m;

    for (int64 nn = n / p_, mm = m / p_, dd = dist / p_; nn;
         nn /= p_, mm /= p_, dd /= p_) {
      pp += nn - mm - dd;
    }
    if (pp) return 0;
    int64 l = 1, r = 1;
    for (int64 x = n; x; x /= p_) {
      l = MulMod(l, Sign(x / p_), p_);
      l = MulMod(l, fac_[x % p_], p_);
    }
    for (int64 x = m; x; x /= p_) {
      r = MulMod(r, Sign(x / p_), p_);
      r = MulMod(r, fac_[x % p_], p_);
    }
    for (int64 x = dist; x; x /= p_) {
      r = MulMod(r, Sign(x / p_), p_);
      r = MulMod(r, fac_[x % p_], p_);
    }
    return MulMod(ModInv(r, p_), l, p_);
  }

 private:
  int64 Sign(int64 x) const { return x & 1 ? p_ - 1 : 1; }

 private:
  int64 p_, f_;
  int64* fac_;
  int64* ifac_;
  int64* invs_;
  std::vector<int64> storage_;
};
}  // namespace pe
// 65701
#endif
/*

*/
