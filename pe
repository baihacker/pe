#ifndef PE_
#define PE_

#include "pe_config"

// How to use a library in MinGW or VC++ (including compiled binaries on windows
// (x64)) https://github.com/baihacker/pe/blob/master/libraries_on_win64.md#use

// Compiler and cpp version check
// https://blog.kowalczyk.info/article/j/guide-to-predefined-macros-in-c-compilers-gcc-clang-msvc-etc..html
#if defined(__GNUC__)

// COMPILER_GNU: gcc/mingw32/mingw64/clang
#define COMPILER_GNU

#if defined(__clang__)
#define COMPILER_CLANG
#elif defined(__MINGW64__)
#define COMPILER_MINGW64
#elif defined(__MINGW32__)
#define COMPILER_MINGW32
#else
#define COMPILER_GCC
#endif

#define PE_CPP_VERSION __cplusplus

#elif defined(_MSC_VER)

// COMPILER_MSVC
#define COMPILER_MSVC
// VC2015 (1900) or above to support c++11
// https://en.wikipedia.org/wiki/Microsoft_Visual_C%2B%2B#Internal_version_numbering
// https://en.cppreference.com/w/cpp/compiler_support#cpp11
// https://blogs.msdn.microsoft.com/vcblog/2018/04/09/msvc-now-correctly-reports-__cplusplus/

#if defined(_MSVC_LANG)
#define PE_CPP_VERSION _MSVC_LANG
#elif _MSC_VER == 1900
#define PE_CPP_VERSION 201103L
#else
#define PE_CPP_VERSION 199711L
#endif

#else
#define PE_CPP_VERSION 199711L
#endif

// C++ version check
#if PE_CPP_VERSION < 201103L
#define PE_HAS_CPP11 0
#else
#define PE_HAS_CPP11 1
#endif

#if PE_CPP_VERSION < 201402L
#define PE_HAS_CPP14 0
#else
#define PE_HAS_CPP14 1
#endif

#if PE_CPP_VERSION < 201703L
#define PE_HAS_CPP17 0
#else
#define PE_HAS_CPP17 1
#endif

#if PE_CPP_VERSION < 202002L
#define PE_HAS_CPP20 0
#else
#define PE_HAS_CPP20 1
#endif

// Platform
#if _WIN32 || _WIN64
#define PLATFORM_WIN 1
#define PLATFORM_APPLE 0
#define PLATFORM_LINUX 0
#elif defined(__APPLE__)
#define PLATFORM_WIN 0
#define PLATFORM_APPLE 1
#define PLATFORM_LINUX 0
#else
#define PLATFORM_WIN 0
#define PLATFORM_APPLE 0
#define PLATFORM_LINUX 1
#endif

// Arch
#if defined(COMPILER_GNU)

#if defined(__x86_64)
#define PE_X86_64 1
#define PE_X86_32 0
#elif defined(_X86_)
#define PE_X86_64 0
#define PE_X86_32 1
#else
#error "unknown arch"
#endif

#elif defined(COMPILER_MSVC)

#if defined(_M_X64)
#define PE_X86_64 1
#define PE_X86_32 0
#else
#define PE_X86_64 0
#define PE_X86_32 1
#endif

#else
#define PE_X86_64 0
#define PE_X86_32 1
#endif

#if PE_X86_64
#define _AMD64_
#else
#define _X86_
#endif

#if defined(__AVX2__) && __AVX2__
#define PE_HAS_AVX2 1
#else
#define PE_HAS_AVX2 0
#endif

// At least c++17
#if !PE_HAS_CPP17
#error "c++17 or above only"
#endif

// TODO(baihacker): we may disable non-standard c++.
// Workaround to detect gnu++XX
// https://quuxplusone.github.io/blog/2019/02/28/is-int128-integral/
// https://stackoverflow.com/questions/41198673/uint128-t-not-working-with-clang-and-libstdc
// #ifdef __GLIBCXX_TYPE_INT_N_0
// #error "Please add --std=c++XX to use standard c++ instead of --std=gnu++XX"
// #endif

// Configurations

// int128
#if !defined(TRY_TO_USE_INT128)
#define TRY_TO_USE_INT128 1
#endif

// Let int128 be recognized in vscode.
// Make the vscode support int128
#if defined(VSCODE_EDITOR)
// #define __SIZEOF_INT128__ 16
// #define __int128 long long
#endif

#if TRY_TO_USE_INT128 && defined(__SIZEOF_INT128__)
#define PE_HAS_INT128 1
using int128 = __int128;
using uint128 = unsigned __int128;
#else
#define PE_HAS_INT128 0
#endif

#if !defined(ENABLE_ASSERT)
#define ENABLE_ASSERT 1
#endif

// Link: https://www.openmp.org/
// Doc: https://www.openmp.org/wp-content/uploads/openmp-4.5.pdf
// Add -fopenmp in gcc compile command of config it in vc solution property
// dialog. Change 1 to 0, if you want to prevent pe from using OPENMP even if
// OPENMP is enabled by compiler.
#if !defined(ENABLE_OPENMP)
#if defined(_OPENMP)
#define ENABLE_OPENMP 1
#else
#define ENABLE_OPENMP 0
#endif
#else
#if ENABLE_OPENMP && !defined(_OPENMP)
// Clang:
// Use -fopenmp to enable default openmp, the default openmp is specified when
// building the clang. You can find the default openmp in
// "include\clang\Config\config.h". Use -fopenmp=libgomp or -fopenmp=libomp to
// specify the openmp implementation explicitly. You need to specify the
// corresponding library explicitly, i.e. add -lomp or -lgomp. Clang only works
// with libomp. If the implementation is not libomp, _OPENMP is not defined and
// it works in one thread.
#if defined(COMPILER_GNU)
#warning "ENABLE_OPENMP is 1 but the openmp compiler option is off."
#else
#pragma message("ENABLE_OPENMP is 1 but the openmp compiler option is off.")
#endif
#endif
#endif

// Link: http://eigen.tuxfamily.org/index.php?title=Main_Page
// Doc: http://eigen.tuxfamily.org/dox/
// Please make sure #include <Eigen/Dense> work
#if !defined(ENABLE_EIGEN)
#define ENABLE_EIGEN 1
#endif

// Link: https://gmplib.org/
// Doc: https://gmplib.org/manual/C_002b_002b-Interface-General.html
#if !defined(ENABLE_GMP)
#define ENABLE_GMP 1
#endif

// Link: http://www.flintlib.org
// Doc: http://www.flintlib.org/flint-2.5.pdf
#if !defined(ENABLE_FLINT)
#define ENABLE_FLINT 1
#endif

// Link: https://www.mpfr.org/
#if !defined(ENABLE_MPFR)
#define ENABLE_MPFR 1
#endif

// Link: https://bellard.org/libbf/
#if !defined(ENABLE_LIBBF)
#define ENABLE_LIBBF 1
#endif

// https://www.shoup.net/ntl/download.html
#if !defined(ENABLE_NTL)
#define ENABLE_NTL 1
#endif

// Check dependencies
#if ENABLE_FLINT

#if !ENABLE_GMP
#error gmp should be enabled if flint is enabled
#endif

#if !ENABLE_MPFR
#error mpfr should be enabled if flint is enabled
#endif

#endif

// Include third party libraries and apply fixes to them.
// Add the corresponding libraries if the compiler is msvc.
#if defined(COMPILER_MSVC)
#pragma warning(disable : 4996)  // Always disable 4996
#pragma warning(push)
#pragma warning(disable : 4244)
#pragma warning(disable : 4267)
#pragma warning(disable : 4146)
#endif

#if ENABLE_LIBBF

/**
  Use the following fix if the libbf version is less than 2019-02-10.
  pe_ntt_libbf is also required to modify, see the modified code in pe4.0.
  #include <cstdint>
  #include <cstdlib>

  extern "C" {

    #include <libbf.h>

    void* bf_realloc(void* ptr, size_t size) { return realloc(ptr, size); }
  }
*/

extern "C" {
#include <libbf.h>
}

#if defined(COMPILER_MSVC)
#pragma comment(lib, "libbf.a")
#endif

#endif

// flint must come before the following libs.
#if ENABLE_FLINT

#if defined(COMPILER_MSVC)
#include <malloc.h>
#define alloca _alloca
#endif

#include <flint.h>
#include <fmpz.h>
#include <fq_nmod_poly.h>
#include <nmod_poly.h>

#if defined(COMPILER_MSVC)
#pragma comment(lib, "libflint.a")
#endif

#endif

#if ENABLE_GMP
#include <gmp.h>
#include <gmpxx.h>

#if defined(COMPILER_MSVC)
#include <iostream>
static inline std::ostream& operator<<(std::ostream& o, __mpz_struct const* x) {
  size_t sz = mpz_sizeinbase(x, 10) + 1;
  char* buff = new char[sz + 1];
  if (buff != NULL) {
    gmp_sprintf(buff, "%Zd", x);
  }
  o << buff;
  delete[] buff;
  return o;
}
#endif

#if defined(COMPILER_MSVC)
#pragma comment(lib, "libgmpxx.a")
#pragma comment(lib, "libgmp.a")
#endif

#endif

#if ENABLE_MPFR
#include <mpfr.h>
// Don't use this adapter by default.
// Due to some compatibilities reason,
// If this adapter is enabled, the initialization from string will
// have precision issue, memory allocation function may fail.
// #include <mpf2mpfr.h>

#if defined(COMPILER_MSVC)
#pragma comment(lib, "libmpfr.a")
#endif

#endif

#if ENABLE_OPENMP
#include <omp.h>
#endif

#if ENABLE_EIGEN
#include <Eigen/Core>
#endif

#if ENABLE_NTL
#if defined(COMPILER_MSVC)
#pragma message( \
    "Cannot support ntl in msvc due to pthread dependency and binary compatibility.")
#undef ENABLE_NTL
#define ENABLE_NTL 0
#endif
#endif

#if ENABLE_NTL
#include <NTL/ZZ.h>
#include <NTL/ZZ_p.h>
#include <NTL/ZZ_pX.h>
#include <NTL/lzz_p.h>
#include <NTL/lzz_pX.h>
#endif

#if defined(COMPILER_MSVC)
#pragma warning(pop)
#endif

#if defined(COMPILER_MSVC) && \
    (ENABLE_LIBBF || ENABLE_FLINT || ENABLE_GMP || ENABLE_MPFR)
#pragma comment(lib, "libgcc_s.a")
#pragma comment(lib, "libgcc.a")
#pragma comment(lib, "legacy_stdio_definitions.lib")
#endif

// Disable unnecessary features in windows.h
#if PLATFORM_WIN
#define NOGDICAPMASKS
#define NOVIRTUALKEYCODES
#define NOWINMESSAGES
#define NOWINSTYLES
#define NOSYSMETRICS
#define NOMENUS
#define NOICONS
#define NOKEYSTATES
#define NOSYSCOMMANDS
#define NORASTEROPS
#define NOSHOWWINDOW
#define OEMRESOURCE
#define NOATOM
#define NOCLIPBOARD
#define NOCOLOR
#define NOCTLMGR
#define NODRAWTEXT
#define NOGDI
#define NOKERNEL
#define NOUSER
#define NONLS
#define NOMB
#define NOMEMMGR
#define NOMETAFILE
#define NOMINMAX
#define NOMSG
#define NOOPENFILE
#define NOSCROLL
#define NOSERVICE
#define NOSOUND
#define NOTEXTMETRIC
#define NOWH
#define NOWINOFFSETS
#define NOCOMM
#define NOKANJI
#define NOHELP
#define NOPROFILER
#define NODEFERWINDOWPOS
#define NOMCX

#define NOCRYPT
#endif

// Disable max/min in windows.h
#ifndef NOMINMAX
#define NOMINMAX 1
#endif

#if PLATFORM_WIN
// #if defined(COMPILER_MSVC) && PLATFORM_WIN && PE_X86_64
// pe_mod depends VirtualProtect when the target arch is x64.
// pe_memory depends on several APIs if the platform is windows.
#include <windows.h>
#endif

#if defined(COMPILER_MSVC)
#pragma comment(linker, "/STACK:268435456")
#endif

// Include pe

// Base
#include "pe_base"
#include "pe_int128"
#include "pe_type_traits"
#include "pe_io"

// General util
#include "pe_time"
#include "pe_persistance"
#include "pe_bit"
#include "pe_tree"
#include "pe_rand"

// Modular arithmetic
#include "pe_mod"

// Range
#include "pe_range"

// Matrix arithmetic
#include "pe_mat"

// Number theory arithmetic
#include "pe_nt_base"
#include "pe_nt"

// Fraction arithmetic
#include "pe_fraction"

// Polynomial
#include "pe_poly_base"
#include "pe_poly"
#include "pe_poly_algo"

// fft
#include "pe_fft"

// Big integer
#include "pe_gbi"
#include "pe_bi32"
#include "pe_mpz"

// Geometry
#include "pe_geometry"

// Large memory support (windows)
#include "pe_memory"

// Parallel support
#include "pe_parallel"
#include "pe_parallel_algo"

// MP extension
#include "pe_mpf"

// Misc
#include "pe_misc"
#include "pe_mma"

#include "pe_array"
#include "pe_algo"
#include "pe_sym_poly"
#include "pe_db"

struct PeInitializer {
  PeInitializer& set_max_prime(int64 maxp = 1000000) {
    this->maxp = maxp;
    return *this;
  }

  PeInitializer& set_cal_phi(int cal_phi = 1) {
    this->cal_phi = cal_phi;
    return *this;
  }

  PeInitializer& set_cal_mu(int cal_mu = 1) {
    this->cal_mu = cal_mu;
    return *this;
  }

  PeInitializer& set_cal_rad(int cal_rad = 1) {
    this->cal_rad = cal_rad;
    return *this;
  }

  PeInitializer& set_fft_k(int fft_k = 22) {
    this->fft_k = fft_k;
    return *this;
  }

  PeInitializer& set_ntt32_k(int ntt32_k = 22) {
    this->ntt32_k = ntt32_k;
    return *this;
  }

  PeInitializer& set_ntt64_k(int ntt64_k = 22) {
    this->ntt64_k = ntt64_k;
    return *this;
  }

  PeInitializer& set_mod(int64 default_mod = 1000000007) {
    this->default_mod = default_mod;
    return *this;
  }

  void Init() {
    InitNt();
    InitParallel();
    InitFft(fft_k);
    InitNtt32(ntt32_k);
    InitNtt64(ntt64_k);
    ::DEFAULT_MOD = default_mod;
  }

  void InitNt() {
    DeinitPrimes();
    INIT_MAXP(maxp);
    if (cal_phi == 0 && cal_mu == 0 && cal_rad == 0) {
      InitPrimes();
    } else {
      InitPrimes(cal_phi, cal_mu, cal_rad);
    }
  }

  void InitParallel() {
#if ENABLE_OPENMP
    omp_set_nested(1);
    omp_set_dynamic(1);
#endif

#if PLATFORM_WIN
    SetProcessPriority(PRIORITY_IDLE);
#endif
  }

  void InitFft(int k = 22) {
    if (k >= 0) {
      fft::InitFftK(k);
    }
  }

  void InitNtt32(int k = 22) {
    if (k >= 0) {
      ntt32::InitNtt(k);
    }
  }

  void InitNtt64(int k = 22) {
#if PE_HAS_INT128
    if (k >= 0) {
      ntt64::InitNtt(k);
    }
#endif
  }

  int64 maxp = 1000000;
  int cal_phi = 0;
  int cal_mu = 0;
  int cal_rad = 0;

  int fft_k = -1;
  int ntt32_k = -1;
  int ntt64_k = -1;

  int64 default_mod = 1;
};

PeInitializer pe() { return PeInitializer(); }
#define PE_ADD_DOT_IMPL_0(...)
#define PE_ADD_DOT_IMPL_1(I) .I
#define PE_ADD_DOT_IMPL_2(I, ...) .I, PE_ADD_DOT_IMPL_1(__VA_ARGS__)
#define PE_ADD_DOT_IMPL_3(I, ...) .I, PE_ADD_DOT_IMPL_2(__VA_ARGS__)
#define PE_ADD_DOT_IMPL_4(I, ...) .I, PE_ADD_DOT_IMPL_3(__VA_ARGS__)
#define PE_ADD_DOT_IMPL_5(I, ...) .I, PE_ADD_DOT_IMPL_4(__VA_ARGS__)
#define PE_ADD_DOT_IMPL_6(I, ...) .I, PE_ADD_DOT_IMPL_5(__VA_ARGS__)
#define PE_ADD_DOT_IMPL_7(I, ...) .I, PE_ADD_DOT_IMPL_6(__VA_ARGS__)
#define PE_ADD_DOT_IMPL_8(I, ...) .I, PE_ADD_DOT_IMPL_7(__VA_ARGS__)
#define PE_ADD_DOT_IMPL_9(I, ...) .I, PE_ADD_DOT_IMPL_8(__VA_ARGS__)
#define PE_ADD_DOT_IMPL_10(I, ...) .I, PE_ADD_DOT_IMPL_9(__VA_ARGS__)
#define PE_ADD_DOT_IMPL_11(I, ...) .I, PE_ADD_DOT_IMPL_10(__VA_ARGS__)
#define PE_ADD_DOT_IMPL_12(I, ...) .I, PE_ADD_DOT_IMPL_11(__VA_ARGS__)
#define PE_ADD_DOT_IMPL_13(I, ...) .I, PE_ADD_DOT_IMPL_12(__VA_ARGS__)
#define PE_ADD_DOT_IMPL_14(I, ...) .I, PE_ADD_DOT_IMPL_13(__VA_ARGS__)
#define PE_ADD_DOT_IMPL_15(I, ...) .I, PE_ADD_DOT_IMPL_14(__VA_ARGS__)
#define PE_ADD_DOT_IMPL_16(I, ...) .I, PE_ADD_DOT_IMPL_15(__VA_ARGS__)

#define PE_ADD_DOT_IMPL(n, ...) PE_CONCAT(PE_ADD_DOT_IMPL_, n)(__VA_ARGS__)

#define PE_ADD_DOT(...) PE_ADD_DOT_IMPL(PE_NARG(__VA_ARGS__), __VA_ARGS__)

#define PE_INIT(...) (PeInitializer{PE_ADD_DOT(__VA_ARGS__)}).Init()
#endif
