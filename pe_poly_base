#ifndef PE_POLY_BASE_
#define PE_POLY_BASE_

#include "pe_base"
#include "pe_int128"
#include "pe_mod"
#include "pe_type_traits"
#include "pe_nt"

#include "pe_poly_base_common"
#include "pe_poly_base_flint"
#include "pe_poly_base_ntl"
#include "pe_poly_base_min_25"
#include "pe_poly_base_libbf"

namespace ntt_base {
template <typename T>
SL REQUIRES((is_native_integer<T>::value)) RETURN(void)
    ntt_trans(T* data, const int n) {
  int j = n >> 1;
  for (int i = 1; i < n - 1; ++i) {
    if (i < j) swap(data[i], data[j]);
    int k = n >> 1;
    while (j >= k) {
      j -= k;
      k >>= 1;
    }
    if (j < k) j += k;
  }
}
}  // namespace ntt_base

// mod is 32 bit
namespace ntt32 {
struct NttMod32 {
  // mod = r * 2 ^ k + 1
  // mod is prime
  const unsigned mod;
  const unsigned r;
  const int k;
  const unsigned g;

  unsigned omg[32];
  mutable unsigned* preOmg[32];

  NttMod32(unsigned mod, unsigned r, int k, unsigned g)
      : mod(mod), r(r), k(k), g(g) {
    for (int i = 0; i <= k; ++i) {
      omg[i] = static_cast<unsigned>(power_mod<uint64>(g, (mod - 1) >> i, mod));
    }
    fill(preOmg, preOmg + 32, (unsigned*)nullptr);
  }

  ~NttMod32() {
    for (int i = 0; i <= k; ++i) {
      if (preOmg[i] != nullptr) {
        delete[] preOmg[i];
        preOmg[i] = nullptr;
      }
    }
  }

  void initPreOmg(int K) const {
    PE_ASSERT(K <= k);
    for (int i = 0; i <= K; ++i) {
      if (preOmg[i] != nullptr) {
        continue;
      }
      const int cnt = 1 << i;
      preOmg[i] = new unsigned[cnt];
      auto* target = preOmg[i];
      const uint64 m = omg[i];
      unsigned last = 1;
      target[0] = 1;
      for (int i = 1; i < cnt; ++i) {
        last = last * m % mod;
        target[i] = last;
      }
    }
  }
};

static const NttMod32 nttMod1(2013265921ull, 15ull, 27, 31ull);
static const NttMod32 nttMod2(2281701377ull, 17ull, 27, 3ull);
static const NttMod32 nttMod3(3221225473ull, 3ull, 30, 5ull);

template <typename T>
SL REQUIRES((is_native_integer<T>::value)) RETURN(void)
    ntt(T* data, const int n, const NttMod32& moder, bool inv = false) {
  ntt_base::ntt_trans(data, n);

  const auto mod = moder.mod;
  int id = 0;
  for (int h = 2; h <= n; h <<= 1) {
    const auto* preOmg = moder.preOmg[++id];
    if (preOmg) {
#if ENABLE_OPENMP
#pragma omp parallel for schedule(dynamic, 16) if (n / h > 100000)
#endif
      for (int j = 0; j < n; j += h) {
        const auto* omg = preOmg;
        const int halfH = h >> 1;
        const int limit = j + halfH;
        for (int k = j; k < limit; ++k) {
          const auto u = data[k] % mod;
          const auto t = static_cast<uint64>(*omg++) * data[k + halfH] % mod;
          data[k] = (u + t) % mod;
          data[k + halfH] = (u + mod - t) % mod;
        }
      }
    } else {
#if ENABLE_OPENMP
#pragma omp parallel for schedule(dynamic, 16) if (n / h > 100000)
#endif
      for (int j = 0; j < n; j += h) {
        uint64 omgn = 1;
        const int halfH = h >> 1;
        const int limit = j + halfH;
        for (int k = j; k < limit; ++k) {
          const auto u = data[k] % mod;
          const auto t = omgn * data[k + halfH] % mod;
          data[k] = (u + t) % mod;
          data[k + halfH] = (u + mod - t) % mod;
          omgn = omgn * moder.omg[id] % mod;
        }
      }
    }
  }
  if (inv) {
    const int halfN = n >> 1;
    for (int i = 1; i < halfN; ++i) swap(data[i], data[n - i]);
    const uint64 c = power_mod<uint64>(n, mod - 2, mod);
    for (int i = 0; i < n; ++i) data[i] = c * data[i] % mod;
  }
}

void init_ntt(int k = 22) {
  PE_ASSERT(k <= 27 && k >= 0);
  nttMod1.initPreOmg(k);
  nttMod2.initPreOmg(k);
  nttMod3.initPreOmg(k);
}

// Need int128 to handle the big polynomial coefficient.
#define HAS_POLY_MUL_NTT32 1

struct ntt_constant {
  static constexpr uint64 M1 = 2013265921;
  static constexpr uint64 M2 = 2281701377;
  static constexpr uint64 M3 = 3221225473;
#if 0 && PE_HAS_INT128
  static constexpr uint64 M12 = M1 * M2;
  static constexpr uint64 M13 = M1 * M3;
  static constexpr uint64 M23 = M2 * M3;
  static constexpr uint64 IM12 = 2300875347;
  static constexpr uint64 IM13 = 1792765347;
  static constexpr uint64 IM23 = 1006632973;

  static constexpr uint128 M13M = (uint128)IM13 * M13;
  static constexpr uint128 M23M = (uint128)IM23 * M23;
  static constexpr uint128 M12M = (uint128)IM12 * M12;
  static constexpr uint128 MMM = (uint128)M1 * M2 * M3;
#else
  static constexpr uint64 INV_M1__M2 = 1140850697;

  static constexpr uint64 M1M2 = M1 * M2;
  static constexpr uint64 INV_M3__M1M2 = 1312477593879670191ull;
#endif
};

// Multiply two polynomials.
// Make sure the length of result is at least: n + m - 1
template <typename T>
SL REQUIRES((is_native_integer<T>::value)) RETURN(void)
    poly_mul_large_internal(const T* X, int n, const T* Y, int m, T* result,
                            int64 mod) {
  static_assert(std::is_unsigned<T>::value, "T must be unsigned");

  const int alignedSize = 1 << pe_lg(2 * (n + m - 1) - 1);

  // TODO(baihacker): decide the size automatically.
  const NttMod32* moderList[3] = {&nttMod1, &nttMod2, &nttMod3};
  vector<uint64> tresult[3];
#if ENABLE_OPENMP
#pragma omp parallel for schedule(dynamic, 1) num_threads(3)
#endif
  for (int id = 0; id < 3; ++id) {
    const NttMod32& moder = *moderList[id];
    vector<uint64> XX(alignedSize);
    vector<uint64> YY(alignedSize);
    for (int i = 0; i < n; ++i) XX[i] = X[i];
    for (int i = n; i < alignedSize; ++i) XX[i] = 0;
    for (int i = 0; i < m; ++i) YY[i] = Y[i];
    for (int i = m; i < alignedSize; ++i) YY[i] = 0;
#if ENABLE_OPENMP
#pragma omp parallel sections if (n + m >= 100000)
#endif
    {
#if ENABLE_OPENMP
#pragma omp section
#endif
      ntt(&XX[0], alignedSize, moder);
#if ENABLE_OPENMP
#pragma omp section
#endif
      ntt(&YY[0], alignedSize, moder);
    }
    const uint64 mod = moder.mod;
    for (int i = 0; i < alignedSize; ++i) {
      XX[i] = static_cast<uint64>(XX[i]) * YY[i] % mod;
    }
    ntt(&XX[0], alignedSize, moder, true);
    tresult[id] = std::move(XX);
  }

  const int resultSize = n + m - 1;
#if ENABLE_OPENMP
#pragma omp parallel for schedule(dynamic, 100000) if (n + m >= 100000)
#endif
  for (int i = 0; i < resultSize; ++i) {
#if 0 && PE_HAS_INT128
    const uint128 a = tresult[0][i] * ntt_constant::M23M;
    const uint128 b = tresult[1][i] * ntt_constant::M13M;
    const uint128 c = tresult[2][i] * ntt_constant::M12M;
    const uint128 t = a + b + c;
    const auto tmp = t < ntt_constant::MMM ? t : t % ntt_constant::MMM;
    result[i] = mod > 0 ? tmp % mod : tmp;
#else
    const uint64 a = tresult[0][i];
    const uint64 b = tresult[1][i];
    const uint64 c = tresult[2][i];
    const uint64 x1 = b >= a ? b - a : ntt_constant::M2 - a + b;
    const uint64 y1 = x1 * ntt_constant::INV_M1__M2 % ntt_constant::M2;
    const uint64 modab = y1 * ntt_constant::M1 + a;
    const uint64 x2 = modab >= c ? modab - c : ntt_constant::M1M2 - c + modab;
#if PE_HAS_INT128
    const uint64 y2 = static_cast<uint128>(x2) * ntt_constant::INV_M3__M1M2 %
                      ntt_constant::M1M2;
    const uint128 t = static_cast<uint128>(y2) * ntt_constant::M3 + c;
    result[i] = mod > 0 ? t % mod : t;
#else
    PE_ASSERT(mod > 0);
    const uint64 y2 =
        mul_mod_ex(x2, ntt_constant::INV_M3__M1M2, ntt_constant::M1M2);
    const uint64 t = mul_mod_ex(y2 % mod, ntt_constant::M3 % mod, mod);
    result[i] = add_mod(t, c % mod, mod);
#endif
#endif
  }
}

// Multiply two polynomials.
// The length of result is at least n + m - 1.
template <typename T>
SL REQUIRES((is_native_integer<T>::value)) RETURN(void)
    poly_mul_large(const T* X, const int n, const T* Y, const int m, T* result,
                   int64 mod) {
  using unsignedT = typename std::make_unsigned<T>::type;
  poly_mul_wrapper<unsignedT>((const unsignedT*)X, n, (const unsignedT*)Y, m,
                              (unsignedT*)result, mod,
                              &poly_mul_large_internal<unsignedT>);
}

template <typename T>
SL REQUIRES((is_native_integer<T>::value)) RETURN(vector<T>)
    poly_mul_large(const vector<T>& X, const vector<T>& Y, int64 mod) {
  const int n = (int)X.size();
  const int m = (int)Y.size();

  vector<T> result(n + m - 1);
  poly_mul_large(&X[0], n, &Y[0], m, &result[0], mod);

  return result;
}

#define HAS_POLY_MUL_NTT32_SMALL 1
struct ntt_small_constant {
  static constexpr uint64 M1 = 2013265921;
  static constexpr uint64 M2 = 2281701377;
  static constexpr uint64 INV_M1__M2 = 1140850697;
};

// Multiply two polynomials.
// Make sure the length of result is at least: n + m - 1
template <typename T>
SL REQUIRES((is_native_integer<T>::value)) RETURN(void)
    poly_mul_small_internal(const T* X, int n, const T* Y, int m, T* result,
                            int64 mod) {
  static_assert(std::is_unsigned<T>::value, "T must be unsigned");

  const int alignedSize = 1 << pe_lg(2 * (n + m - 1) - 1);

  // TODO(baihacker): decide the size automatically.
  const NttMod32* moderList[2] = {&nttMod1, &nttMod2};
  vector<uint64> tresult[2];
#if ENABLE_OPENMP
#pragma omp parallel for schedule(dynamic, 1) num_threads(2)
#endif
  for (int id = 0; id < 2; ++id) {
    const NttMod32& moder = *moderList[id];
    vector<uint64> XX(alignedSize);
    vector<uint64> YY(alignedSize);
    for (int i = 0; i < n; ++i) XX[i] = X[i];
    for (int i = n; i < alignedSize; ++i) XX[i] = 0;
    for (int i = 0; i < m; ++i) YY[i] = Y[i];
    for (int i = m; i < alignedSize; ++i) YY[i] = 0;
#if ENABLE_OPENMP
#pragma omp parallel sections if (n + m >= 100000)
#endif
    {
#if ENABLE_OPENMP
#pragma omp section
#endif
      ntt(&XX[0], alignedSize, moder);
#if ENABLE_OPENMP
#pragma omp section
#endif
      ntt(&YY[0], alignedSize, moder);
    }
    const uint64 mod = moder.mod;
    for (int i = 0; i < alignedSize; ++i) {
      XX[i] = static_cast<uint64>(XX[i]) * YY[i] % mod;
    }
    ntt(&XX[0], alignedSize, moder, true);
    tresult[id] = std::move(XX);
  }

  const int resultSize = n + m - 1;
#if ENABLE_OPENMP
#pragma omp parallel for schedule(dynamic, 100000) if (n + m >= 100000)
#endif
  for (int i = 0; i < resultSize; ++i) {
    const uint64 a = tresult[0][i];
    const uint64 b = tresult[1][i];
    const uint64 c = b >= a ? b - a : b + ntt_small_constant::M2 - a;
    const uint64 d =
        c * ntt_small_constant::INV_M1__M2 % ntt_small_constant::M2;
    const uint64 t = d * ntt_small_constant::M1 + a;
    result[i] = mod > 0 ? t % mod : t;
  }
}

// Multiply two polynomials.
// The length of result is at least n + m - 1.
template <typename T>
SL REQUIRES((is_native_integer<T>::value)) RETURN(void)
    poly_mul_small(const T* X, const int n, const T* Y, const int m, T* result,
                   int64 mod) {
  using unsignedT = typename std::make_unsigned<T>::type;
  poly_mul_wrapper<unsignedT>((const unsignedT*)X, n, (const unsignedT*)Y, m,
                              (unsignedT*)result, mod,
                              &poly_mul_small_internal<unsignedT>);
}

template <typename T>
SL REQUIRES((is_native_integer<T>::value)) RETURN(vector<T>)
    poly_mul_small(const vector<T>& X, const vector<T>& Y, int64 mod) {
  const int n = (int)X.size();
  const int m = (int)Y.size();

  vector<T> result(n + m - 1);
  poly_mul_small(&X[0], n, &Y[0], m, &result[0], mod);

  return result;
}
}  // namespace ntt32

#define HAS_POLY_MUL_NTT64 1
#define HAS_POLY_MUL_NTT64_SMALL 1

// mod is 64 bit
namespace ntt64 {
struct NttMod64 {
  // mod = r * 2 ^ k + 1
  // mod is prime
  const uint64 mod;
  const unsigned r;
  const int k;
  const unsigned g;

  uint64 omg[64];
  mutable uint64* preOmg[64];

  NttMod64(uint64 mod, unsigned r, int k, unsigned g)
      : mod(mod), r(r), k(k), g(g) {
    for (int i = 0; i <= k; ++i) {
      omg[i] = power_mod_ex<uint64>(g, (mod - 1) >> i, mod);
    }
    fill(preOmg, preOmg + 64, (uint64*)nullptr);
  }

  ~NttMod64() {
    for (int i = 0; i <= k; ++i) {
      if (preOmg[i] != nullptr) {
        delete[] preOmg[i];
        preOmg[i] = nullptr;
      }
    }
  }

  void initPreOmg(int K) const {
    PE_ASSERT(K <= k);
    for (int i = 0; i <= K; ++i) {
      if (preOmg[i] != nullptr) {
        continue;
      }
      const int cnt = 1 << i;
      preOmg[i] = new uint64[cnt];
      auto* target = preOmg[i];
      const uint64 m = omg[i];
      uint64 last = 1;
      target[0] = 1;
      for (int i = 1; i < cnt; ++i) {
#if PE_HAS_INT128
        last = mod128_64(static_cast<uint128>(last) * m, mod);
#else
        last = mul_mod_ex(last, m, mod);
#endif
        target[i] = last;
      }
    }
  }
};

static const NttMod64 nttMod1(180143985094819841ull, 5ull, 55, 6ull);
static const NttMod64 nttMod2(1945555039024054273ull, 27ull, 56, 5ull);

template <typename T>
SL REQUIRES((is_native_integer<T>::value)) RETURN(void)
    ntt(T* data, const int n, const NttMod64& moder, bool inv = false) {
  ntt_base::ntt_trans(data, n);

  const auto mod = moder.mod;
  int id = 0;
  for (int h = 2; h <= n; h <<= 1) {
    const auto* preOmg = moder.preOmg[++id];
    if (preOmg) {
#if ENABLE_OPENMP
#pragma omp parallel for schedule(dynamic, 16) if (n / h > 100000)
#endif
      for (int j = 0; j < n; j += h) {
        const auto* omg = preOmg;
        const int halfH = h >> 1;
        const int limit = j + halfH;
        for (int k = j; k < limit; ++k) {
          const auto u = data[k] % mod;
#if PE_HAS_INT128
          const auto t =
              mod128_64(static_cast<uint128>(*omg++) * data[k + halfH], mod);
#else
          const auto t = mul_mod_ex(*omg++, data[k + halfH], mod);
#endif
          data[k] = (u + t) % mod;
          data[k + halfH] = (u + mod - t) % mod;
        }
      }
    } else {
#if ENABLE_OPENMP
#pragma omp parallel for schedule(dynamic, 16) if (n / h > 100000)
#endif
      for (int j = 0; j < n; j += h) {
        uint64 omgn = 1;
        const int halfH = h >> 1;
        const int limit = j + halfH;
        for (int k = j; k < limit; ++k) {
          const auto u = data[k] % mod;
#if PE_HAS_INT128
          const auto t =
              mod128_64(static_cast<uint128>(omgn) * data[k + halfH], mod);
#else
          const auto t = mul_mod_ex(omgn, data[k + halfH], mod);
#endif
          data[k] = (u + t) % mod;
          data[k + halfH] = (u + mod - t) % mod;
#if PE_HAS_INT128
          omgn = mod128_64(static_cast<uint128>(omgn) * moder.omg[id], mod);
#else
          omgn = mul_mod_ex(omgn, moder.omg[id], mod);
#endif
        }
      }
    }
  }
  if (inv) {
    const int halfN = n >> 1;
    for (int i = 1; i < halfN; ++i) swap(data[i], data[n - i]);
    const uint64 c = power_mod_ex<uint64>(n, mod - 2, mod);
    for (int i = 0; i < n; ++i) {
#if PE_HAS_INT128
      data[i] = mod128_64(static_cast<uint128>(c) * data[i], mod);
#else
      data[i] = mul_mod_ex(c, data[i], mod);
#endif
    }
  }
}

void init_ntt(int k = 22) {
  PE_ASSERT(k <= 30 && k >= 0);
  nttMod1.initPreOmg(k);
  nttMod2.initPreOmg(k);
}

struct ntt_constant {
  static constexpr uint64 M1 = 180143985094819841ull;
  static constexpr uint64 M2 = 1945555039024054273ull;
  static constexpr uint64 INV_M1__M2 = 714693687804754632ull;
};

// Multiply two polynomials.
// Make sure the length of result is at least: n + m - 1
template <typename T>
SL REQUIRES((is_native_integer<T>::value)) RETURN(void)
    poly_mul_large_internal(const T* X, int n, const T* Y, int m, T* result,
                            int64 mod) {
  static_assert(std::is_unsigned<T>::value, "T must be unsigned");

  const int alignedSize = 1 << pe_lg(2 * (n + m - 1) - 1);

  // TODO(baihacker): decide the size automatically.
  const NttMod64* moderList[2] = {&nttMod1, &nttMod2};
  vector<uint64> tresult[2];
#if ENABLE_OPENMP
#pragma omp parallel for schedule(dynamic, 1) num_threads(2)
#endif
  for (int id = 0; id < 2; ++id) {
    const NttMod64& moder = *moderList[id];
    vector<uint64> XX(alignedSize);
    vector<uint64> YY(alignedSize);
    for (int i = 0; i < n; ++i) XX[i] = X[i];
    for (int i = n; i < alignedSize; ++i) XX[i] = 0;
    for (int i = 0; i < m; ++i) YY[i] = Y[i];
    for (int i = m; i < alignedSize; ++i) YY[i] = 0;
#if ENABLE_OPENMP
#pragma omp parallel sections if (n + m >= 100000)
#endif
    {
#if ENABLE_OPENMP
#pragma omp section
#endif
      ntt(&XX[0], alignedSize, moder);
#if ENABLE_OPENMP
#pragma omp section
#endif
      ntt(&YY[0], alignedSize, moder);
    }
    const uint64 mod = moder.mod;
    for (int i = 0; i < alignedSize; ++i) {
#if PE_HAS_INT128
      XX[i] = mod128_64(static_cast<uint128>(XX[i]) * YY[i], mod);
#else
      XX[i] = mul_mod_ex(XX[i], YY[i], mod);
#endif
    }
    ntt(&XX[0], alignedSize, moder, true);
    tresult[id] = std::move(XX);
  }

  const int resultSize = n + m - 1;
#if ENABLE_OPENMP
#pragma omp parallel for schedule(dynamic, 100000) if (n + m >= 100000)
#endif
  for (int i = 0; i < resultSize; ++i) {
    const uint64 a = tresult[0][i];
    const uint64 b = tresult[1][i];
    const uint64 x = b >= a ? b - a : b + ntt_constant::M2 - a;
#if PE_HAS_INT128
    const uint64 y = mod128_64(
        static_cast<uint128>(x) * ntt_constant::INV_M1__M2, ntt_constant::M2);
    const uint128 t = static_cast<uint128>(y) * ntt_constant::M1 + a;
    result[i] = mod > 0 ? t % mod : t;
#else
    PE_ASSERT(mod > 0);
    const uint64 y = mul_mod_ex(x, ntt_constant::INV_M1__M2, ntt_constant::M2);
    const uint64 t = mul_mod_ex(y % mod, ntt_constant::M1 % mod, mod);
    result[i] = add_mod(t, a % mod, mod);
#endif
  }
}

// Multiply two polynomials.
// The length of result is at least n + m - 1.
template <typename T>
SL REQUIRES((is_native_integer<T>::value)) RETURN(void)
    poly_mul_large(const T* X, const int n, const T* Y, const int m, T* result,
                   int64 mod) {
  using unsignedT = typename std::make_unsigned<T>::type;
  poly_mul_wrapper<unsignedT>((const unsignedT*)X, n, (const unsignedT*)Y, m,
                              (unsignedT*)result, mod,
                              &poly_mul_large_internal<unsignedT>);
}

template <typename T>
SL REQUIRES((is_native_integer<T>::value)) RETURN(vector<T>)
    poly_mul_large(const vector<T>& X, const vector<T>& Y, int64 mod) {
  const int n = (int)X.size();
  const int m = (int)Y.size();

  vector<T> result(n + m - 1);
  poly_mul_large(&X[0], n, &Y[0], m, &result[0], mod);

  return result;
}

// Multiply two polynomials.
// Make sure the length of result is at least: n + m - 1
template <typename T>
SL REQUIRES((is_native_integer<T>::value)) RETURN(void)
    poly_mul_small_internal(const T* X, int n, const T* Y, int m, T* result,
                            int64 mod) {
  static_assert(std::is_unsigned<T>::value, "T must be unsigned");

  const int alignedSize = 1 << pe_lg(2 * (n + m - 1) - 1);

  // TODO(baihacker): decide the size automatically.
  const NttMod64* moderList[1] = {&nttMod2};
  vector<uint64> tresult[1];
  for (int id = 0; id < 1; ++id) {
    const NttMod64& moder = *moderList[id];
    vector<uint64> XX(alignedSize);
    vector<uint64> YY(alignedSize);
    for (int i = 0; i < n; ++i) XX[i] = X[i];
    for (int i = n; i < alignedSize; ++i) XX[i] = 0;
    for (int i = 0; i < m; ++i) YY[i] = Y[i];
    for (int i = m; i < alignedSize; ++i) YY[i] = 0;
#if ENABLE_OPENMP
#pragma omp parallel sections if (n + m >= 100000)
#endif
    {
#if ENABLE_OPENMP
#pragma omp section
#endif
      ntt(&XX[0], alignedSize, moder);
#if ENABLE_OPENMP
#pragma omp section
#endif
      ntt(&YY[0], alignedSize, moder);
    }
    const uint64 mod = moder.mod;
    for (int i = 0; i < alignedSize; ++i) {
#if PE_HAS_INT128
      XX[i] = mod128_64(static_cast<uint128>(XX[i]) * YY[i], mod);
#else
      XX[i] = mul_mod_ex(XX[i], YY[i], mod);
#endif
    }
    ntt(&XX[0], alignedSize, moder, true);
    tresult[id] = std::move(XX);
  }

  const int resultSize = n + m - 1;
#if ENABLE_OPENMP
#pragma omp parallel for schedule(dynamic, 100000) if (n + m >= 100000)
#endif
  for (int i = 0; i < resultSize; ++i) {
    const uint64 a = tresult[0][i];
    result[i] = mod > 0 ? a % mod : a;
  }
}

// Multiply two polynomials.
// The length of result is at least n + m - 1.
template <typename T>
SL REQUIRES((is_native_integer<T>::value)) RETURN(void)
    poly_mul_small(const T* X, const int n, const T* Y, const int m, T* result,
                   int64 mod) {
  using unsignedT = typename std::make_unsigned<T>::type;
  poly_mul_wrapper<unsignedT>((const unsignedT*)X, n, (const unsignedT*)Y, m,
                              (unsignedT*)result, mod,
                              &poly_mul_small_internal<unsignedT>);
}

template <typename T>
SL REQUIRES((is_native_integer<T>::value)) RETURN(vector<T>)
    poly_mul_small(const vector<T>& X, const vector<T>& Y, int64 mod) {
  const int n = (int)X.size();
  const int m = (int)Y.size();

  vector<T> result(n + m - 1);
  poly_mul_small(&X[0], n, &Y[0], m, &result[0], mod);

  return result;
}
}  // namespace ntt64

template <typename T>
SL REQUIRES((is_native_integer<T>::value)) RETURN(void)
    poly_add(const T* X, const int n, const T* Y, const int m, T* result,
             int64 mod) {
  if (n <= m) {
    for (int i = 0; i < n; ++i) {
      result[i] = add_mod(X[i], Y[i], mod);
    }
    copy(Y + n, Y + m, result + n);
  } else {
    for (int i = 0; i < m; ++i) {
      result[i] = add_mod(X[i], Y[i], mod);
    }
    copy(X + m, X + n, result + m);
  }
}

template <typename T>
SL REQUIRES((is_native_integer<T>::value)) RETURN(vector<T>)
    poly_add(const vector<T>& X, const vector<T>& Y, int64 mod) {
  const int n = (int)X.size();
  const int m = (int)Y.size();

  vector<T> result(max(n, m));
  poly_add(&X[0], n, &Y[0], m, &result[0], mod);

  return result;
}

template <typename T>
SL REQUIRES((is_native_integer<T>::value)) RETURN(void)
    poly_sub(const T* X, const int n, const T* Y, const int m, T* result,
             int64 mod) {
  if (n <= m) {
    for (int i = 0; i < n; ++i) {
      result[i] = sub_mod(X[i], Y[i], mod);
    }
    for (int i = n; i < m; ++i) {
      result[i] = Y[i] == 0 ? 0 : mod - Y[i];
    }
  } else {
    for (int i = 0; i < m; ++i) {
      result[i] = sub_mod(X[i], Y[i], mod);
    }
    copy(X + m, X + n, result + m);
  }
}

template <typename T>
SL REQUIRES((is_native_integer<T>::value)) RETURN(vector<T>)
    poly_sub(const vector<T>& X, const vector<T>& Y, int64 mod) {
  const int n = (int)X.size();
  const int m = (int)Y.size();

  vector<T> result(max(n, m));
  poly_sub(&X[0], n, &Y[0], m, &result[0], mod);

  return result;
}

// Multiply two polynomials of the same length.
// size result >= 2 * n
// size return = 2 * n (deg return = 2 * n - 1)
template <typename T>
SL REQUIRES((is_native_integer<T>::value)) RETURN(void)
    poly_mul_dc_internal(const T* X, const T* Y, const int n, T* result,
                         int64 mod) {
  static_assert(std::is_unsigned<T>::value, "T must be unsigned");

  const int n2 = n << 1;
  if (n <= 49) {
    fill(result, result + n2, 0);
    for (int i = 0; i < n; ++i)
      for (int j = 0; j < n; ++j) {
        result[i + j] =
            add_mod(result[i + j], mul_mod_ex(X[i], Y[j], mod), mod);
      }
    return;
  }

  const int m1 = (n + 1) >> 1;
  const int m0 = n - m1;
  const int dbm1 = m1 << 1;
  const int dbm0 = m0 << 1;
  // m1 >= m0
  const T* x0 = X + m1;
  const T* y0 = Y + m1;
  const T* x1 = X;
  const T* y1 = Y;

  T* x0y0 = new T[dbm1];
  T* x1y1 = new T[dbm1];
#if ENABLE_OPENMP
#pragma omp parallel sections if (n > 5000)
#endif
  {
#if ENABLE_OPENMP
#pragma omp section
#endif
    poly_mul_dc_internal(x0, y0, m0, x0y0, mod);
#if ENABLE_OPENMP
#pragma omp section
#endif
    poly_mul_dc_internal(x1, y1, m1, x1y1, mod);
  }
  if (m0 != m1) {
    x0y0[dbm0] = 0;
    x0y0[dbm0 + 1] = 0;
  }
  T* w = new T[dbm1];
  {
    T* u = new T[m1];
    T* v = new T[m1];

    for (int i = 0; i < m0; ++i)
      u[i] = add_mod(x0[i], x1[i], mod), v[i] = add_mod(y0[i], y1[i], mod);
    if (m0 != m1) {
      u[m1 - 1] = x1[m1 - 1];
      v[m1 - 1] = y1[m1 - 1];
    }
    poly_mul_dc_internal(u, v, m1, w, mod);
    delete[] u;
    delete[] v;
    for (int i = 0; i < m1 * 2; ++i)
      w[i] = sub_mod(w[i], add_mod(x0y0[i], x1y1[i], mod), mod);
  }
  fill(result, result + n2, 0);
  for (int i = 0; i < dbm0; ++i)
    result[dbm1 + i] = add_mod(result[dbm1 + i], x0y0[i], mod);
  for (int i = 0; i < dbm1; ++i)
    result[m1 + i] = add_mod(result[m1 + i], w[i], mod);
  for (int i = 0; i < dbm1; ++i) result[i] = add_mod(result[i], x1y1[i], mod);
  delete[] x0y0;
  delete[] x1y1;
  delete[] w;
}

// Multiply two polynomials.
// size result >= n + m - 1
template <typename T>
SL REQUIRES((is_native_integer<T>::value)) RETURN(void)
    poly_mul_dc(const T* X, const int n, const T* Y, const int m, T* result,
                int64 mod) {
  using unsignedT = typename std::make_unsigned<T>::type;
  // In case n == m, we still allocate tempory result space to meet the
  // requirement of poly_mul_dc_internal.
  const int v = max(n, m);
  vector<T> tresult(v * 2);
  if (n < m) {
    vector<T> XX(2 * v);
    for (int i = 0; i < n; ++i) {
      XX[i] = X[i];
    }
    for (int i = n; i < m; ++i) {
      XX[i] = 0;
    }
    poly_mul_dc_internal<unsignedT>((const unsignedT*)&XX[0],
                                    (const unsignedT*)Y, m,
                                    (unsignedT*)&tresult[0], mod);
  } else {
    vector<T> YY(2 * v);
    for (int i = 0; i < m; ++i) {
      YY[i] = Y[i];
    }
    for (int i = m; i < n; ++i) {
      YY[i] = 0;
    }
    poly_mul_dc_internal<unsignedT>((const unsignedT*)X,
                                    (const unsignedT*)&YY[0], n,
                                    (unsignedT*)&tresult[0], mod);
  }
  copy(tresult.begin(), tresult.begin() + n + m - 1, result);
}

template <typename T>
SL REQUIRES((is_native_integer<T>::value)) RETURN(vector<T>)
    poly_mul_dc(const vector<T>& X, const vector<T>& Y, int64 mod) {
  using unsignedT = typename std::make_unsigned<T>::type;

  const int n = (int)X.size();
  const int m = (int)Y.size();
  const int resultSize = n + m - 1;
  if (n == m) {
    vector<T> result(2 * n);
    poly_mul_dc_internal<unsignedT>((const unsignedT*)&X[0],
                                    (const unsignedT*)&Y[0], n,
                                    (unsignedT*)&result[0], mod);
    result.resize(resultSize);
    return result;
  } else if (n > m) {
    vector<T> YY;
    vector<T> result(2 * n);
    YY.resize(n);
    for (int i = 0; i < m; ++i) YY[i] = Y[i];
    poly_mul_dc_internal<unsignedT>((const unsignedT*)&X[0],
                                    (const unsignedT*)&YY[0], n,
                                    (unsignedT*)&result[0], mod);
    result.resize(resultSize);
    return result;
  } else {
    vector<T> XX;
    vector<T> result(2 * m);
    XX.resize(m);
    for (int i = 0; i < n; ++i) XX[i] = X[i];
    poly_mul_dc_internal<unsignedT>((const unsignedT*)&XX[0],
                                    (const unsignedT*)&Y[0], m,
                                    (unsignedT*)&result[0], mod);
    result.resize(resultSize);
    return result;
  }
}

template <typename T>
SL REQUIRES((is_native_integer<T>::value)) RETURN(void)
    poly_mul(const T* X, const int n, const T* Y, const int m, T* result,
             int64 mod) {
  using unsignedT = typename std::make_unsigned<T>::type;

  const int isBig = max(n, m) >= 50;
  if (isBig) {
#if HAS_POLY_MUL_FLINT
    poly_flint::poly_mul_nmod(&X[0], n, &Y[0], m, result, mod);
#elif HAS_POLY_MUL_MIN25
    poly_min25::poly_mul_large(&X[0], n, &Y[0], m, result, mod);
#elif HAS_POLY_MUL_NTT32
    ntt32::poly_mul_large(&X[0], n, &Y[0], m, result, mod);
#elif HAS_POLY_MUL_NTT64
    ntt64::poly_mul_large(&X[0], n, &Y[0], m, result, mod);
#else

#if defined(COMPILER_GNU)
#warning "poly_mul may be very slow."
#else
#pragma message("poly_mul may be very slow.")
#endif

    poly_mul_dc(&X[0], n, &Y[0], m, result, mod);
#endif
  } else {
    poly_mul_dc(&X[0], n, &Y[0], m, result, mod);
  }
}

template <typename T>
SL REQUIRES((is_native_integer<T>::value)) RETURN(vector<T>)
    poly_mul(const vector<T>& X, const vector<T>& Y, int64 mod) {
  const int n = (int)X.size();
  const int m = (int)Y.size();

  vector<T> result(n + m - 1);
  poly_mul(&X[0], n, &Y[0], m, &result[0], mod);

  return result;
}

template <typename T>
SL REQUIRES((is_native_integer<T>::value)) RETURN(void)
    poly_inv_doubling_internal(int n, const T* a, T* b, T* tmp[2], int64 mod) {
  static_assert(std::is_unsigned<T>::value, "T must be unsigned");
  if (n == 1) {
    b[0] = power_mod_ex(a[0], mod - 2, mod);
  } else {
    const int m = (n + 1) >> 1;
    poly_inv_doubling_internal(m, a, b, tmp, mod);
    fill(b + m, b + n, 0);
    poly_mul(b, m, b, m, tmp[0], mod);
    if (m + m - 2 < n - 1) {
      tmp[0][n - 1] = 0;
    }
    poly_mul(a, n, tmp[0], n, tmp[1], mod);
    for (int i = 0; i < n; ++i) {
      auto t = b[i] << 1;
      if (t >= static_cast<uint64>(mod)) t -= mod;
      t = t + mod - tmp[1][i];
      if (t >= static_cast<uint64>(mod)) t -= mod;
      b[i] = t;
    }
  }
}

// size result >= n
template <typename T>
SL REQUIRES((is_native_integer<T>::value)) RETURN(void)
    poly_inv_doubling_internal(const T* x, int m, int n, T* result, int64 mod) {
  // It is assumed that mod is a prime
  const int t = max(n, m);
  const int p = 1 << pe_lg(4 * t - 1);

  // a
  vector<T> a(p);
  for (int i = 0; i < m; ++i) {
    a[i] = x[i];
  }
  for (int i = m; i < p; ++i) {
    a[i] = 0;
  }

  // b
  vector<T> b(n);

  // tmp
  vector<T> tmpData[2];
  T* tmp[2];
  for (int i = 0; i < 2; ++i) {
    tmpData[i].resize(p);
    tmp[i] = &tmpData[i][0];
  }

  poly_inv_doubling_internal(n, &a[0], &b[0], tmp, mod);
  copy(b.begin(), b.begin() + n, result);
}

// size result >= n
template <typename T>
SL REQUIRES((is_native_integer<T>::value)) RETURN(void)
    poly_inv_doubling(const T* x, int m, int n, T* result, int64 mod) {
  using unsignedT = typename std::make_unsigned<T>::type;
  poly_inv_doubling_internal<unsignedT>((const unsignedT*)x, m, n,
                                        (unsignedT*)result, mod);
}

template <typename T>
SL REQUIRES((is_native_integer<T>::value)) RETURN(vector<T>)
    poly_inv_doubling(const vector<T>& x, int n, int64 mod) {
  // It is assumed that mod is a prime
  const int m = (int)x.size();

  // b
  vector<T> b(n);

  poly_inv_doubling(&x[0], m, n, &b[0], mod);

  return b;
}

// size result >= n
template <typename T>
SL REQUIRES((is_native_integer<T>::value)) RETURN(void)
    poly_inv(const T* x, int m, int n, T* result, int64 mod) {
  using unsignedT = typename std::make_unsigned<T>::type;
#if HAS_POLY_FLINT
  poly_flint::poly_inv<unsignedT>((const unsignedT*)x, m, n, (unsignedT*)result,
                                  mod);
#else
  poly_inv_doubling<unsignedT>((const unsignedT*)x, m, n, (unsignedT*)result,
                               mod);
#endif
}

template <typename T>
SL REQUIRES((is_native_integer<T>::value)) RETURN(vector<T>)
    poly_inv(const vector<T>& x, int n, int64 mod) {
  // It is assumed that mod is a prime
  const int m = (int)x.size();

  // b
  vector<T> b(n);

  poly_inv(&x[0], m, n, &b[0], mod);

  return b;
}

// size r >= m
// size q >= n - m + 1
template <typename T>
SL REQUIRES((is_native_integer<T>::value)) RETURN(void)
    poly_div_and_mod_dc_internal(const T* X, int n, const T* Y, int m, T* q,
                                 T* r, int64 mod) {
  static_assert(std::is_unsigned<T>::value, "T must be unsigned");

  if (m > n) {
    if (r) {
      copy(X, X + n, r);
      fill(r + n, r + m, 0);
    }
    if (q) {
      q[0] = 0;
    }
    return;
  }
  vector<T> YR(m);
  for (int i = 0; i < m; ++i) YR[i] = Y[m - 1 - i];
  vector<T> IYR = poly_inv(YR, n - m + 1, mod);
  vector<T> XR(n);
  for (int i = 0; i < n; ++i) XR[i] = X[n - 1 - i];
  vector<T> Z = poly_mul(XR, IYR, mod);
  Z.resize(n - m + 1);
  reverse(Z.begin(), Z.end());
  if (q) {
    copy(Z.begin(), Z.end(), q);
  }
  if (r) {
    vector<T> tmp(n);
    poly_mul(&Y[0], m, &Z[0], n - m + 1, &tmp[0], mod);
    for (int i = 0; i < m; ++i) {
      r[i] = X[i] >= tmp[i] ? X[i] - tmp[i] : X[i] + mod - tmp[i];
    }
  }
}

POLY_DIV_AND_MOD_IMPL(poly_div_and_mod_dc, poly_div_and_mod_dc_internal)
POLY_DIV_IMPL(poly_div_dc, poly_div_and_mod_dc)
POLY_MOD_IMPL(poly_mod_dc, poly_div_and_mod_dc)

// size q >= n - m + 1
// size r >= m
template <typename T>
SL REQUIRES((is_native_integer<T>::value)) RETURN(void)
    poly_div_and_mod_normal_internal(const T* X, int n, const T* Y, int m, T* q,
                                     T* r, int64 mod) {
  static_assert(std::is_unsigned<T>::value, "T must be unsigned");

  if (m > n) {
    if (r) {
      copy(X, X + n, r);
      fill(r + n, r + m, 0);
    }
    if (q) {
      q[0] = 0;
    }
    return;
  }

  int top = 0;
  vector<T> tmp(X, X + n);
  int64 t = inv_of(Y[m - 1], mod);
  for (int i = n - 1; i >= m - 1; --i) {
    int64 u = mul_mod_ex(tmp[i], t, mod);
    for (int j = i, k = m - 1; k >= 0; --j, --k) {
      tmp[j] = sub_mod(tmp[j], mul_mod_ex(u, Y[k], mod), mod);
    }
    if (q) {
      q[top++] = u;
    }
  }
  if (q) {
    reverse(q, q + top);
  }
  if (r) {
    copy(tmp.begin(), tmp.begin() + m, r);
  }
}

POLY_DIV_AND_MOD_IMPL(poly_div_and_mod_normal, poly_div_and_mod_normal_internal)
POLY_DIV_IMPL(poly_div_normal, poly_div_and_mod_normal)
POLY_MOD_IMPL(poly_mod_normal, poly_div_and_mod_normal)

template <typename T>
SL REQUIRES((is_native_integer<T>::value)) RETURN(void)
    poly_div_and_mod(const T* X, const int n, const T* Y, const int m, T* q,
                     T* r, int64 mod) {
  using unsignedT = typename std::make_unsigned<T>::type;
#if HAS_POLY_FLINT
  poly_flint::poly_div_and_mod_internal<unsignedT>(
      (const unsignedT*)X, n, (const unsignedT*)Y, m, (unsignedT*)q,
      (unsignedT*)r, mod);
#else
  // This condition also includes the case n < m;
  if ((n - m) * m <= 1000) {
    poly_div_and_mod_normal_internal<unsignedT>(
        (const unsignedT*)X, n, (const unsignedT*)Y, m, (unsignedT*)q,
        (unsignedT*)r, mod);
  } else {
    poly_div_and_mod_dc_internal<unsignedT>((const unsignedT*)X, n,
                                            (const unsignedT*)Y, m,
                                            (unsignedT*)q, (unsignedT*)r, mod);
  }
#endif
}

template <typename T>
SL REQUIRES((is_native_integer<T>::value)) RETURN(tuple<vector<T>, vector<T>>)
    poly_div_and_mod(const vector<T>& X, const vector<T>& Y, int64 mod) {
  const int n = (int)X.size() - 1;
  const int m = (int)Y.size() - 1;

  vector<T> q(max(n - m + 1, 1));
  vector<T> r(m + 1);
  poly_div_and_mod(&X[0], n + 1, &Y[0], m + 1, &q[0], &r[0], mod);

  r[m] = 0;
  adjust_poly_leading_zero(r);
  return make_tuple(std::move(q), std::move(r));
}

POLY_DIV_IMPL(poly_div, poly_div_and_mod)
POLY_MOD_IMPL(poly_mod, poly_div_and_mod)

// size result == m
template <typename T>
SL REQUIRES((is_native_integer<T>::value)) RETURN(void)
    poly_derivative_internal(const T* x, int m, T* result, int64 mod) {
  for (int i = 1; i < m; ++i) {
    result[i - 1] = mul_mod_ex(x[i], i, mod);
  }
  result[m - 1] = 0;
}

// size result == m
template <typename T>
SL REQUIRES((is_native_integer<T>::value)) RETURN(void)
    poly_derivative(const T* x, int m, T* result, int64 mod) {
  using unsignedT = typename std::make_unsigned<T>::type;
  poly_derivative_internal<unsignedT>((const unsignedT*)x, m,
                                      (unsignedT*)result, mod);
}

// size result == m
template <typename T>
SL REQUIRES((is_native_integer<T>::value)) RETURN(vector<T>)
    poly_derivative(const vector<T>& x, int64 mod) {
  // It is assumed that mod is a prime
  const int m = (int)x.size();

  // b
  vector<T> b(m);

  poly_derivative(&x[0], m, &b[0], mod);

  return b;
}

// size result == m + 1
template <typename T>
SL REQUIRES((is_native_integer<T>::value)) RETURN(void)
    poly_integral_internal(const T* x, int m, T* result, int64 mod) {
  vector<T> y(m + 1);
  init_inv(&y[0], m, mod);
  for (int i = 0; i < m; ++i) {
    result[i + 1] = mul_mod_ex(x[i], y[i + 1], mod);
  }
  result[0] = static_cast<T>(1 % mod);
}

// size result == m + 1
template <typename T>
SL REQUIRES((is_native_integer<T>::value)) RETURN(void)
    poly_integral(const T* x, int m, T* result, int64 mod) {
  using unsignedT = typename std::make_unsigned<T>::type;
  poly_integral_internal<unsignedT>((const unsignedT*)x, m, (unsignedT*)result,
                                    mod);
}

// size result == m + 1
template <typename T>
SL REQUIRES((is_native_integer<T>::value)) RETURN(vector<T>)
    poly_integral(const vector<T>& x, int64 mod) {
  // It is assumed that mod is a prime
  const int m = (int)x.size();

  // b
  vector<T> b(m);

  poly_integral(&x[0], m, &b[0], mod);

  return b;
}

// size result == n
template <typename T>
SL REQUIRES((is_native_integer<T>::value)) RETURN(void)
    poly_log_normal_internal(const T* x, int m, int n, T* result, int64 mod) {
  vector<T> dx(m);
  poly_derivative(x, m, &dx[0], mod);

  vector<T> y(n);
  poly_inv(x, m, n, &y[0], mod);

  vector<T> z(m - 1 + n - 1);
  poly_mul(&dx[0], m - 1, &y[0], n, &z[0], mod);

  init_inv(&y[0], n - 1, mod);

  for (int i = 0; i < n - 1; ++i) {
    result[i + 1] = mul_mod_ex(z[i], y[i + 1], mod);
  }
  result[0] = 0;
}

// size result == n
template <typename T>
SL REQUIRES((is_native_integer<T>::value)) RETURN(void)
    poly_log_normal(const T* x, int m, int n, T* result, int64 mod) {
  using unsignedT = typename std::make_unsigned<T>::type;
  poly_log_normal_internal<unsignedT>((const unsignedT*)x, m, n,
                                      (unsignedT*)result, mod);
}

template <typename T>
SL REQUIRES((is_native_integer<T>::value)) RETURN(vector<T>)
    poly_log_normal(const vector<T>& x, int n, int64 mod) {
  // It is assumed that mod is a prime
  const int m = (int)x.size();

  // b
  vector<T> b(n);

  poly_log_normal(&x[0], m, n, &b[0], mod);

  return b;
}

// size result == n
template <typename T>
SL REQUIRES((is_native_integer<T>::value)) RETURN(void)
    poly_log(const T* x, int m, int n, T* result, int64 mod) {
  using unsignedT = typename std::make_unsigned<T>::type;
#if HAS_POLY_FLINT
  poly_flint::poly_log<unsignedT>((const unsignedT*)x, m, n, (unsignedT*)result,
                                  mod);
#else
  poly_log_normal<unsignedT>((const unsignedT*)x, m, n, (unsignedT*)result,
                             mod);
#endif
}

template <typename T>
SL REQUIRES((is_native_integer<T>::value)) RETURN(vector<T>)
    poly_log(const vector<T>& x, int n, int64 mod) {
  // It is assumed that mod is a prime
  const int m = (int)x.size();

  // b
  vector<T> b(n);

  poly_log(&x[0], m, n, &b[0], mod);

  return b;
}

// size result == n
template <typename T>
SL REQUIRES((is_native_integer<T>::value)) RETURN(void)
    poly_exp_normal_internal(const T* x, int m, int n, T* result, int64 mod) {
  PE_ASSERT(x[0] == 0);
  vector<T> ret{static_cast<T>(1 % mod)};

  for (int u = 1; u < 2 * n; u = u << 1) {
    vector<T> t0(u);
    poly_log_normal(&ret[0], u, u, &t0[0], mod);

    vector<T> t1(u);
    poly_sub(x, min(u, m), &t0[0], u, &t1[0], mod);
    t1[0] = add_mod(1, t1[0], mod);

    vector<T> t2(u << 1);
    poly_mul(&ret[0], u, &t1[0], u, &t2[0], mod);
    t2.resize(u << 1);
    ret = std::move(t2);
    ret[0] = 1;
  }

  ret.resize(n);
  copy(ret.begin(), ret.end(), result);
}

// size result == n
template <typename T>
SL REQUIRES((is_native_integer<T>::value)) RETURN(void)
    poly_exp_normal(const T* x, int m, int n, T* result, int64 mod) {
  using unsignedT = typename std::make_unsigned<T>::type;
  poly_exp_normal_internal<unsignedT>((const unsignedT*)x, m, n,
                                      (unsignedT*)result, mod);
}

template <typename T>
SL REQUIRES((is_native_integer<T>::value)) RETURN(vector<T>)
    poly_exp_normal(const vector<T>& x, int n, int64 mod) {
  // It is assumed that mod is a prime
  const int m = (int)x.size();

  // b
  vector<T> b(n);

  poly_exp_normal(&x[0], m, n, &b[0], mod);

  return b;
}

// size result == n
template <typename T>
SL REQUIRES((is_native_integer<T>::value)) RETURN(void)
    poly_exp(const T* x, int m, int n, T* result, int64 mod) {
  using unsignedT = typename std::make_unsigned<T>::type;
#if HAS_POLY_FLINT
  poly_flint::poly_exp<unsignedT>((const unsignedT*)x, m, n, (unsignedT*)result,
                                  mod);
#else
  poly_exp_normal<unsignedT>((const unsignedT*)x, m, n, (unsignedT*)result,
                             mod);
#endif
}

template <typename T>
SL REQUIRES((is_native_integer<T>::value)) RETURN(vector<T>)
    poly_exp(const vector<T>& x, int n, int64 mod) {
  // It is assumed that mod is a prime
  const int m = (int)x.size();

  // b
  vector<T> b(n);

  poly_exp(&x[0], m, n, &b[0], mod);

  return b;
}

// FactSumModer uses poly_multipoint_evaluate.
struct PSPTree {
  int64 mod;

  int64* v;
  int n;

  vector<int64> p;

  PSPTree* L;
  PSPTree* R;

  ~PSPTree() {
    if (L) delete L;
    if (R) delete R;
  }

  static PSPTree* build_minus(int64* values, int n, int64 mod) {
    auto* ptree = new PSPTree();
    auto& tree = *ptree;
    tree.mod = mod;
    tree.v = values;
    tree.n = n;
    tree.L = tree.R = nullptr;
    if (n == 1) {
      // -x0 + x
      int64 t = values[0];
      tree.p.emplace_back(t == 0 ? 0 : mod - t);
      tree.p.emplace_back(1 % mod);
      return ptree;
    }
    int c1 = n >> 1, c2 = n - c1;
    tree.L = build_minus(values, c1, mod);
    tree.R = build_minus(values + c1, c2, mod);
    tree.p = poly_mul(tree.L->p, tree.R->p, mod);
    return ptree;
  }

  static PSPTree* build_plus(int64* values, int n, int64 mod) {
    auto* ptree = new PSPTree();
    auto& tree = *ptree;
    tree.mod = mod;
    tree.v = values;
    tree.n = n;
    tree.L = tree.R = nullptr;
    if (n == 1) {
      // x0 + x
      int64 t = values[0];
      tree.p.emplace_back(t);
      tree.p.emplace_back(1);
      return ptree;
    }
    int c1 = n >> 1, c2 = n - c1;
    tree.L = build_plus(values, c1, mod);
    tree.R = build_plus(values + c1, c2, mod);
    tree.p = poly_mul(tree.L->p, tree.R->p, mod);
    return ptree;
  }
};

// size(V) = n
template <typename T>
SL REQUIRES((is_native_integer<T>::value)) RETURN(void)
    poly_multipoint_evaluate_normal_internal(const T* X, int n, PSPTree* psp,
                                             T* result, int64 mod) {
  if (psp->n == 1) {
    result[0] = (X[0] + psp->v[0] * X[1]) % mod;
    return;
  }
  int c1 = psp->n >> 1;
  int c2 = psp->n - c1;

  vector<T> m(max(psp->L->p.size(), psp->R->p.size()));
  poly_mod(X, n, (const T*)&psp->L->p[0], static_cast<int>(psp->L->p.size()),
           &m[0], mod);
  poly_multipoint_evaluate_normal_internal(
      &m[0], static_cast<int>(psp->L->p.size()) - 1, psp->L, result, mod);
  poly_mod(X, n, (const T*)&psp->R->p[0], static_cast<int>(psp->R->p.size()),
           &m[0], mod);
  poly_multipoint_evaluate_normal_internal(
      &m[0], static_cast<int>(psp->R->p.size()) - 1, psp->R, result + c1, mod);
}

// size(V) = n
template <typename T>
SL REQUIRES((is_native_integer<T>::value)) RETURN(void)
    poly_multipoint_evaluate_normal_internal(const T* X, int n, const T* V,
                                             T* result, int64 mod) {
  static_assert(std::is_unsigned<T>::value, "T must be unsigned");
  PSPTree* psp = PSPTree::build_minus((int64*)V, n, mod);
  poly_multipoint_evaluate_normal_internal(X, n, psp, result, mod);
  delete psp;
}

// Tellegen's Principle into Pratice
// A. Bostan, G. Lecerf, E. Schost
// size(V) = n
template <typename T>
SL REQUIRES((is_native_integer<T>::value)) RETURN(void)
    poly_multipoint_evaluate_bls_internal(const T* X, int n, const T* V,
                                          T* result, int64 mod) {
  static_assert(std::is_unsigned<T>::value, "T must be unsigned");
  vector<vector<vector<T>>> tree;
  {
    vector<vector<T>> from;
    for (int i = 0; i < n; ++i) {
      vector<T> tmp{(V[i] == 0 ? 0 : mod - V[i]) % mod, 1};
      from.push_back(tmp);
    }

    tree.push_back(from);
    int lastSize = n;
    while (lastSize != 1) {
      vector<vector<T>> to;
      to.reserve(lastSize / 2);
      for (int i = 0; i < lastSize / 2; ++i) {
        to.push_back(poly_mul(from[i * 2], from[i * 2 + 1], mod));
      }
      if (lastSize & 1) {
        to.push_back(from[lastSize - 1]);
      }
      lastSize = (lastSize + 1) >> 1;
      from.swap(to);
      tree.push_back(from);
    }
  }

  const int d = (int)tree.size() - 1;
  {
    auto alpha = tree[d][0];
    reverse(alpha.begin(), alpha.end());
    alpha = poly_inv(alpha, n, mod);
    reverse(alpha.begin(), alpha.end());

    vector<uint64> b(X, X + n);
    int degb = sz(b) - 1;
    auto t = poly_mul(alpha, b, mod);
    assert(sz(t) - 1 == n - 1 + degb);
    for (int i = n - 1, j = 0; i <= (n - 1) + degb; ++i, ++j) {
      t[j] = t[i];
    }
    assert(degb + 1 >= n);
    t.resize(n);
    reverse(t.begin(), t.end());

    vector<vector<T>> c(n);
    c[0] = std::move(t);
    // c[0] = vector<uint64>(X, X+n);
    for (int i = d; i > 0; --i) {
      int hi = (int)tree[i].size();
      for (int j = hi - 1; j >= 0; --j) {
        int u = j * 2;
        int v = u + 1;
        if (v >= tree[i - 1].size()) {
          c[u] = c[j];
          continue;
        }
        int nn = (int)tree[i][j].size() - 1;
        vector<T> x;
        {
          const int os = sz(tree[i - 1][2 * j]);
          reverse(tree[i - 1][2 * j].begin(), tree[i - 1][2 * j].end());
          x = poly_mul(tree[i - 1][2 * j], c[j], mod);
          int s = 0;
          for (int i = os - 1, j = 0; i < x.size() && j < nn; ++i, ++j) {
            x[j] = x[i];
            ++s;
          }
          x.resize(s);
        }
        vector<T> y;
        {
          const int os = sz(tree[i - 1][2 * j + 1]);
          reverse(tree[i - 1][2 * j + 1].begin(), tree[i - 1][2 * j + 1].end());
          y = poly_mul(tree[i - 1][2 * j + 1], c[j], mod);
          int s = 0;
          for (int i = os - 1, j = 0; i < y.size() && j < nn; ++i, ++j) {
            y[j] = y[i];
            ++s;
          }
          y.resize(s);
        }
        c[2 * j + 1] = std::move(x);
        c[2 * j] = std::move(y);
      }
    }
    for (int i = 0; i < n; ++i) result[i] = c[i][0];
  }
}

// size(V) = n
template <typename T>
SL REQUIRES((is_native_integer<T>::value)) RETURN(void)
    poly_multipoint_evaluate_normal(const T* X, const int n, const T* V,
                                    T* result, int64 mod) {
  using unsignedT = typename std::make_unsigned<T>::type;
  poly_multipoint_evaluate_normal_internal<unsignedT>(
      (const unsignedT*)X, n, (const unsignedT*)V, (unsignedT*)result, mod);
}

// size x = size v
template <typename T>
SL REQUIRES((is_native_integer<T>::value)) RETURN(vector<T>)
    poly_multipoint_evaluate_normal(const vector<T>& X, const vector<T>& V,
                                    int64 mod) {
  const int n = (int)X.size();
  vector<T> result(n);
  poly_multipoint_evaluate_normal(&X[0], n, &V[0], &result[0], mod);
  return result;
}

// size(V) = n
template <typename T>
SL REQUIRES((is_native_integer<T>::value)) RETURN(void)
    poly_multipoint_evaluate_bls(const T* X, const int n, const T* V, T* result,
                                 int64 mod) {
  using unsignedT = typename std::make_unsigned<T>::type;
  poly_multipoint_evaluate_bls_internal<unsignedT>(
      (const unsignedT*)X, n, (const unsignedT*)V, (unsignedT*)result, mod);
}

// size x = size v
template <typename T>
SL REQUIRES((is_native_integer<T>::value)) RETURN(vector<T>)
    poly_multipoint_evaluate_bls(const vector<T>& X, const vector<T>& V,
                                 int64 mod) {
  const int n = (int)X.size();
  vector<T> result(n);
  poly_multipoint_evaluate_bls(&X[0], n, &V[0], &result[0], mod);
  return result;
}

// size(V) = n
template <typename T>
SL REQUIRES((is_native_integer<T>::value)) RETURN(void)
    poly_multipoint_evaluate(const T* X, const int n, const T* V, T* result,
                             int64 mod) {
  using unsignedT = typename std::make_unsigned<T>::type;
#if HAS_POLY_FLINT
  poly_flint::poly_multipoint_evaluate<unsignedT>(
      (const unsignedT*)X, n, (const unsignedT*)V, (unsignedT*)result, mod);
#else
  poly_multipoint_evaluate_bls<unsignedT>(
      (const unsignedT*)X, n, (const unsignedT*)V, (unsignedT*)result, mod);
#endif
}

// size x = size v
template <typename T>
SL REQUIRES((is_native_integer<T>::value)) RETURN(vector<T>)
    poly_multipoint_evaluate(const vector<T>& X, const vector<T>& V,
                             int64 mod) {
  const int n = (int)X.size();
  vector<T> result(n);
  poly_multipoint_evaluate(&X[0], n, &V[0], &result[0], mod);
  return result;
}

// poly_offset_evaluate is used by FactModer

// Known f[0],f[1],f[2],...,f[d]
// Calculate f[0+offset],f[1+offset],f[2+offset],...,f[d+offset]
// offset > d
template <typename T>
SL REQUIRES((is_native_integer<T>::value)) RETURN(void)
    poly_offset_evaluate_internal(int d, const T* h, T* result, int64 offset,
                                  const T* preFactInv, T mod) {
  static_assert(std::is_unsigned<T>::value, "T must be unsigned");

  vector<T> A(d + 1);
  vector<T> B(2 * d + 1);
  vector<T> C(3 * d + 1);
  vector<T> T0(2 * d + 2);
  vector<T> T1(2 * d + 2);
  for (int i = 0; i <= d; ++i) {
    auto t = mul_mod_ex(h[i], preFactInv[i], mod);
    t = mul_mod_ex(t, preFactInv[d - i], mod);
    if ((d - i) & 1) {
      A[i] = t == 0 ? 0 : mod - t;
    } else {
      A[i] = t;
    }
  }

  T0[0] = T1[0] = 1;
  for (int i = -d, j = 1; i <= d; ++i, ++j) {
    T0[j] = mul_mod_ex(T0[j - 1], offset + i, mod);
  }

  T1[2 * d + 1] = power_mod_ex(T0[2 * d + 1], mod - 2, mod);
  for (int i = d - 1, j = 2 * d; i >= -d; --i, --j) {
    T1[j] = mul_mod_ex(T1[j + 1], offset + i + 1, mod);
  }

  for (int i = -d, j = 1; i <= d; ++i, ++j) {
    B[j - 1] = mul_mod_ex(T1[j], T0[j - 1], mod);
  }

  poly_mul(&A[0], d + 1, &B[0], 2 * d + 1, &C[0], mod);
  copy(&C[0] + d, &C[0] + 2 * d + 1, result);

  for (int i = 0, j = d + 1; i <= d; ++i, ++j) {
    result[i] = mul_mod_ex(result[i], T0[j], mod);
    result[i] = mul_mod_ex(result[i], T1[j - d - 1], mod);
  }
}

template <typename T>
SL REQUIRES((is_native_integer<T>::value)) RETURN(void)
    poly_offset_evaluate(int d, const T* h, T* result, int64 offset,
                         const T* preFactInv, T mod) {
  using unsignedT = typename std::make_unsigned<T>::type;
  poly_offset_evaluate_internal<unsignedT>(
      d, (const unsignedT*)h, (unsignedT*)result, offset, preFactInv, mod);
}

template <typename T>
SL REQUIRES((is_native_integer<T>::value)) RETURN(vector<T>)
    poly_offset_evaluate(const vector<T>& values, int64 offset,
                         const T* preFactInv, T mod) {
  const int d = (int)values.size() - 1;
  vector<T> result(d + 1);
  poly_offset_evaluate(d, &values[0], &result[0], offset, preFactInv, mod);
  return std::move(result);
}

#if 0
// Y = X
// s(i) = (Y[1]*x+Y[0])(Y[3]x+Y[2])...(Y[2i+1]x+Y[2i])
// return s(n-1)
// size s(n-1) = n + 1
template <typename T>
SL REQUIRES((is_native_integer<T>::value)) RETURN(void)
    poly_batch_mul_internal(const T* X, int n, T* result,
                                   int64 mod) {
  static_assert(std::is_unsigned<T>::value, "T must be unsigned");
  vector<vector<T>> from;
  for (int i = 0; i < n; ++i) {
    vector<T> tmp{X[2*i] % mod, X[2*i+1]%mod};
    from.push_back(tmp);
  }
  int lastSize = n;
  while (lastSize != 1) {
    vector<vector<T>> to;
    for (int i = 0; i < lastSize / 2; ++i) {
      to.push_back(poly_mul(from[i * 2], from[i * 2 + 1], mod));
    }
    if (lastSize & 1) {
      to.push_back(from[lastSize - 1]);
    }
    lastSize = lastSize + 1 >> 1;
    from.swap(to);
  }
  auto& t = from[0];
  PE_ASSERT(sz(t) == n + 1);
  copy(t.begin(), t.end(), result);
}

// n = e - s
// Y = X[2s:2e]
// s(i) = (Y[1]*x+Y[0])(Y[3]x+Y[2])...(Y[2i+1]x+Y[2i])
// return s(n-1)
// size s(n-1) = n + 1
template <typename T>
SL REQUIRES((is_native_integer<T>::value)) RETURN(void)
    poly_batch_mul_internal(const T* X, int s, int e, T* result,
                                   int64 mod) {
  poly_batch_mul_internal(X + 2 * s, e - s, result, mod);
}
#else
// n = e - s
// Y = X[2s:2e]
// s(i) = (Y[1]*x+Y[0])(Y[3]x+Y[2])...(Y[2i+1]x+Y[2i])
// return s(n-1)
// size s(n-1) = n + 1
template <typename T>
SL REQUIRES((is_native_integer<T>::value)) RETURN(void)
    poly_batch_mul_internal(const T* X, int s, int e, T* result, int64 mod) {
  static_assert(std::is_unsigned<T>::value, "T must be unsigned");
  const int n = e - s;
  if (n == 1) {
    copy(X + s * 2, X + e * 2, result);
    return;
  }
  const int half = n >> 1;
  vector<T> A(half + 1);
  vector<T> B(n - half + 1);
#if ENABLE_OPENMP
#pragma omp parallel sections if (n > 5000)
#endif
  {
#if ENABLE_OPENMP
#pragma omp section
#endif
    poly_batch_mul_internal(X, s, s + half, &A[0], mod);
#if ENABLE_OPENMP
#pragma omp section
#endif
    poly_batch_mul_internal(X, s + half, e, &B[0], mod);
  }
  poly_mul(&A[0], half + 1, &B[0], n - half + 1, result, mod);
}
#endif

// Y = X
// s(i) = (Y[1]*x+Y[0])(Y[3]x+Y[2])...(Y[2i+1]x+Y[2i])
// return s(n-1)
// size s(n-1) = n + 1
template <typename T>
SL REQUIRES((is_native_integer<T>::value)) RETURN(void)
    poly_batch_mul(const T* X, const int n, T* result, int64 mod) {
  using unsignedT = typename std::make_unsigned<T>::type;
  poly_batch_mul_internal<unsignedT>((const unsignedT*)X, 0, n,
                                     (unsignedT*)result, mod);
}

// n = size X / 2
// Y = X
// s(i) = (Y[1]*x+Y[0])(Y[3]x+Y[2])...(Y[2i+1]x+Y[2i])
// return s(n-1)
// size s(n-1) = n + 1
template <typename T>
SL REQUIRES((is_native_integer<T>::value)) RETURN(vector<T>)
    poly_batch_mul(const vector<T>& X, int64 mod) {
  const int n = (int)X.size();
  vector<T> result(n / 2 + 1);
  poly_batch_mul(&X[0], n / 2, &result[0], mod);
  return result;
}

// poly_batch_mul_acc is used by FactSumModer

#if 0
// n = e - s
// Y = X[2s:2e]
// s(i) = (Y[1]*x+Y[0])(Y[3]x+Y[2])...(Y[2i+1]x+Y[2i])
// return s(0) + s(2) + s(3) + ... + s(n-1)
template <typename T>
SL REQUIRES((is_native_integer<T>::value)) RETURN(vector<T>)
poly_batch_mul_acc(const vector<T>& X, int s, int e, uint64 mod) {
  const int n = e - s;
  if (n == 1) {
    return vector<T>(X.begin() + s * 2, X.begin() + e * 2);
  }

  const int half = n / 2;
  vector<T> A, B, C;
#if ENABLE_OPENMP
#pragma omp parallel sections if (n > 5000)
#endif
  {
#if ENABLE_OPENMP
#pragma omp section
#endif
    A = poly_batch_mul_acc(X, s, s + half, mod);
#if ENABLE_OPENMP
#pragma omp section
#endif
    B = poly_batch_mul_acc(X, s + half, e, mod);
#if ENABLE_OPENMP
#pragma omp section
#endif
    C = poly_batch_mul(vector<T>(X.begin() + s * 2, X.begin() + (s + half)*2), mod);
  }

  B = poly_mul(B, C, mod);
  return poly_add(A, B, mod);
}

// n = X.size() / 2
// Y = X
// s(i) = (Y[1]*x+Y[0])(Y[3]x+Y[2])...(Y[2i+1]x+Y[2i])
// return s(0) + s(2) + s(3) + ... + s(n-1)
template <typename T>
SL REQUIRES((is_native_integer<T>::value)) RETURN(vector<T>)
poly_batch_mul_acc(const vector<T>& X, uint64 mod) {
  return poly_batch_mul_acc(X, 0, X.size() / 2, mod);
}

// n = e - s
// Y = X[2s:2e]
// s(i) = (Y[1]*x+Y[0])(Y[3]x+Y[2])...(Y[2i+1]x+Y[2i])
// M = s(n-1)
// return s(0) + s(2) + s(3) + ... + s(n-1)
template <typename T>
SL REQUIRES((is_native_integer<T>::value)) RETURN(vector<T>)
poly_batch_mul_acc(const vector<T>& X, int s, int e, vector<T>& M, uint64 mod) {
  vector<T> Y(X.begin() + s * 2, X.begin() + e * 2);
  M = poly_batch_mul(Y, mod);
  return poly_batch_mul_acc(Y, mod);
}
#else
// n = e - s
// Y = X[2s:2e]
// s(i) = (Y[1]*x+Y[0])(Y[3]x+Y[2])...(Y[2i+1]x+Y[2i])
// M = s(n-1)
// return s(0) + s(2) + s(3) + ... + s(n-1)
template <typename T>
SL REQUIRES((is_native_integer<T>::value)) RETURN(vector<T>)
    poly_batch_mul_acc(const vector<T>& X, int s, int e, vector<T>& M,
                       uint64 mod) {
  const int n = e - s;
  if (n == 1) {
    vector<T> t(X.begin() + s * 2, X.begin() + e * 2);
    M = t;
    return t;
  }
  vector<T> C, D;
  const int half = n / 2;
  vector<T> A, B;
#if ENABLE_OPENMP
#pragma omp parallel sections if (n > 5000)
#endif
  {
#if ENABLE_OPENMP
#pragma omp section
#endif
    A = poly_batch_mul_acc(X, s, s + half, C, mod);
#if ENABLE_OPENMP
#pragma omp section
#endif
    B = poly_batch_mul_acc(X, s + half, e, D, mod);
  }
#if ENABLE_OPENMP
#pragma omp parallel sections if (n > 5000)
#endif
  {
#if ENABLE_OPENMP
#pragma omp section
#endif
    B = poly_mul(B, C, mod);
#if ENABLE_OPENMP
#pragma omp section
#endif
    M = poly_mul(C, D, mod);
  }
  return poly_add(A, B, mod);
}

// n = X.size() / 2
// Y = X
// s(i) = (Y[1]*x+Y[0])(Y[3]x+Y[2])...(Y[2i+1]x+Y[2i])
// return s(0) + s(2) + s(3) + ... + s(n-1)
template <typename T>
SL REQUIRES((is_native_integer<T>::value)) RETURN(vector<T>)
    poly_batch_mul_acc(const vector<T>& X, uint64 mod) {
  vector<T> C;
  return poly_batch_mul_acc(X, 0, X.size() / 2, C, mod);
}
#endif

/**
 * Name convention:
 *   [implementation namespace ::]poly_mul[implementation suffix][scalability
 * suffix]
 *
 *   implementation namespace is one of:
 *     ntt32 (32 bit internal mod)
 *     ntt64 (64 bit internal mod)
 *     poly_min25
 *     poly_libbf
 *     poly_flint
 *
 *   scalability uffix: see the contstraints
 *
 *   implementation suffix:
 *     dc: divide and conquer
 *
 * Template parameters:
 *   T:
 *     native integer which can be promoted to uint64
 *
 * Availability
 * ntt32 small : always available
 * ntt32 large : always available
 * ntt64 small : always available
 * ntt64 large : always available
 * min25 small : requires int128
 * min25 large : requires int128
 * libbf       : enable libbf && LIMB_BITS >= 64
 * flint prime : enable flint && GMP_LIMB_BITS >= 64
 * flint nmod  : enable flint && GMP_LIMB_BITS >= 64
 * ntl small   : enable ntl
 * ntl large   : enable ntl
 *
 * Constraints
 * mod < 2^62 in all implementation.
 *
 * ntt32 small
 * (mod-1)^2*n < 4593671624212873217                              4.5e18
 *
 * ntt32 large
 * (mod-1)^2*n < 14797252050511790781119856641                    1.4e28
 *
 * ntt64 small
 * (mod-1)^2*n < 1945555039024054273                              1.9e18
 *
 * ntt64 large
 * (mod-1)^2*n < 350480037951100867051507526341230593             3.5e35
 *
 * min25 small
 * (mod-1)^2*n < 1128298388379402241                              1.1e18
 *
 * min25 large
 * (mod-1)^2*n < 1265198875113262859862934516672757761            1.2e36
 *
 * flint prime
 * mod is a word size prime
 *
 * flint nmod
 * mod is word size
 *
 * libbf
 * (mod-1)^2*n < 340282366920938463463374607431768211456 (2^128)  3.4e38
 *
 * ntl small mod
 * mod < 2^30 if sizeof(long) = 4
 * mod < 2^50 if sizeof(long) = 8
 *
 * ntl large mod
 * no constraints
 */
#endif
