#ifndef PE_EXTENDED_UNSIGNED_INT_
#define PE_EXTENDED_UNSIGNED_INT_

#include "pe_base"
#include "pe_type_traits"
#include "pe_int"
#include "pe_bit"

namespace pe {
// Extended integers

// Extended unsigned integer.

template <typename ET, bool is_builtin>
struct ExtendedUnsignedIntImpl;

template <typename ET, bool is_builtin>
struct ExtendedSignedIntImpl;

template <typename ET, bool is_builtin>
struct ExtractETImpl;

template <typename ET>
struct ExtractETImpl<ET, true> {
  using type = pe_make_unsigned_t<ET>;
};

template <typename ET>
struct ExtractETImpl<ET, false> {
  using type = typename ET::UnsignedT;
};

template <typename ET>
struct ExtractET : public ExtractETImpl<ET, is_builtin_integer_v<ET>> {};

template <typename ET>
struct ExtendedUnsignedIntImpl<ET, true> {
  constexpr static int quarter_bitsize = sizeof(ET) * 4;
  constexpr static int half_bitsize = quarter_bitsize * 2;
  constexpr static int bitsize = half_bitsize * 2;

  constexpr static ET quarter_mask =
      (static_cast<ET>(1) << quarter_bitsize) - 1;

  constexpr static ET hibit_mask = (static_cast<ET>(1) << (half_bitsize - 1));

  static constexpr int div_bit_size = 1;

  using UnsignedT = ExtendedUnsignedIntImpl<ET, true>;
  using SignedT = ExtendedSignedIntImpl<ET, true>;

  // The corresponding native integer type.
  using NT = ET;
  using ElementT = ET;

 private:
  template <typename T>
  constexpr REQUIRES((is_builtin_integer_v<T> && pe_is_unsigned_v<T> &&
                      sizeof(T) <= sizeof(ET))) RETURN(void)
      FromNativeInt(T v) {
    low_ = v;
  }

  template <typename T>
  constexpr REQUIRES((is_builtin_integer_v<T> && pe_is_unsigned_v<T> &&
                      sizeof(T) > sizeof(ET))) RETURN(void) FromNativeInt(T v) {
    low_ = v;
    hi_ = v >> half_bitsize;
  }

  template <typename T>
  constexpr REQUIRES((is_builtin_integer_v<T> && pe_is_signed_v<T> &&
                      sizeof(T) <= sizeof(ET))) RETURN(void)
      FromNativeInt(T v) {
    if (v >= 0) {
      low_ = v;
    } else {
      low_ = v;
      hi_ = -1;
    }
  }

  template <typename T>
  constexpr REQUIRES((is_builtin_integer_v<T> && pe_is_signed_v<T> &&
                      sizeof(T) > sizeof(ET))) RETURN(void) FromNativeInt(T v) {
    using UnsignedT = pe_make_unsigned_t<T>;
    FromNativeInt<UnsignedT>(static_cast<UnsignedT>(v));
  }

  constexpr void FromString(const std::string& str) {
    const int n = static_cast<int>(std::size(str));
    if (n == 0) return;
    int idx = 0;
    int neg = 0;
    if (str[idx] == '-') {
      ++idx;
      neg = 1;
    } else if (str[idx] == '+') {
      ++idx;
    }
    while (idx < n && std::isdigit(str[idx])) {
      *this *= 10;
      *this += str[idx] - '0';
      ++idx;
    }
    if (neg) {
      FlipBits();
      AddOne();
    }
  }

 public:
  constexpr ExtendedUnsignedIntImpl(ET low = 0) : low_(low), hi_(0) {}
  constexpr ExtendedUnsignedIntImpl(ET low, ET hi) : low_(low), hi_(hi) {}

  template <typename T,
            typename TT = REQUIRES((is_builtin_integer_v<T>)) RETURN(T)>
  constexpr ExtendedUnsignedIntImpl(T v) : low_(0), hi_(0) {
    FromNativeInt<T>(v);
  }

  constexpr ExtendedUnsignedIntImpl(const std::string& str) : low_(0), hi_(0) {
    FromString(str);
  }

  constexpr ExtendedUnsignedIntImpl(const ExtendedUnsignedIntImpl& other)
      : low_(other.low_), hi_(other.hi_) {}

  template <typename ET1, bool is_builtin_integer1>
  constexpr ExtendedUnsignedIntImpl(
      const ExtendedUnsignedIntImpl<ET1, is_builtin_integer1>& other) {
    FromUInt32Vector(other.ToUInt32Vector());
  }

  constexpr ExtendedUnsignedIntImpl& operator=(const ET& other) {
    low_ = other;
    hi_ = 0;
    return *this;
  }

  template <typename T,
            typename TT = REQUIRES((is_builtin_integer_v<T>)) RETURN(T)>
  constexpr ExtendedUnsignedIntImpl& operator=(const T& other) {
    low_ = hi_ = 0;
    FromNativeInt<T>(other);
    return *this;
  }

  constexpr ExtendedUnsignedIntImpl& operator=(const std::string& str) {
    MakeZeroBits();
    FromString(str);
    return *this;
  }

  constexpr ExtendedUnsignedIntImpl& operator=(
      const ExtendedUnsignedIntImpl& other) {
    low_ = other.low_;
    hi_ = other.hi_;
    return *this;
  }

  constexpr ExtendedUnsignedIntImpl& operator=(
      const ExtendedUnsignedIntImpl&& other) noexcept {
    low_ = std::move(other.low_);
    hi_ = std::move(other.hi_);
    return *this;
  }

 public:
  constexpr void MakeAbs() {}

  constexpr void FlipBits() {
    low_ = ~low_;
    hi_ = ~hi_;
  }

  constexpr void MakeZeroBits() {
    low_ = 0;
    hi_ = 0;
  }

  constexpr void AddOne() {
    ++low_;
    if (low_ == 0) {
      ++hi_;
    }
  }

  constexpr int BitWidth() const {
    if (hi_) {
      return pe::BitWidth(hi_) + sizeof(low_) * 8;
    } else {
      return pe::BitWidth(low_);
    }
  }

  constexpr int Popcount() const {
    const int each = sizeof(ET) / sizeof(uint32);

    int ret = 0;
    ET t = low_;
    for (int i = 0; t && i < each; ++i) {
      ret += pe_popcount(static_cast<uint32>(t));
#if defined(COMPILER_MSVC) || defined(COMPILER_CLANG)
      t >>= 16;
      t >>= 16;
#else
      t >>= 32;
#endif
    }

    t = hi_;
    for (int i = 0; t && i < each; ++i) {
      ret += pe_popcount(static_cast<uint32>(t));
#if defined(COMPILER_MSVC) || defined(COMPILER_CLANG)
      t >>= 16;
      t >>= 16;
#else
      t >>= 32;
#endif
    }

    return ret;
  }

  constexpr int GetHighestBit() const { return hi_ & hibit_mask ? 1 : 0; }

  constexpr void ResetHighestBit() { hi_ &= ~hibit_mask; }

  constexpr void SetHighestBit() { hi_ |= hibit_mask; }

  constexpr void SetBit(int idx) {
    if (idx < half_bitsize) {
      low_ |= static_cast<ET>(1) << idx;
    } else if (idx < bitsize) {
      hi_ |= static_cast<ET>(1) << (idx - half_bitsize);
    }
  }

  constexpr void ResetBit(int idx) {
    if (idx < half_bitsize) {
      low_ &= ~(static_cast<ET>(1) << idx);
    } else if (idx < bitsize) {
      hi_ &= ~(static_cast<ET>(1) << (idx - half_bitsize));
    }
  }

  constexpr int GetBit(int idx) const {
    if (idx < half_bitsize) {
      return low_ & (static_cast<ET>(1) << idx) ? 1 : 0;
    } else if (idx < bitsize) {
      return hi_ & (static_cast<ET>(1) << (idx - half_bitsize)) ? 1 : 0;
    } else {
      return 0;
    }
  }

  constexpr void RevBit(int idx) {
    if (idx < half_bitsize) {
      low_ ^= static_cast<ET>(1) << idx;
    } else if (idx < bitsize) {
      hi_ ^= static_cast<ET>(1) << (idx - half_bitsize);
    }
  }

  constexpr void ArithmeticShiftRight(int cnt) {
    if (GetHighestBit()) {
      FlipBits();
      AddOne();
      ShiftRight(cnt);
      FlipBits();
    } else {
      ShiftRight(cnt);
    }
  }

  constexpr void ShiftRight(int cnt) {
    if (cnt >= bitsize) {
      low_ = hi_ = 0;
    } else if (cnt >= half_bitsize) {
      low_ = hi_ >> (cnt - half_bitsize);
      hi_ = 0;
    } else {
      ET mask = (static_cast<ET>(1) << cnt) - 1;
      ET t = hi_ & mask;
      hi_ >>= cnt;
      low_ >>= cnt;
      low_ |= t << (half_bitsize - cnt);
    }
  }

  constexpr void ShiftLeft(int cnt) {
    if (cnt >= bitsize) {
      low_ = hi_ = 0;
    } else if (cnt >= half_bitsize) {
      hi_ = low_ << (cnt - half_bitsize);
      low_ = 0;
    } else {
      ET t = low_ >> (half_bitsize - cnt);
      hi_ = hi_ << cnt | t;
      low_ <<= cnt;
    }
  }

  constexpr ET GetQuarter(int i) const {
    switch (i & 3) {
      case 0:
        return low_ & quarter_mask;
      case 1:
        return low_ >> quarter_bitsize;
      case 2:
        return hi_ & quarter_mask;
      case 3:
        return hi_ >> quarter_bitsize;
    }
    return 0;
  }

  template <typename T>
  constexpr static void FixSize(std::vector<T>& v) {
    if (std::empty(v)) v.push_back(0);
    int now = static_cast<int>(std::size(v)) - 1;
    while (now > 0 && v[now] == 0) --now;
    v.resize(now + 1);
  }

  std::vector<uint32> ToUInt32Vector(int fix_size = 1) const {
    const int each = sizeof(ET) / sizeof(uint32);

    std::vector<uint32> r;
    r.reserve(each * 2);
    ET t = low_;
    for (int i = 0; i < each; ++i) {
      r.push_back(static_cast<uint32>(t));
#if defined(COMPILER_MSVC) || defined(COMPILER_CLANG)
      t >>= 16;
      t >>= 16;
#else
      t >>= 32;
#endif
    }
    if (!fix_size || hi_) {
      t = hi_;
      for (int i = 0; i < each; ++i) {
        r.push_back(static_cast<uint32>(t));
#if defined(COMPILER_MSVC) || defined(COMPILER_CLANG)
        t >>= 16;
        t >>= 16;
#else
        t >>= 32;
#endif
      }
    }
    if (fix_size) {
      FixSize(r);
    }
    return r;
  }

  constexpr void FromUInt32Vector(const std::vector<uint32>& bits32) {
    const int each = sizeof(ET) / sizeof(int32);

    hi_ = 0;
    for (int i =
             std::min(2 * each - 1, static_cast<int>(std::size(bits32)) - 1);
         i >= each; --i) {
#if defined(COMPILER_MSVC) || defined(COMPILER_CLANG)
      hi_ <<= 16;
      hi_ = (hi_ << 16) | bits32[i];
#else
      hi_ = (hi_ << 32) | bits32[i];
#endif
    }

    low_ = 0;
    for (int i = std::min(each - 1, static_cast<int>(std::size(bits32)) - 1);
         i >= 0; --i) {
#if defined(COMPILER_MSVC) || defined(COMPILER_CLANG)
      low_ <<= 16;
      low_ = (low_ << 16) | bits32[i];
#else
      low_ = (low_ << 32) | bits32[i];
#endif
    }
  }

  template <typename T>
  REQUIRES((is_builtin_integer_v<T>))
  RETURN(std::vector<T>) ToKBits(int k, int fix_size = 1) const {
    if (k == 1) {
      return ToBinary<T>(fix_size);
    } else {
      const unsigned mask = (1U << k) - 1;
      const int blocks = half_bitsize / k;
      std::vector<T> ret;
      {
        auto t = low_;
        for (int j = 0; j < blocks; ++j) {
          ret.push_back(t & mask);
          t >>= k;
        }
      }
      {
        auto t = hi_;
        for (int j = 0; j < blocks; ++j) {
          ret.push_back(t & mask);
          t >>= k;
        }
      }
      if (fix_size) {
        FixSize(ret);
      }
      return ret;
    }
  }

  template <typename T>
  constexpr REQUIRES((is_builtin_integer_v<T>)) RETURN(void)
      FromKBits(const int k, const T* bits, const int n) {
    if (k == 1) {
      FromBinary(bits, n);
    } else {
      const int blocks = half_bitsize / k;
      hi_ = 0;
      for (int i = std::min(2 * blocks - 1, n - 1); i >= blocks; --i) {
        hi_ = (hi_ << k) | bits[i];
      }

      low_ = 0;
      for (int i = std::min(blocks - 1, n - 1); i >= 0; --i) {
        low_ = (low_ << k) | bits[i];
      }
    }
  }

  template <typename T>
  constexpr REQUIRES((is_builtin_integer_v<T>)) RETURN(void)
      FromKBits(int k, const std::vector<T>& bits) {
    if (k == 1) {
      FromBinary(std::data(bits), static_cast<int>(std::size(bits)));
    } else {
      FromKBits(k, std::data(bits), static_cast<int>(std::size(bits)));
    }
  }

  template <typename T>
  REQUIRES((is_builtin_integer_v<T>))
  RETURN(std::vector<T>) ToBinary(int fix_size = 1) const {
    std::vector<T> r;
    r.reserve(bitsize);
    ET t = low_;
    for (int i = 0; i < half_bitsize; ++i) {
      r.push_back(t & 1);
      t >>= 1;
    }
    if (!fix_size || hi_) {
      t = hi_;
      for (int i = 0; i < half_bitsize; ++i) {
        r.push_back(t & 1);
        t >>= 1;
      }
    }
    if (fix_size) {
      FixSize(r);
    }
    return r;
  }

  template <typename T>
  constexpr REQUIRES((is_builtin_integer_v<T>)) RETURN(void)
      FromBinary(const T* bits, const int n) {
    hi_ = 0;
    for (int i = std::min(bitsize - 1, n - 1); i >= half_bitsize; --i) {
      hi_ = (hi_ << 1) | bits[i];
    }

    low_ = 0;
    for (int i = std::min(half_bitsize - 1, n - 1); i >= 0; --i) {
      low_ = (low_ << 1) | bits[i];
    }
  }

  template <typename T>
  constexpr REQUIRES((is_builtin_integer_v<T>)) RETURN(void)
      FromBinary(const std::vector<T>& bits) {
    FromBinary(std::data(bits), static_cast<int>(std::size(bits)));
  }

  static void DivideInplace(ExtendedUnsignedIntImpl& self,
                            const ExtendedUnsignedIntImpl& other) {
    if (self.IsZero()) {
      return;
    }
    PE_ASSERT(!other.IsZero());

    if (other.hi_ == 0 && other.low_ == 1) {
      return;
    }

    int t = self.CompareTo(other);
    if (t == 0) {
      self.low_ = 1;
      self.hi_ = 0;
      return;
    }

    if (t < 0) {
      self.low_ = self.hi_ = 0;
      return;
    }

    if (self.hi_ == 0) {
      self.low_ /= other.low_;
      return;
    }

    const int k = div_bit_size;

    if (k == 1) {
      std::vector<uint32> remain;

      std::vector<uint32> result = internal::AbsDivide<uint32>(
          self.ToBinary<uint32>(), other.ToBinary<uint32>(), remain);

      self.FromBinary(result);
    } else {
      std::vector<uint32> remain;

      std::vector<uint32> result = internal::AbsDivide<uint32>(
          k, self.ToKBits<uint32>(k), other.ToKBits<uint32>(k), remain);

      self.FromKBits(k, result);
    }
  }

  static void DivideInplace(ExtendedUnsignedIntImpl& self,
                            const ExtendedUnsignedIntImpl& other,
                            ExtendedUnsignedIntImpl& remain) {
    if (self.IsZero()) {
      remain = 0;
      return;
    }
    PE_ASSERT(!other.IsZero());

    if (other.hi_ == 0 && other.low_ == 1) {
      remain = 0;
      return;
    }

    int t = self.CompareTo(other);
    if (t == 0) {
      self.low_ = 1;
      self.hi_ = 0;
      remain = 0;
      return;
    }

    if (t < 0) {
      remain = self;
      self.low_ = self.hi_ = 0;
      return;
    }

    if (self.hi_ == 0) {
      remain = self.low_ % other.low_;
      self.low_ /= other.low_;
      return;
    }

    const int k = div_bit_size;

    if (k == 1) {
      std::vector<uint32> r;

      std::vector<uint32> result = internal::AbsDivide<uint32>(
          self.ToBinary<uint32>(), other.ToBinary<uint32>(), r);

      self.FromBinary(result);
      remain.FromBinary(r);

    } else {
      std::vector<uint32> r;

      std::vector<uint32> result = internal::AbsDivide<uint32>(
          k, self.ToKBits<uint32>(k), other.ToKBits<uint32>(k), r);

      self.FromKBits(k, result);
      remain.FromKBits(k, r);
    }
  }

  static void RemainInplace(ExtendedUnsignedIntImpl& self,
                            const ExtendedUnsignedIntImpl& other) {
    if (self.IsZero()) {
      return;
    }
    PE_ASSERT(!other.IsZero());

    if (other.hi_ == 0 && other.low_ == 1) {
      self.low_ = self.hi_ = 0;
      return;
    }

    int t = self.CompareTo(other);
    if (t == 0) {
      self.low_ = self.hi_ = 0;
      return;
    }

    if (t < 0) {
      return;
    }

    if (self.hi_ == 0) {
      self.low_ %= other.low_;
      return;
    }

    const int k = div_bit_size;

    if (k > 1) {
      std::vector<uint32> remain;

      internal::AbsDivide<uint32>(self.ToBinary<uint32>(),
                                  other.ToBinary<uint32>(), remain);

      self.FromBinary(remain);

    } else {
      std::vector<uint32> remain;

      internal::AbsDivide<uint32>(k, self.ToKBits<uint32>(k),
                                  other.ToKBits<uint32>(k), remain);

      self.FromKBits(k, remain);
    }
  }

 public:
  constexpr ET& low() { return low_; }

  constexpr ET& hi() { return hi_; }

  constexpr ET low() const { return low_; }

  constexpr ET hi() const { return hi_; }

  constexpr int sign() const { return low_ || hi_ ? 1 : 0; }

  constexpr int CompareTo(const ExtendedUnsignedIntImpl& other) const {
    if (hi_ != other.hi_) {
      return hi_ < other.hi_ ? -1 : hi_ > other.hi_;
    } else {
      return low_ < other.low_ ? -1 : low_ > other.low_;
    }
  }

  constexpr int IntSign() const { return low_ || hi_ ? 1 : 0; }

  constexpr int IsZero() const { return low_ == 0 && hi_ == 0; }

  constexpr int IsEven() const { return low_ & 1 ? 0 : 1; }

  constexpr int IsOdd() const { return low_ & 1 ? 1 : 0; }

  constexpr uint32 LowerBits() const { return static_cast<uint32>(low_); }

  constexpr ExtendedUnsignedIntImpl Abs() const { return *this; }

  constexpr ExtendedUnsignedIntImpl FAbs() const { return *this; }

  template <typename T>
  constexpr REQUIRES((is_builtin_integer_v<T> && sizeof(T) <= sizeof(ET)))
      RETURN(T) ToInt() const {
    return static_cast<T>(low_);
  }

  template <typename T>
  constexpr REQUIRES((is_builtin_integer_v<T> && sizeof(T) > sizeof(ET)))
      RETURN(T) ToInt() const {
    using UnsignedT = pe_make_unsigned_t<T>;
    return static_cast<T>((static_cast<UnsignedT>(hi_) << half_bitsize) |
                          static_cast<UnsignedT>(low_));
  }

  template <typename T>
  T ToFloat() const {
    auto t = ToUInt32Vector();
    const int size = static_cast<int>(std::size(t));
    T r = 0;
    for (int i = size - 1; i >= 0; --i) {
      r = r * 4294967296 + t[i];
    }
    return r;
  }

  std::string ToString() const {
    const uint32 output_mod = 1000000000;
    if (IsZero()) {
      return "0";
    }
    if (hi_ == 0) {
      return pe::ToString(low_);
    }

    std::vector<uint32> bits32 = ToUInt32Vector();
    std::vector<uint32> mods;

    std::stringstream ss;

    int idx = static_cast<int>(std::size(bits32)) - 1;
    while (bits32[idx] == 0) --idx;

    do {
      uint64 add = 0;
      for (int i = idx; i > 0; --i) {
        const uint64 x = add + bits32[i];
        const uint64 next_add = (x % output_mod) << 32;
        bits32[i] = static_cast<unsigned>(x / output_mod);
        add = next_add;
      }
      uint64 x = add + bits32[0];
      bits32[0] = static_cast<unsigned>(x / output_mod);
      mods.push_back(x % output_mod);
      while (idx >= 0 && bits32[idx] == 0) --idx;
    } while (idx >= 0);

    idx = static_cast<int>(std::size(mods)) - 1;
    char buff[32];
    sprintf(buff, "%u", mods[idx--]);
    ss << buff;
    for (; idx >= 0; --idx) {
      sprintf(buff, "%09u", mods[idx]);
      ss << buff;
    }
    return ss.str();
  }

  constexpr ExtendedUnsignedIntImpl Difference(
      const ExtendedUnsignedIntImpl& other) const {
    int t = CompareTo(other);
    if (t == 0) {
      return 0;
    }
    if (t > 0) {
      ET x = hi_ - other.hi_;
      ET y;
      if (low_ >= other.low_) {
        y = low_ - other.low_;
      } else {
        y = low_ - other.low_;
        --x;
      }
      return ExtendedUnsignedIntImpl(y, x);
    } else {
      ET x = other.hi_ - hi_;
      ET y;
      if (other.low_ >= low_) {
        y = other.low_ - low_;
      } else {
        y = other.low_ - low_;
        --x;
      }
      return ExtendedUnsignedIntImpl(y, x);
    }
  }

 public:
  // Operators
  constexpr ExtendedUnsignedIntImpl operator+() const { return *this; }

  constexpr ExtendedUnsignedIntImpl operator-() const {
    ExtendedUnsignedIntImpl ret(*this);
    ret.FlipBits();
    ret.AddOne();
    return ret;
  }

  constexpr ExtendedUnsignedIntImpl operator~() const {
    return ExtendedUnsignedIntImpl(~low_, ~hi_);
  }

  constexpr ExtendedUnsignedIntImpl& operator+=(
      const ExtendedUnsignedIntImpl& other) {
    if (IsZero()) {
      low_ = other.low();
      hi_ = other.hi();
      return *this;
    }

    if (!other.IsZero()) {
      ET x = other.low() + low_;
      ET y = other.hi() + hi_;
      if (other.low_ && low_ && (x < other.low() || x < low_)) {
        ++y;
      }
      low_ = x;
      hi_ = y;
    }
    return *this;
  }

  constexpr ExtendedUnsignedIntImpl& operator+=(const ET& other) {
    if (IsZero()) {
      low_ = other;
      hi_ = 0;
      return *this;
    }

    if (other) {
      ET x = low_ + other;
      ET y = hi_;
      if (low_ && other && (x < low_ || x < other)) {
        ++y;
      }
      low_ = x;
      hi_ = y;
    }
    return *this;
  }

  constexpr ExtendedUnsignedIntImpl& operator-=(
      const ExtendedUnsignedIntImpl& other) {
    if (other.IsZero()) {
      return *this;
    }

    if (IsZero()) {
      low_ = other.low();
      hi_ = other.hi();
      FlipBits();
      AddOne();
      return *this;
    }

    int t = CompareTo(other);
    if (t == 0) {
      low_ = hi_ = 0;
      return *this;
    } else {
      ExtendedUnsignedIntImpl d = Difference(other);
      if (t < 0) {
        d.FlipBits();
        d.AddOne();
      }
      low_ = d.low();
      hi_ = d.hi();
    }

    return *this;
  }

  constexpr ExtendedUnsignedIntImpl& operator-=(const ET& other) {
    if (other == 0) {
      return *this;
    }

    if (IsZero()) {
      low_ = other;
      FlipBits();
      AddOne();
      return *this;
    }

    int t = CompareTo(other);
    if (t == 0) {
      low_ = hi_ = 0;
      return *this;
    } else {
      ExtendedUnsignedIntImpl d = Difference(other);
      if (t < 0) {
        d.FlipBits();
        d.AddOne();
      }
      low_ = d.low();
      hi_ = d.hi();
    }

    return *this;
  }

  constexpr ExtendedUnsignedIntImpl& operator*=(
      const ExtendedUnsignedIntImpl& other) {
    if (IsZero() || other.IsZero()) {
      low_ = hi_ = 0;
      return *this;
    }
    ET t[4] = {0};
    for (int i = 0; i < 4; ++i) {
      for (int j = 0; j + i < 4; ++j) {
        ET carry = GetQuarter(i) * other.GetQuarter(j);
        for (int now = i + j; now < 4; ++now) {
          ET x = t[now] + (carry & quarter_mask);
          t[now] = x & quarter_mask;
          carry = (x >> quarter_bitsize) + (carry >> quarter_bitsize);
          if (carry == 0) {
            break;
          }
        }
      }
    }
    low_ = t[0] | (t[1] << quarter_bitsize);
    hi_ = t[2] | (t[3] << quarter_bitsize);

    return *this;
  }

  constexpr ExtendedUnsignedIntImpl& operator*=(const ET& other) {
    if (IsZero() || other == 0) {
      low_ = hi_ = 0;
      return *this;
    }
    ET t[4] = {0};
    for (int i = 0; i < 4; ++i) {
      for (int j = 0; j < 2 && j + i < 4; ++j) {
        ET carry = GetQuarter(i) *
                   (j == 0 ? other & quarter_mask : other >> quarter_bitsize);
        for (int now = i + j; now < 4; ++now) {
          ET x = t[now] + (carry & quarter_mask);
          t[now] = x & quarter_mask;
          carry = (x >> quarter_bitsize) + (carry >> quarter_bitsize);
          if (carry == 0) {
            break;
          }
        }
      }
    }
    low_ = t[0] | (t[1] << quarter_bitsize);
    hi_ = t[2] | (t[3] << quarter_bitsize);
    return *this;
  }

  constexpr ExtendedUnsignedIntImpl& operator/=(
      const ExtendedUnsignedIntImpl& other) {
    DivideInplace(*this, other);
    return *this;
  }

  constexpr ExtendedUnsignedIntImpl& operator/=(const ET& other) {
    return *this /= ExtendedUnsignedIntImpl(other);
  }

  constexpr ExtendedUnsignedIntImpl& operator%=(
      const ExtendedUnsignedIntImpl& other) {
    RemainInplace(*this, other);
    return *this;
  }

  constexpr ExtendedUnsignedIntImpl& operator%=(const ET& other) {
    return *this %= ExtendedUnsignedIntImpl(other);
  }

  constexpr ExtendedUnsignedIntImpl& operator&=(
      const ExtendedUnsignedIntImpl& other) {
    low_ &= other.low();
    hi_ &= other.hi();
    return *this;
  }

  constexpr ExtendedUnsignedIntImpl& operator&=(const ET& other) {
    low_ &= other;
    hi_ = 0;
    return *this;
  }

  constexpr ExtendedUnsignedIntImpl& operator^=(
      const ExtendedUnsignedIntImpl& other) {
    low_ ^= other.low();
    hi_ ^= other.hi();
    return *this;
  }

  constexpr ExtendedUnsignedIntImpl& operator^=(const ET& other) {
    low_ ^= other;
    return *this;
  }

  constexpr ExtendedUnsignedIntImpl& operator|=(
      const ExtendedUnsignedIntImpl& other) {
    low_ |= other.low();
    hi_ |= other.hi();
    return *this;
  }

  constexpr ExtendedUnsignedIntImpl& operator|=(const ET& other) {
    low_ |= other;
    return *this;
  }

  constexpr ExtendedUnsignedIntImpl& operator>>=(int cnt) {
    ShiftRight(cnt);
    return *this;
  }

  constexpr ExtendedUnsignedIntImpl& operator<<=(int cnt) {
    ShiftLeft(cnt);
    return *this;
  }

  constexpr ExtendedUnsignedIntImpl& operator++() {
    AddOne();
    return *this;
  }

  constexpr ExtendedUnsignedIntImpl operator++(int) {
    ExtendedUnsignedIntImpl ret(*this);
    *this += 1;
    return ret;
  }

  constexpr ExtendedUnsignedIntImpl& operator--() {
    if (low_) {
      --low_;
    } else {
      --low_;
      --hi_;
    }
    return *this;
  }

  constexpr ExtendedUnsignedIntImpl operator--(int) {
    ExtendedUnsignedIntImpl ret(*this);
    *this -= 1;
    return ret;
  }

 public:
  // All the binary operators are friend operators
  // Comparison operators
#if PE_HAS_CPP20
  constexpr friend inline int operator<=>(const ExtendedUnsignedIntImpl& l,
                                          const ExtendedUnsignedIntImpl& r) {
    return l.CompareTo(r);
  }
  constexpr friend inline int operator==(const ExtendedUnsignedIntImpl& l,
                                         const ExtendedUnsignedIntImpl& r) {
    return l.CompareTo(r) == 0;
  }
  constexpr friend inline int operator!=(const ExtendedUnsignedIntImpl& l,
                                         const ExtendedUnsignedIntImpl& r) {
    return l.CompareTo(r) != 0;
  }
#else
  constexpr friend inline int operator<(const ExtendedUnsignedIntImpl& l,
                                        const ExtendedUnsignedIntImpl& r) {
    return l.CompareTo(r) < 0;
  }
  constexpr friend inline int operator<=(const ExtendedUnsignedIntImpl& l,
                                         const ExtendedUnsignedIntImpl& r) {
    return l.CompareTo(r) <= 0;
  }
  constexpr friend inline int operator>(const ExtendedUnsignedIntImpl& l,
                                        const ExtendedUnsignedIntImpl& r) {
    return l.CompareTo(r) > 0;
  }
  constexpr friend inline int operator>=(const ExtendedUnsignedIntImpl& l,
                                         const ExtendedUnsignedIntImpl& r) {
    return l.CompareTo(r) >= 0;
  }
  constexpr friend inline int operator==(const ExtendedUnsignedIntImpl& l,
                                         const ExtendedUnsignedIntImpl& r) {
    return l.CompareTo(r) == 0;
  }
  constexpr friend inline int operator!=(const ExtendedUnsignedIntImpl& l,
                                         const ExtendedUnsignedIntImpl& r) {
    return l.CompareTo(r) != 0;
  }
#endif
  constexpr friend inline ExtendedUnsignedIntImpl operator+(
      const ExtendedUnsignedIntImpl& l, const ExtendedUnsignedIntImpl& r) {
    ExtendedUnsignedIntImpl ret(l);
    ret += r;
    return ret;
  }
  constexpr friend inline ExtendedUnsignedIntImpl operator-(
      const ExtendedUnsignedIntImpl& l, const ExtendedUnsignedIntImpl& r) {
    ExtendedUnsignedIntImpl ret(l);
    ret -= r;
    return ret;
  }
  constexpr friend inline ExtendedUnsignedIntImpl operator*(
      const ExtendedUnsignedIntImpl& l, const ExtendedUnsignedIntImpl& r) {
    ExtendedUnsignedIntImpl ret(l);
    ret *= r;
    return ret;
  }
  constexpr friend inline ExtendedUnsignedIntImpl operator/(
      const ExtendedUnsignedIntImpl& l, const ExtendedUnsignedIntImpl& r) {
    ExtendedUnsignedIntImpl ret(l);
    ret /= r;
    return ret;
  }
  constexpr friend inline ExtendedUnsignedIntImpl operator%(
      const ExtendedUnsignedIntImpl& l, const ExtendedUnsignedIntImpl& r) {
    ExtendedUnsignedIntImpl ret(l);
    ret %= r;
    return ret;
  }
  constexpr friend inline ExtendedUnsignedIntImpl operator&(
      const ExtendedUnsignedIntImpl& l, const ExtendedUnsignedIntImpl& r) {
    ExtendedUnsignedIntImpl ret(l);
    ret &= r;
    return ret;
  }
  constexpr friend inline ExtendedUnsignedIntImpl operator^(
      const ExtendedUnsignedIntImpl& l, const ExtendedUnsignedIntImpl& r) {
    ExtendedUnsignedIntImpl ret(l);
    ret ^= r;
    return ret;
  }
  constexpr friend inline ExtendedUnsignedIntImpl operator|(
      const ExtendedUnsignedIntImpl& l, const ExtendedUnsignedIntImpl& r) {
    ExtendedUnsignedIntImpl ret(l);
    ret |= r;
    return ret;
  }
  constexpr friend inline ExtendedUnsignedIntImpl operator<<(
      const ExtendedUnsignedIntImpl& l, const int cnt) {
    ExtendedUnsignedIntImpl ret(l);
    ret <<= cnt;
    return ret;
  }
  constexpr friend inline ExtendedUnsignedIntImpl operator>>(
      const ExtendedUnsignedIntImpl& l, const int cnt) {
    ExtendedUnsignedIntImpl ret(l);
    ret >>= cnt;
    return ret;
  }
  friend inline std::ostream& operator<<(std::ostream& o,
                                         const ExtendedUnsignedIntImpl& n) {
    return o << n.ToString();
  }

 protected:
#if PE_IS_LITTLE_ENDIAN
  ET low_;
  ET hi_;
#else
  ET hi_;
  ET low_;
#endif
};

template <typename ET>
struct ExtendedUnsignedIntImpl<ET, false> {
  constexpr static int quarter_bitsize = sizeof(ET) * 4;
  constexpr static int half_bitsize = quarter_bitsize * 2;
  constexpr static int bitsize = half_bitsize * 2;

  static constexpr int div_bit_size = 1;

  using NT = typename ET::NT;
  using UnsignedT = ExtendedUnsignedIntImpl<ET, false>;
  using SignedT = ExtendedSignedIntImpl<ET, false>;
  using ElementT = ET;

 private:
  template <typename T>
  constexpr REQUIRES((is_builtin_integer_v<T> && pe_is_unsigned_v<T> &&
                      sizeof(T) <= sizeof(ET))) RETURN(void)
      FromNativeInt(T v) {
    low_ = v;
  }

  template <typename T>
  constexpr REQUIRES((is_builtin_integer_v<T> && pe_is_unsigned_v<T> &&
                      sizeof(T) > sizeof(ET))) RETURN(void) FromNativeInt(T v) {
    low_ = v;
    hi_ = v >> half_bitsize;
  }

  template <typename T>
  constexpr REQUIRES((is_builtin_integer_v<T> && pe_is_signed_v<T> &&
                      sizeof(T) <= sizeof(ET))) RETURN(void)
      FromNativeInt(T v) {
    if (v >= 0) {
      low_ = v;
    } else {
      low_ = v;
      hi_.FlipBits();
    }
  }

  template <typename T>
  constexpr REQUIRES((is_builtin_integer_v<T> && pe_is_signed_v<T> &&
                      sizeof(T) > sizeof(ET))) RETURN(void) FromNativeInt(T v) {
    using UnsignedT = pe_make_unsigned_t<T>;
    FromNativeInt<UnsignedT>(static_cast<UnsignedT>(v));
  }

  constexpr void FromString(const std::string& str) {
    const int n = static_cast<int>(std::size(str));
    if (n == 0) return;
    int idx = 0;
    int neg = 0;
    if (str[idx] == '-') {
      ++idx;
      neg = 1;
    } else if (str[idx] == '+') {
      ++idx;
    }
    while (idx < n && std::isdigit(str[idx])) {
      *this *= 10;
      *this += str[idx] - '0';
      ++idx;
    }
    if (neg) {
      FlipBits();
      AddOne();
    }
  }

 public:
  constexpr ExtendedUnsignedIntImpl(ET low = 0) : low_(low), hi_(0) {}
  constexpr ExtendedUnsignedIntImpl(ET low, ET hi) : low_(low), hi_(hi) {}

  template <typename T,
            typename TT = REQUIRES((is_builtin_integer_v<T>)) RETURN(T)>
  constexpr ExtendedUnsignedIntImpl(T v) : low_(0), hi_(0) {
    FromNativeInt<T>(v);
  }

  constexpr ExtendedUnsignedIntImpl(const std::string& str) : low_(0), hi_(0) {
    FromString(str);
  }

  constexpr ExtendedUnsignedIntImpl(const ExtendedUnsignedIntImpl& other)
      : low_(other.low_), hi_(other.hi_) {}

  template <typename ET1, bool is_builtin_integer1>
  constexpr ExtendedUnsignedIntImpl(
      const ExtendedUnsignedIntImpl<ET1, is_builtin_integer1>& other) {
    FromUInt32Vector(other.ToUInt32Vector());
  }

  constexpr ExtendedUnsignedIntImpl& operator=(const ET& other) {
    low_ = other;
    hi_.MakeZeroBits();
    return *this;
  }

  template <typename T,
            typename TT = REQUIRES((is_builtin_integer_v<T>)) RETURN(T)>
  constexpr ExtendedUnsignedIntImpl& operator=(const T& other) {
    MakeZeroBits();
    FromNativeInt<T>(other);
    return *this;
  }

  constexpr ExtendedUnsignedIntImpl& operator=(const std::string& str) {
    MakeZeroBits();
    FromString(str);
    return *this;
  }

  constexpr ExtendedUnsignedIntImpl& operator=(
      const ExtendedUnsignedIntImpl& other) {
    low_ = other.low_;
    hi_ = other.hi_;
    return *this;
  }

  constexpr ExtendedUnsignedIntImpl& operator=(
      const ExtendedUnsignedIntImpl&& other) noexcept {
    low_ = std::move(other.low_);
    hi_ = std::move(other.hi_);
    return *this;
  }

 public:
  constexpr void MakeAbs();

  constexpr void FlipBits() {
    low_.FlipBits();
    hi_.FlipBits();
  }

  constexpr void MakeZeroBits() {
    low_.MakeZeroBits();
    hi_.MakeZeroBits();
  }

  constexpr void AddOne() {
    ++low_;
    if (low_.IsZero()) {
      ++hi_;
    }
  }

  constexpr int BitWidth() const {
    if (!hi_.IsZero()) {
      return hi_.BitWidth() + sizeof(low_) * 8;
    } else {
      return low_.BitWidth();
    }
  }

  constexpr int Popcount() const { return hi_.Popcount() + low_.Popcount(); }

  constexpr int GetHighestBit() const { return hi_.GetHighestBit(); }

  constexpr void ResetHighestBit() { hi_.ResetHighestBit(); }

  constexpr void SetHighestBit() { hi_.SetHighestBit(); }

  constexpr void SetBit(int idx) {
    if (idx < half_bitsize) {
      low_.SetBit(idx);
    } else if (idx < bitsize) {
      hi_.SetBit(idx - half_bitsize);
    }
  }

  constexpr void ResetBit(int idx) {
    if (idx < half_bitsize) {
      low_.ResetBit(idx);
    } else if (idx < bitsize) {
      hi_.ResetBit(idx - half_bitsize);
    }
  }

  constexpr int GetBit(int idx) const {
    if (idx < half_bitsize) {
      return low_.GetBit(idx);
    } else if (idx < bitsize) {
      return hi_.GetBit(idx - half_bitsize);
    } else {
      return 0;
    }
  }

  constexpr void RevBit(int idx) {
    if (idx < half_bitsize) {
      low_.RevBit(idx);
    } else if (idx < bitsize) {
      hi_.RevBit(idx - half_bitsize);
    }
  }

  constexpr void ArithmeticShiftRight(int cnt) {
    if (GetHighestBit()) {
      FlipBits();
      AddOne();
      ShiftRight(cnt);
      FlipBits();
    } else {
      ShiftRight(cnt);
    }
  }

  constexpr void ShiftRight(int cnt) {
    if (cnt >= bitsize) {
      MakeZeroBits();
    } else if (cnt >= half_bitsize) {
      low_ = hi_ >> (cnt - half_bitsize);
      hi_.MakeZeroBits();
    } else {
      ET mask = (static_cast<ET>(1) << cnt) - 1;
      ET t = hi_ & mask;
      hi_ >>= cnt;
      low_ >>= cnt;
      low_ |= t << (half_bitsize - cnt);
    }
  }

  constexpr void ShiftLeft(int cnt) {
    if (cnt >= bitsize) {
      MakeZeroBits();
    } else if (cnt >= half_bitsize) {
      hi_ = low_ << (cnt - half_bitsize);
      low_.MakeZeroBits();
    } else {
      ET t = low_ >> (half_bitsize - cnt);
      hi_ = hi_ << cnt | t;
      low_ <<= cnt;
    }
  }

  constexpr ET GetQuarter(int i) const {
    switch (i & 3) {
      case 0:
        return low_.low();
      case 1:
        return low_.hi();
      case 2:
        return hi_.low();
      case 3:
        return hi_.hi();
    }
    return 0;
  }

  template <typename T>
  static void FixSize(std::vector<T>& v) {
    if (std::empty(v)) v.push_back(0);
    int now = static_cast<int>(std::size(v)) - 1;
    while (now > 0 && v[now] == 0) --now;
    v.resize(now + 1);
  }

  std::vector<uint32> ToUInt32Vector(int fix_size = 1) const {
    const int each = sizeof(ET) / sizeof(uint32);

    std::vector<uint32> r;
    r.reserve(each * 2);
    for (auto& iter : low_.ToUInt32Vector(0)) r.push_back(iter);
    if (!fix_size || !hi_.IsZero()) {
      for (auto& iter : hi_.ToUInt32Vector(0)) r.push_back(iter);
    }
    if (fix_size) {
      FixSize(r);
    }
    return r;
  }

  constexpr void FromUInt32Vector(const std::vector<uint32>& bits32) {
    const int each = sizeof(ET) / sizeof(int32);
    hi_.MakeZeroBits();
    for (int i =
             std::min(2 * each - 1, static_cast<int>(std::size(bits32)) - 1);
         i >= each; --i) {
      hi_ = (hi_ << 32) | bits32[i];
    }

    low_.MakeZeroBits();
    for (int i = std::min(each - 1, static_cast<int>(std::size(bits32)) - 1);
         i >= 0; --i) {
      low_ = (low_ << 32) | bits32[i];
    }
  }

  template <typename T>
  REQUIRES((is_builtin_integer_v<T>))
  RETURN(std::vector<T>) ToKBits(int k, int fix_size = 1) const {
    if (k == 1) {
      return ToBinary<T>(fix_size);
    } else {
      std::vector<T> r = low_.template ToKBits<T>(k, 0);
      if (!fix_size || !hi_.IsZero()) {
        r.reserve(bitsize / k);
        for (auto& iter : hi_.template ToKBits<T>(k, 0)) r.push_back(iter);
      }
      if (fix_size) {
        FixSize(r);
      }
      return r;
    }
  }

  template <typename T>
  constexpr REQUIRES((is_builtin_integer_v<T>)) RETURN(void)
      FromKBits(int k, const std::vector<T>& bits) {
    if (k == 1) {
      FromBinary(std::data(bits), static_cast<int>(std::size(bits)));
    } else {
      FromKBits(k, std::data(bits), static_cast<int>(std::size(bits)));
    }
  }

  template <typename T>
  constexpr REQUIRES((is_builtin_integer_v<T>)) RETURN(void)
      FromKBits(int k, const T* bits, const int n) {
    if (k == 1) {
      FromBinary(bits, n);
      return;
    } else {
      low_.FromKBits(k, bits, n);
      int need = half_bitsize / k;
      if (n > need) {
        hi_.FromKBits(k, bits + need, n - need);
      } else {
        hi_.MakeZeroBits();
      }
    }
  }

  template <typename T>
  constexpr REQUIRES((is_builtin_integer_v<T>)) RETURN(std::vector<T>)
      ToBinary(int fix_size = 1) const {
    std::vector<T> r = low_.template ToBinary<T>(0);
    if (!fix_size || !hi_.IsZero()) {
      r.reserve(bitsize);
      for (auto& iter : hi_.template ToBinary<T>(0)) r.push_back(iter);
    }
    if (fix_size) {
      FixSize(r);
    }
    return r;
  }

  template <typename T>
  constexpr REQUIRES((is_builtin_integer_v<T>)) RETURN(void)
      FromBinary(const std::vector<T>& bits) {
    FromBinary(std::data(bits), static_cast<int>(std::size(bits)));
  }

  template <typename T>
  constexpr REQUIRES((is_builtin_integer_v<T>)) RETURN(void)
      FromBinary(const T* bits, const int n) {
    low_.FromBinary(bits, n);
    if (n > half_bitsize) {
      hi_.FromBinary(bits + half_bitsize, n - half_bitsize);
    } else {
      hi_.MakeZeroBits();
    }
  }

  static void DivideInplace(ExtendedUnsignedIntImpl& self,
                            const ExtendedUnsignedIntImpl& other) {
    if (self.IsZero()) {
      return;
    }
    PE_ASSERT(!other.IsZero());

    if (other.hi_ == 0 && other.low_ == 1) {
      return;
    }

    int t = self.CompareTo(other);
    if (t == 0) {
      self.low_ = 1;
      self.hi_.MakeZeroBits();
      return;
    }

    if (t < 0) {
      self.low_.MakeZeroBits();
      self.hi_.MakeZeroBits();
      return;
    }

    if (self.hi_ == 0) {
      self.low_ /= other.low_;
      return;
    }

    const int k = div_bit_size;

    if (k == 1) {
      std::vector<uint32> remain;

      std::vector<uint32> result = internal::AbsDivide<uint32>(
          self.ToBinary<uint32>(), other.ToBinary<uint32>(), remain);

      self.FromBinary(result);
    } else {
      std::vector<uint32> remain;

      std::vector<uint32> result = internal::AbsDivide<uint32>(
          k, self.ToKBits<uint32>(k), other.ToKBits<uint32>(k), remain);

      self.FromKBits(k, result);
    }
  }

  static void DivideInplace(ExtendedUnsignedIntImpl& self,
                            const ExtendedUnsignedIntImpl& other,
                            ExtendedUnsignedIntImpl& remain) {
    if (self.IsZero()) {
      remain.MakeZeroBits();
      return;
    }
    PE_ASSERT(!other.IsZero());

    if (other.hi_ == 0 && other.low_ == 1) {
      remain.MakeZeroBits();
      return;
    }

    int t = self.CompareTo(other);
    if (t == 0) {
      self.low_ = 1;
      self.hi_.MakeZeroBits();
      remain.MakeZeroBits();
      return;
    }

    if (t < 0) {
      remain = self;
      self.low_.MakeZeroBits();
      self.hi_.MakeZeroBits();
      return;
    }

    if (self.hi_ == 0) {
      remain = self.low_ % other.low_;
      self.low_ /= other.low_;
      return;
    }

    const int k = div_bit_size;

    if (k == 1) {
      std::vector<uint32> r;

      std::vector<uint32> result = internal::AbsDivide<uint32>(
          self.ToBinary<uint32>(), other.ToBinary<uint32>(), r);

      self.FromBinary(result);
      remain.FromBinary(r);
    } else {
      std::vector<uint32> r;

      std::vector<uint32> result = internal::AbsDivide<uint32>(
          k, self.ToKBits<uint32>(k), other.ToKBits<uint32>(k), r);

      self.FromKBits(k, result);
      remain.FromKBits(k, r);
    }
  }

  static void RemainInplace(ExtendedUnsignedIntImpl& self,
                            const ExtendedUnsignedIntImpl& other) {
    if (self.IsZero()) {
      return;
    }
    PE_ASSERT(!other.IsZero());

    if (other.hi_ == 0 && other.low_ == 1) {
      self.low_.MakeZeroBits();
      self.hi_.MakeZeroBits();
      return;
    }

    int t = self.CompareTo(other);
    if (t == 0) {
      self.low_.MakeZeroBits();
      self.hi_.MakeZeroBits();
      return;
    }

    if (t < 0) {
      return;
    }

    if (self.hi_.IsZero()) {
      self.low_ %= other.low_;
      return;
    }

    const int k = div_bit_size;
    if (k == 1) {
      std::vector<uint32> remain;

      internal::AbsDivide<uint32>(self.ToBinary<uint32>(),
                                  other.ToBinary<uint32>(), remain);

      self.FromBinary(remain);
    } else {
      std::vector<uint32> remain;

      internal::AbsDivide<uint32>(k, self.ToKBits<uint32>(k),
                                  other.ToKBits<uint32>(k), remain);

      self.FromKBits(k, remain);
    }
  }

 public:
  constexpr ET& low() { return low_; }

  constexpr ET& hi() { return hi_; }

  constexpr ET low() const { return low_; }

  constexpr ET hi() const { return hi_; }

  constexpr int sign() const { return low_.IsZero() || hi_.IsZero() ? 1 : 0; }

  constexpr int CompareTo(const ExtendedUnsignedIntImpl& other) const {
    int t = hi_.CompareTo(other.hi_);
    if (t != 0) {
      return t;
    }
    return low_.CompareTo(other.low_);
  }

  constexpr int IntSign() const {
    return low_.IsZero() || hi_.IsZero() ? 1 : 0;
  }

  constexpr int IsZero() const { return low_.IsZero() && hi_.IsZero(); }

  constexpr int IsEven() const { return LowerBits() & 1 ? 0 : 1; }

  constexpr int IsOdd() const { return LowerBits() & 1 ? 1 : 0; }

  constexpr uint32 LowerBits() const { return low_.LowerBits(); }

  constexpr ExtendedUnsignedIntImpl Abs() const { return *this; }

  constexpr ExtendedUnsignedIntImpl FAbs() const { return *this; }

  template <typename T>
  constexpr REQUIRES((is_builtin_integer_v<T> && sizeof(T) <= sizeof(ET)))
      RETURN(T) ToInt() const {
    return low_.template ToInt<T>();
  }

  template <typename T>
  constexpr REQUIRES((is_builtin_integer_v<T> && sizeof(T) > sizeof(ET)))
      RETURN(T) ToInt() const {
    using UnsignedT = pe_make_unsigned_t<T>;
    return static_cast<T>(hi_.template ToInt<UnsignedT>() << half_bitsize |
                          low_.template ToInt<UnsignedT>());
  }

  template <typename T>
  T ToFloat() const {
    auto t = ToUInt32Vector();
    const int size = static_cast<int>(std::size(t));
    T r = 0;
    for (int i = size - 1; i >= 0; --i) {
      r = r * 4294967296 + t[i];
    }
    return r;
  }

  std::string ToString() const {
    const uint32 output_mod = 1000000000;
    if (IsZero()) {
      return "0";
    }
    if (hi_.IsZero()) {
      return low_.ToString();
    }

    std::vector<uint32> bits32 = ToUInt32Vector();
    std::vector<uint32> mods;

    std::stringstream ss;
    int idx = static_cast<int>(std::size(bits32)) - 1;
    while (bits32[idx] == 0) --idx;
    do {
      uint64 add = 0;
      for (int i = idx; i > 0; --i) {
        const uint64 x = add + bits32[i];
        const uint64 next_add = (x % output_mod) << 32;
        bits32[i] = static_cast<unsigned>(x / output_mod);
        add = next_add;
      }
      uint64 x = add + bits32[0];
      bits32[0] = static_cast<unsigned>(x / output_mod);
      mods.push_back(x % output_mod);
      while (idx >= 0 && bits32[idx] == 0) --idx;
    } while (idx >= 0);

    idx = static_cast<int>(std::size(mods)) - 1;
    char buff[32];
    sprintf(buff, "%u", mods[idx--]);
    ss << buff;
    for (; idx >= 0; --idx) {
      sprintf(buff, "%09u", mods[idx]);
      ss << buff;
    }
    return ss.str();
  }

  constexpr ExtendedUnsignedIntImpl Difference(
      const ExtendedUnsignedIntImpl& other) const {
    int t = CompareTo(other);
    if (t == 0) {
      return 0;
    }
    if (t > 0) {
      ET x = hi_ - other.hi_;
      ET y;
      if (low_ >= other.low_) {
        y = low_ - other.low_;
      } else {
        y = low_ - other.low_;
        --x;
      }
      return ExtendedUnsignedIntImpl(y, x);
    } else {
      ET x = other.hi_ - hi_;
      ET y;
      if (other.low_ >= low_) {
        y = other.low_ - low_;
      } else {
        y = other.low_ - low_;
        --x;
      }
      return ExtendedUnsignedIntImpl(y, x);
    }
  }

 public:
  // Operators
  constexpr ExtendedUnsignedIntImpl operator+() const { return *this; }

  constexpr ExtendedUnsignedIntImpl operator-() const {
    ExtendedUnsignedIntImpl ret(*this);
    ret.FlipBits();
    ret.AddOne();
    return ret;
  }

  constexpr ExtendedUnsignedIntImpl operator~() const {
    return ExtendedUnsignedIntImpl(~low_, ~hi_);
  }

  constexpr ExtendedUnsignedIntImpl& operator+=(
      const ExtendedUnsignedIntImpl& other) {
    if (IsZero()) {
      low_ = other.low();
      hi_ = other.hi();
      return *this;
    }

    if (!other.IsZero()) {
      ET x = other.low() + low_;
      ET y = other.hi() + hi_;
      if (!other.low().IsZero() && !low_.IsZero() &&
          (x < other.low() || x < low_)) {
        ++y;
      }
      low_ = x;
      hi_ = y;
    }
    return *this;
  }

  constexpr ExtendedUnsignedIntImpl& operator+=(const ET& other) {
    return *this += ExtendedUnsignedIntImpl(other);
  }

  template <typename T>
  constexpr REQUIRES((is_builtin_integer_v<T>))
      RETURN(ExtendedUnsignedIntImpl&) operator+=(const T & other) {
    return *this += ExtendedUnsignedIntImpl(other);
  }

  constexpr ExtendedUnsignedIntImpl& operator-=(
      const ExtendedUnsignedIntImpl& other) {
    if (other.IsZero()) {
      return *this;
    }

    if (IsZero()) {
      low_ = other.low();
      hi_ = other.hi();
      FlipBits();
      AddOne();
      return *this;
    }

    int t = CompareTo(other);
    if (t == 0) {
      low_.MakeZeroBits();
      hi_.MakeZeroBits();
      return *this;
    } else {
      ExtendedUnsignedIntImpl d = Difference(other);
      if (t < 0) {
        d.FlipBits();
        d.AddOne();
      }
      low_ = d.low_;
      hi_ = d.hi_;
    }

    return *this;
  }

  constexpr ExtendedUnsignedIntImpl& operator-=(const ET& other) {
    return *this -= ExtendedUnsignedIntImpl(other);
  }

  template <typename T>
  constexpr REQUIRES((is_builtin_integer_v<T>))
      RETURN(ExtendedUnsignedIntImpl&) operator-=(const T & other) {
    return *this -= ExtendedUnsignedIntImpl(other);
  }

  constexpr ExtendedUnsignedIntImpl& operator*=(
      const ExtendedUnsignedIntImpl& other) {
    if (IsZero() || other.IsZero()) {
      low_.MakeZeroBits();
      hi_.MakeZeroBits();
      return *this;
    }
    ET t[4];
    for (int i = 0; i < 4; ++i) {
      for (int j = 0; j + i < 4; ++j) {
        ET carry = GetQuarter(i) * other.GetQuarter(j);
        for (int now = i + j; now < 4; ++now) {
          ET x = ET(t[now]) + ET(carry.low());
          t[now] = x.low();
          carry = ET(x.hi()) + ET(carry.hi());
          if (carry.IsZero()) {
            break;
          }
        }
      }
    }

#if 1
#if PE_IS_LITTLE_ENDIAN
    typename ET::ElementT tmp[4]{t[0].low(), t[1].low(), t[2].low(),
                                 t[3].low()};
#else
    typename ET::ElementT tmp[4]{t[3].low(), t[2].low(), t[1].low(),
                                 t[0].low()};
#endif
    memcpy(reinterpret_cast<void*>(this),
           reinterpret_cast<void*>(std::data(tmp)), sizeof(tmp));
#else
    // When the following codes are compilfed by clang (msys2 and ubuntu
    // version) with O3 option, the behavior is weird.
    low_ = t[0] | (t[1] << quarter_bitsize);
    hi_ = t[2] | (t[3] << quarter_bitsize);
#endif

    return *this;
  }

  constexpr ExtendedUnsignedIntImpl& operator*=(const ET& other) {
    return *this *= ExtendedUnsignedIntImpl(other);
  }

  template <typename T>
  constexpr REQUIRES((is_builtin_integer_v<T>))
      RETURN(ExtendedUnsignedIntImpl&) operator*=(const T & other) {
    return *this *= ExtendedUnsignedIntImpl(other);
  }

  constexpr ExtendedUnsignedIntImpl& operator/=(
      const ExtendedUnsignedIntImpl& other) {
    DivideInplace(*this, other);
    return *this;
  }

  constexpr ExtendedUnsignedIntImpl& operator/=(const ET& other) {
    return *this /= ExtendedUnsignedIntImpl(other);
  }

  template <typename T>
  constexpr REQUIRES((is_builtin_integer_v<T>))
      RETURN(ExtendedUnsignedIntImpl&) operator/=(const T & other) {
    return *this /= ExtendedUnsignedIntImpl(other);
  }

  constexpr ExtendedUnsignedIntImpl& operator%=(
      const ExtendedUnsignedIntImpl& other) {
    RemainInplace(*this, other);
    return *this;
  }

  constexpr ExtendedUnsignedIntImpl& operator%=(const ET& other) {
    return *this %= ExtendedUnsignedIntImpl(other);
  }

  template <typename T>
  constexpr REQUIRES((is_builtin_integer_v<T>))
      RETURN(ExtendedUnsignedIntImpl&) operator%=(const T & other) {
    return *this %= ExtendedUnsignedIntImpl(other);
  }

  constexpr ExtendedUnsignedIntImpl& operator&=(
      const ExtendedUnsignedIntImpl& other) {
    low_ &= other.low();
    hi_ &= other.hi();
    return *this;
  }

  template <typename T>
  constexpr REQUIRES((is_builtin_integer_v<T>))
      RETURN(ExtendedUnsignedIntImpl&) operator&=(const T & other) {
    return *this &= ExtendedUnsignedIntImpl(other);
  }

  constexpr ExtendedUnsignedIntImpl& operator&=(const ET& other) {
    return *this &= ExtendedUnsignedIntImpl(other);
  }

  constexpr ExtendedUnsignedIntImpl& operator^=(
      const ExtendedUnsignedIntImpl& other) {
    low_ ^= other.low();
    hi_ ^= other.hi();
    return *this;
  }

  constexpr ExtendedUnsignedIntImpl& operator^=(const ET& other) {
    return *this ^= ExtendedUnsignedIntImpl(other);
  }

  template <typename T>
  constexpr REQUIRES((is_builtin_integer_v<T>))
      RETURN(ExtendedUnsignedIntImpl&) operator^=(const T & other) {
    return *this ^= ExtendedUnsignedIntImpl(other);
  }

  constexpr ExtendedUnsignedIntImpl& operator|=(
      const ExtendedUnsignedIntImpl& other) {
    low_ |= other.low();
    hi_ |= other.hi();
    return *this;
  }

  constexpr ExtendedUnsignedIntImpl& operator|=(const ET& other) {
    return *this |= ExtendedUnsignedIntImpl(other);
  }

  template <typename T>
  constexpr REQUIRES((is_builtin_integer_v<T>))
      RETURN(ExtendedUnsignedIntImpl&) operator|=(const T & other) {
    return *this |= ExtendedUnsignedIntImpl(other);
  }

  constexpr ExtendedUnsignedIntImpl& operator>>=(int cnt) {
    ShiftRight(cnt);
    return *this;
  }

  constexpr ExtendedUnsignedIntImpl& operator<<=(int cnt) {
    ShiftLeft(cnt);
    return *this;
  }

  constexpr ExtendedUnsignedIntImpl& operator++() {
    AddOne();
    return *this;
  }

  constexpr ExtendedUnsignedIntImpl operator++(int) {
    ExtendedUnsignedIntImpl ret(*this);
    *this += 1;
    return ret;
  }

  constexpr ExtendedUnsignedIntImpl& operator--() {
    if (!low_.IsZero()) {
      --low_;
    } else {
      --low_;
      --hi_;
    }
    return *this;
  }

  constexpr ExtendedUnsignedIntImpl operator--(int) {
    ExtendedUnsignedIntImpl ret(*this);
    *this -= 1;
    return ret;
  }

 public:
  // All the binary operators are friend operators
  // Comparison operators
#if PE_HAS_CPP20
  constexpr friend inline int operator<=>(const ExtendedUnsignedIntImpl& l,
                                          const ExtendedUnsignedIntImpl& r) {
    return l.CompareTo(r);
  }
  constexpr friend inline int operator==(const ExtendedUnsignedIntImpl& l,
                                         const ExtendedUnsignedIntImpl& r) {
    return l.CompareTo(r) == 0;
  }
  constexpr friend inline int operator!=(const ExtendedUnsignedIntImpl& l,
                                         const ExtendedUnsignedIntImpl& r) {
    return l.CompareTo(r) != 0;
  }
#else
  constexpr friend inline int operator<(const ExtendedUnsignedIntImpl& l,
                                        const ExtendedUnsignedIntImpl& r) {
    return l.CompareTo(r) < 0;
  }
  constexpr friend inline int operator<=(const ExtendedUnsignedIntImpl& l,
                                         const ExtendedUnsignedIntImpl& r) {
    return l.CompareTo(r) <= 0;
  }
  constexpr friend inline int operator>(const ExtendedUnsignedIntImpl& l,
                                        const ExtendedUnsignedIntImpl& r) {
    return l.CompareTo(r) > 0;
  }
  constexpr friend inline int operator>=(const ExtendedUnsignedIntImpl& l,
                                         const ExtendedUnsignedIntImpl& r) {
    return l.CompareTo(r) >= 0;
  }
  constexpr friend inline int operator==(const ExtendedUnsignedIntImpl& l,
                                         const ExtendedUnsignedIntImpl& r) {
    return l.CompareTo(r) == 0;
  }
  constexpr friend inline int operator!=(const ExtendedUnsignedIntImpl& l,
                                         const ExtendedUnsignedIntImpl& r) {
    return l.CompareTo(r) != 0;
  }
#endif
  constexpr friend inline ExtendedUnsignedIntImpl operator+(
      const ExtendedUnsignedIntImpl& l, const ExtendedUnsignedIntImpl& r) {
    ExtendedUnsignedIntImpl ret(l);
    ret += r;
    return ret;
  }
  constexpr friend inline ExtendedUnsignedIntImpl operator-(
      const ExtendedUnsignedIntImpl& l, const ExtendedUnsignedIntImpl& r) {
    ExtendedUnsignedIntImpl ret(l);
    ret -= r;
    return ret;
  }
  constexpr friend inline ExtendedUnsignedIntImpl operator*(
      const ExtendedUnsignedIntImpl& l, const ExtendedUnsignedIntImpl& r) {
    ExtendedUnsignedIntImpl ret(l);
    ret *= r;
    return ret;
  }
  constexpr friend inline ExtendedUnsignedIntImpl operator/(
      const ExtendedUnsignedIntImpl& l, const ExtendedUnsignedIntImpl& r) {
    ExtendedUnsignedIntImpl ret(l);
    ret /= r;
    return ret;
  }
  constexpr friend inline ExtendedUnsignedIntImpl operator%(
      const ExtendedUnsignedIntImpl& l, const ExtendedUnsignedIntImpl& r) {
    ExtendedUnsignedIntImpl ret(l);
    ret %= r;
    return ret;
  }
  constexpr friend inline ExtendedUnsignedIntImpl operator&(
      const ExtendedUnsignedIntImpl& l, const ExtendedUnsignedIntImpl& r) {
    ExtendedUnsignedIntImpl ret(l);
    ret &= r;
    return ret;
  }
  constexpr friend inline ExtendedUnsignedIntImpl operator^(
      const ExtendedUnsignedIntImpl& l, const ExtendedUnsignedIntImpl& r) {
    ExtendedUnsignedIntImpl ret(l);
    ret ^= r;
    return ret;
  }
  constexpr friend inline ExtendedUnsignedIntImpl operator|(
      const ExtendedUnsignedIntImpl& l, const ExtendedUnsignedIntImpl& r) {
    ExtendedUnsignedIntImpl ret(l);
    ret |= r;
    return ret;
  }
  constexpr friend inline ExtendedUnsignedIntImpl operator<<(
      const ExtendedUnsignedIntImpl& l, const int cnt) {
    ExtendedUnsignedIntImpl ret(l);
    ret <<= cnt;
    return ret;
  }
  constexpr friend inline ExtendedUnsignedIntImpl operator>>(
      const ExtendedUnsignedIntImpl& l, const int cnt) {
    ExtendedUnsignedIntImpl ret(l);
    ret >>= cnt;
    return ret;
  }
  friend inline std::ostream& operator<<(std::ostream& o,
                                         const ExtendedUnsignedIntImpl& n) {
    return o << n.ToString();
  }

 protected:
#if PE_IS_LITTLE_ENDIAN
  ET low_;
  ET hi_;
#else
  ET hi_;
  ET low_;
#endif
};

template <typename ET>
using ExtendedUnsignedInt =
    ExtendedUnsignedIntImpl<typename ExtractET<ET>::type,
                            is_builtin_integer_v<ET>>;
}  // namespace pe

namespace std {
template <typename ET, bool is_builtin_integer>
struct numeric_limits<pe::ExtendedUnsignedIntImpl<ET, is_builtin_integer>> {
  using T = pe::ExtendedUnsignedIntImpl<ET, is_builtin_integer>;
  static constexpr T max() { return -1; }
  static constexpr T min() { return 0; }
  static constexpr T lowest() { return min(); }
  static constexpr bool is_signed = false;
  static constexpr bool is_unsigned = true;
  static constexpr bool is_integer = true;
};
}  // namespace std
#endif
