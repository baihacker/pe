#ifndef PE_SERIALIZATION_
#define PE_SERIALIZATION_

#include "pe_base"
#include "pe_int"

namespace pe {
template <typename T>
SL REQUIRES((std::is_default_constructible_v<T> &&
             std::is_trivially_constructible_v<T> && sizeof(T) == 4))
    RETURN(std::vector<int64>) SerializeValue(const T &value) {
  return {static_cast<int64>(*reinterpret_cast<const uint32 *>(&value))};
}

template <typename T>
SL REQUIRES((std::is_default_constructible_v<T> &&
             std::is_trivially_constructible_v<T> && sizeof(T) == 8))
    RETURN(std::vector<int64>) SerializeValue(const T &value) {
  return {*reinterpret_cast<const int64 *>(&value)};
}

template <typename T>
SL REQUIRES((std::is_default_constructible_v<T> &&
             std::is_trivially_constructible_v<T> && sizeof(T) == 16))
    RETURN(std::vector<int64>) SerializeValue(const T &value) {
  const int64 *ptr = reinterpret_cast<const int64 *>(&value);
  return {ptr[0], ptr[1]};
}

std::vector<int64> SerializeValue(const std::string &value) {
  std::vector<int64> ret;
  ret.push_back(value.size());
  for (auto iter : value) {
    ret.push_back(iter);
  }
  return ret;
}

template <typename T>
std::vector<int64> SerializeValue(const std::vector<T> &value);

template <typename T>
std::vector<int64> SerializeValue(const std::set<T> &value);

template <typename T>
std::vector<int64> SerializeValue(const std::unordered_set<T> &value);

template <typename K, typename V>
std::vector<int64> SerializeValue(const std::map<K, V> &value);

template <typename K, typename V>
std::vector<int64> SerializeValue(const std::unordered_map<K, V> &value);

template <typename U, typename V>
std::vector<int64> SerializeValue(const std::pair<U, V> &value) {
  std::vector<int64> ret;
  for (int64 t : SerializeValue(value.first)) {
    ret.push_back(t);
  }
  for (int64 t : SerializeValue(value.second)) {
    ret.push_back(t);
  }
  return ret;
}

template <typename T>
std::vector<int64> SerializeVectorLike(const T &vector_like) {
  std::vector<int64> ret;
  ret.push_back(vector_like.size());
  for (const auto &iter : vector_like) {
    for (int64 t : SerializeValue(iter)) {
      ret.push_back(t);
    }
  }
  return ret;
}

template <typename T>
std::vector<int64> SerializeValue(const std::vector<T> &value) {
  return SerializeVectorLike(value);
}

template <typename T>
std::vector<int64> SerializeValue(const std::set<T> &value) {
  return SerializeVectorLike(value);
}

template <typename T>
std::vector<int64> SerializeValue(const std::unordered_set<T> &value) {
  return SerializeVectorLike(value);
}

template <typename T>
std::vector<int64> SerializeMapLike(const T &map_like) {
  std::vector<int64> ret;
  ret.push_back(map_like.size());
  for (const auto &iter : map_like) {
    for (int64 t : SerializeValue(iter.first)) {
      ret.push_back(t);
    }
    for (int64 t : SerializeValue(iter.second)) {
      ret.push_back(t);
    }
  }
  return ret;
}

template <typename K, typename V>
std::vector<int64> SerializeValue(const std::map<K, V> &value) {
  return SerializeMapLike(value);
}

template <typename K, typename V>
std::vector<int64> SerializeValue(const std::unordered_map<K, V> &value) {
  return SerializeMapLike(value);
}

template <typename... T>
void SerializeObject(std::tuple<T...> &&obj,
                     std::vector<std::vector<int64>> &target) {
  const int field_count = std::tuple_size_v<std::tuple<T...>>;
  target.push_back(std::vector<int64>{field_count});

  std::apply(
      [&](T &&...field) { ((target.push_back(SerializeValue(field))), ...); },
      obj);
}

template <typename OT, typename... T>
void SerializeObject(const OT &obj, std::vector<std::vector<int64>> &target) {
  SerializeObject(obj.AsTuple(), target);
}

template <typename T>
SL REQUIRES((std::is_default_constructible_v<T> &&
             std::is_trivially_constructible_v<T> && sizeof(T) == 4))
    RETURN(void)
        DeserializeValue(const std::vector<int64> &src, int64 &idx, T &value) {
  const int64 size = src.size();
  if (idx >= size) {
    std::cerr << "Invalid index (sizeof(T) == 4), idx = " << idx
              << ", size = " << size << std::endl;
    exit(-1);
  }
  uint32 t = static_cast<uint32>(src[idx]);
  value = *reinterpret_cast<const T *>(&t);
  idx = idx + 1;
}

template <typename T>
SL REQUIRES((std::is_default_constructible_v<T> &&
             std::is_trivially_constructible_v<T> && sizeof(T) == 8))
    RETURN(void)
        DeserializeValue(const std::vector<int64> &src, int64 &idx, T &value) {
  const int64 size = src.size();
  if (idx >= size) {
    std::cerr << "Invalid index (sizeof(T) == 8), idx = " << idx
              << ", size = " << size << std::endl;
    exit(-1);
  }
  value = *reinterpret_cast<const T *>(&src[idx]);
  idx = idx + 1;
}

template <typename T>
SL REQUIRES((std::is_default_constructible_v<T> &&
             std::is_trivially_constructible_v<T> && sizeof(T) == 16))
    RETURN(void)
        DeserializeValue(const std::vector<int64> &src, int64 &idx, T &value) {
  const int size = static_cast<int>(src.size());
  if (idx >= size) {
    std::cerr << "Invalid index, idx = " << idx << ", size = " << size
              << std::endl;
    exit(-1);
  }
  const int64 length = 2;
  if (idx + length - 1 >= size) {
    std::cerr << "Insufficient data (sizeof(T) == 16), idx = " << idx
              << ", length = " << length << ", size = " << size << std::endl;
    exit(-1);
  }

  int64 *ptr = reinterpret_cast<int64 *>(&value);
  ptr[0] = src[idx];
  ptr[1] = src[idx + 1];
  idx = idx + 2;
}

void DeserializeValue(const std::vector<int64> &src, int64 &idx,
                      std::string &value) {
  const int64 size = src.size();
  if (idx >= size) {
    std::cerr << "Invalid index, idx = " << idx << ", size = " << size
              << std::endl;
    exit(-1);
  }
  const int64 length = src[idx];
  if (idx + length >= size) {
    std::cerr << "Insufficient data (string), idx = " << idx
              << ", length = " << length << ", size = " << size << std::endl;
    exit(-1);
  }
  for (int64 i = idx + 1; i <= idx + length; ++i) {
    value += char(src[i]);
  }
  idx = idx + length + 1;
}

template <typename T>
void DeserializeValue(const std::vector<int64> &src, int64 &idx,
                      std::vector<T> &value);

template <typename T>
void DeserializeValue(const std::vector<int64> &src, int64 &idx,
                      std::set<T> &value);

template <typename T>
void DeserializeValue(const std::vector<int64> &src, int64 &idx,
                      std::unordered_set<T> &value);

template <typename K, typename V>
void DeserializeValue(const std::vector<int64> &src, int64 &idx,
                      std::map<K, V> &value);

template <typename K, typename V>
void DeserializeValue(const std::vector<int64> &src, int64 &idx,
                      std::unordered_map<K, V> &value);

template <typename U, typename V>
void DeserializeValue(const std::vector<int64> &src, int64 &idx,
                      std::pair<U, V> &value) {
  const int64 size = src.size();
  if (idx >= size) {
    std::cerr << "Invalid index, idx = " << idx << ", size = " << size
              << std::endl;
    exit(-1);
  }
  const int64 length = 2;
  if (idx + length - 1 >= size) {
    std::cerr << "Insufficient data (std::pair<U, V>), idx = " << idx
              << ", length = " << length << ", size = " << size << std::endl;
    exit(-1);
  }

  DeserializeValue(src, idx, value.first);
  DeserializeValue(src, idx, value.second);
}

template <typename T, typename C>
void DeserializeVectorLike(const std::vector<int64> &src, int64 &idx,
                           C &value) {
  const int64 size = src.size();
  if (idx >= size) {
    std::cerr << "Invalid index, idx = " << idx << ", size = " << size
              << std::endl;
    exit(-1);
  }

  const int64 length = src[idx];

  ++idx;

  for (int64 parsed = 0; parsed < length; ++parsed) {
    T t;
    DeserializeValue(src, idx, t);
    *std::inserter(value, value.end()) = std::move(t);
  }
}

template <typename T>
void DeserializeValue(const std::vector<int64> &src, int64 &idx,
                      std::vector<T> &value) {
  DeserializeVectorLike<T>(src, idx, value);
}

template <typename T>
void DeserializeValue(const std::vector<int64> &src, int64 &idx,
                      std::set<T> &value) {
  DeserializeVectorLike<T>(src, idx, value);
}

template <typename T>
void DeserializeValue(const std::vector<int64> &src, int64 &idx,
                      std::unordered_set<T> &value) {
  DeserializeVectorLike<T>(src, idx, value);
}

template <typename K, typename V, typename T>
void DeserializeMapLike(const std::vector<int64> &src, int64 &idx, T &value) {
  const int64 size = src.size();
  if (idx >= size) {
    std::cerr << "Invalid index, idx = " << idx << ", size = " << size
              << std::endl;
    exit(-1);
  }

  const int64 length = src[idx];

  ++idx;

  for (int64 parsed = 0; parsed < length; ++parsed) {
    K k;
    DeserializeValue(src, idx, k);
    V v;
    DeserializeValue(src, idx, v);
    value[k] = std::move(v);
  }
}

template <typename K, typename V>
void DeserializeValue(const std::vector<int64> &src, int64 &idx,
                      std::map<K, V> &value) {
  DeserializeMapLike<K, V>(src, idx, value);
}

template <typename K, typename V>
void DeserializeValue(const std::vector<int64> &src, int64 &idx,
                      std::unordered_map<K, V> &value) {
  DeserializeMapLike<K, V>(src, idx, value);
}

template <typename... T>
void DeserializeObject(const std::vector<std::vector<int64>> &source,
                       int64 &idx, std::tuple<T...> &&obj) {
  const int field_count = std::tuple_size_v<std::tuple<T...>>;
  const int size = source.size();
  if (idx >= size) {
    std::cerr << "Invalid index, idx = " << idx << ", size = " << size
              << std::endl;
    exit(-1);
  }
  if (source[idx].size() != 1) {
    std::cerr << "Wrong object format" << std::endl;
    exit(-1);
  }
  int64 source_cnt = source[idx][0];
  if (idx + source_cnt >= size) {
    std::cerr << "Wrong object format, insufficient data, idx = " << idx
              << ", source_cnt = " << source_cnt << ", size = " << size
              << std::endl;
    exit(-1);
  }
  if (field_count != source_cnt) {
    std::cerr << "Wrong field count, expected " << field_count
              << ", actual = " << source_cnt << std::endl;
    exit(-1);
  }
  ++idx;

  std::apply(
      [&](T &&...field) {
        int64 now = 0;
        ((DeserializeValue(source[idx++], now = 0, field)), ...);
      },
      obj);
}

template <typename OT, typename... T>
OT DeserializeObject(const std::vector<std::vector<int64>> &source,
                     int64 &idx) {
  OT obj;
  DeserializeObject(source, idx, obj.AsTuple());
  return obj;
}

template <typename OT, typename... T>
OT DeserializeObject(const std::vector<std::vector<int64>> &source) {
  int64 idx = 0;
  return DeserializeObject<OT>(source, idx);
}

#define DECLARE_SERIALIZATION(...)                              \
  auto AsTuple() { return std::forward_as_tuple(__VA_ARGS__); } \
  auto AsTuple() const { return std::forward_as_tuple(__VA_ARGS__); }

}  // namespace pe

#endif