#ifndef PE_EXTENDED_UNSIGNED_INT_
#define PE_EXTENDED_UNSIGNED_INT_

#include "pe_base"
#include "pe_int128"
#include "pe_type_traits"
#include "pe_int"
#include "pe_bit"
#include "pe_uint_pair"

namespace pe {
// Extended integers

// Extended unsigned integer.
template <typename ET, bool is_native>
struct ExtendedUnsignedIntImpl;

template <typename ET>
struct ExtendedUnsignedIntImpl<ET, true> : public UIntPairImpl<ET, true> {
  // The corresponding native integer type.
  using NT = ET;
  using base = UIntPairImpl<ET, true>;

 public:
  ExtendedUnsignedIntImpl(ET low = 0) : base(low) {}
  ExtendedUnsignedIntImpl(ET low, ET hi) : base(low, hi) {}

  template <typename T,
            typename TT = REQUIRES((is_native_integer<T>::value)) RETURN(T)>
  ExtendedUnsignedIntImpl(T v) : base(v) {}

  ExtendedUnsignedIntImpl(const std::string& str) : base(str) {}

  ExtendedUnsignedIntImpl(const ExtendedUnsignedIntImpl& other) : base(other) {}

  ExtendedUnsignedIntImpl& operator=(const ExtendedUnsignedIntImpl& other) {
    base::low_ = other.low();
    base::hi_ = other.hi();
    return *this;
  }

  ExtendedUnsignedIntImpl& operator=(const ExtendedUnsignedIntImpl&& other) {
    base::low_ = std::move(other.low());
    base::hi_ = std::move(other.hi());
    return *this;
  }

  ExtendedUnsignedIntImpl& operator=(const ET& other) {
    base::low_ = other;
    base::hi_ = 0;
    return *this;
  }

  template <typename T,
            typename TT = REQUIRES((is_native_integer<T>::value)) RETURN(T)>
  ExtendedUnsignedIntImpl& operator=(const T& other) {
    base::MakeZeroBits();
    base::template FromNativeInt<T>(other);
    return *this;
  }

 public:
  void MakeAbs() {}
  ExtendedUnsignedIntImpl& DividedBy(const ExtendedUnsignedIntImpl& other) {
    base::DividedBy(other);
    return *this;
  }

  ExtendedUnsignedIntImpl& DividedBy(const ExtendedUnsignedIntImpl& other,
                                     ExtendedUnsignedIntImpl& r) {
    base::DividedBy(other, r);
    return *this;
  }

  ExtendedUnsignedIntImpl& Modulo(const ExtendedUnsignedIntImpl& other) {
    base::Modulo(other);
    return *this;
  }

 public:
  using base::low;

  using base::hi;

  using base::sign;

  int CompareTo(const ExtendedUnsignedIntImpl& other) const {
    return base::CompareTo(other);
  }

  using base::IntSign;
  using base::IsEven;
  using base::IsOdd;
  using base::IsZero;
  using base::LowerBits;

  ExtendedUnsignedIntImpl Abs() const { return *this; }

  ExtendedUnsignedIntImpl FAbs() const { return *this; }

  using base::ToInt;

  using base::ToFloat;

  using base::SetBit;

  using base::ResetBit;

  using base::GetBit;

  using base::RevBit;

  using base::BitCount;

  using base::to_string;

  using base::ToString;

  ExtendedUnsignedIntImpl Difference(
      const ExtendedUnsignedIntImpl& other) const {
    auto t = base::Difference(other);
    return ExtendedUnsignedIntImpl(t.low(), t.hi());
  }

 public:
  // Operators
  ExtendedUnsignedIntImpl operator+() const { return *this; }

  ExtendedUnsignedIntImpl operator-() const {
    ExtendedUnsignedIntImpl ret(*this);
    base::FlipBits();
    base::AddOne();
    return ret;
  }

  ExtendedUnsignedIntImpl operator~() const {
    return ExtendedUnsignedIntImpl(~base::low_, ~base::hi_);
  }

  ExtendedUnsignedIntImpl& operator+=(const ExtendedUnsignedIntImpl& other) {
    base::AddedBy(other);
    return *this;
  }

  ExtendedUnsignedIntImpl& operator+=(const ET& other) {
    base::AddedBy(other);
    return *this;
  }

  ExtendedUnsignedIntImpl& operator-=(const ExtendedUnsignedIntImpl& other) {
    base::Substract(other);
    return *this;
  }

  ExtendedUnsignedIntImpl& operator-=(const ET& other) {
    base::Substract(other);
    return *this;
  }

  ExtendedUnsignedIntImpl& operator*=(const ExtendedUnsignedIntImpl& other) {
    base::MultipliedBy(other);
    return *this;
  }

  ExtendedUnsignedIntImpl& operator*=(const ET& other) {
    base::MultipliedBy(other);
    return *this;
  }

  ExtendedUnsignedIntImpl& operator/=(const ExtendedUnsignedIntImpl& other) {
    return DividedBy(other);
  }

  ExtendedUnsignedIntImpl& operator/=(const ET& other) {
    return *this /= ExtendedUnsignedIntImpl(other);
  }

  ExtendedUnsignedIntImpl& operator%=(const ExtendedUnsignedIntImpl& other) {
    return Modulo(other);
  }

  ExtendedUnsignedIntImpl& operator%=(const ET& other) {
    return *this %= ExtendedUnsignedIntImpl(other);
  }

  ExtendedUnsignedIntImpl& operator&=(const ExtendedUnsignedIntImpl& other) {
    base::low_ &= other.low();
    base::hi_ &= other.hi();
    return *this;
  }

  ExtendedUnsignedIntImpl& operator&=(const ET& other) {
    base::low_ &= other;
    base::hi_ = 0;
    return *this;
  }

  ExtendedUnsignedIntImpl& operator^=(const ExtendedUnsignedIntImpl& other) {
    base::low_ ^= other.low();
    base::hi_ ^= other.hi();
    return *this;
  }

  ExtendedUnsignedIntImpl& operator^=(const ET& other) {
    base::low_ ^= other;
    return *this;
  }

  ExtendedUnsignedIntImpl& operator|=(const ExtendedUnsignedIntImpl& other) {
    base::low_ |= other.low();
    base::hi_ |= other.hi();
    return *this;
  }

  ExtendedUnsignedIntImpl& operator|=(const ET& other) {
    base::low_ |= other;
    return *this;
  }

  ExtendedUnsignedIntImpl& operator>>=(int cnt) {
    base::ShiftRight(cnt);
    return *this;
  }

  ExtendedUnsignedIntImpl& operator<<=(int cnt) {
    base::ShiftLeft(cnt);
    return *this;
  }

  ExtendedUnsignedIntImpl& operator++() {
    base::AddOne();
    return *this;
  }

  ExtendedUnsignedIntImpl operator++(int) {
    ExtendedUnsignedIntImpl ret(*this);
    ++*this;
    return ret;
  }

  ExtendedUnsignedIntImpl& operator--() {
    if (base::low_) {
      --base::low_;
    } else {
      --base::low_;
      --base::hi_;
    }
    return *this;
  }

  ExtendedUnsignedIntImpl operator--(int) {
    ExtendedUnsignedIntImpl ret(*this);
    --*this;
    return ret;
  }

 public:
  // All the binary operators are friend operators
  // Comparison operators
#if PE_HAS_CPP20
  friend inline int operator<=>(const ExtendedUnsignedIntImpl& l,
                                const ExtendedUnsignedIntImpl& r) {
    return l.CompareTo(r);
  }
  friend inline int operator==(const ExtendedUnsignedIntImpl& l,
                               const ExtendedUnsignedIntImpl& r) {
    return l.CompareTo(r) == 0;
  }
  friend inline int operator!=(const ExtendedUnsignedIntImpl& l,
                               const ExtendedUnsignedIntImpl& r) {
    return l.CompareTo(r) != 0;
  }
#else
  friend inline int operator<(const ExtendedUnsignedIntImpl& l,
                              const ExtendedUnsignedIntImpl& r) {
    return l.CompareTo(r) < 0;
  }
  friend inline int operator<=(const ExtendedUnsignedIntImpl& l,
                               const ExtendedUnsignedIntImpl& r) {
    return l.CompareTo(r) <= 0;
  }
  friend inline int operator>(const ExtendedUnsignedIntImpl& l,
                              const ExtendedUnsignedIntImpl& r) {
    return l.CompareTo(r) > 0;
  }
  friend inline int operator>=(const ExtendedUnsignedIntImpl& l,
                               const ExtendedUnsignedIntImpl& r) {
    return l.CompareTo(r) >= 0;
  }
  friend inline int operator==(const ExtendedUnsignedIntImpl& l,
                               const ExtendedUnsignedIntImpl& r) {
    return l.CompareTo(r) == 0;
  }
  friend inline int operator!=(const ExtendedUnsignedIntImpl& l,
                               const ExtendedUnsignedIntImpl& r) {
    return l.CompareTo(r) != 0;
  }
#endif
  friend inline ExtendedUnsignedIntImpl operator+(
      const ExtendedUnsignedIntImpl& l, const ExtendedUnsignedIntImpl& r) {
    ExtendedUnsignedIntImpl ret(l);
    ret += r;
    return ret;
  }
  friend inline ExtendedUnsignedIntImpl operator-(
      const ExtendedUnsignedIntImpl& l, const ExtendedUnsignedIntImpl& r) {
    ExtendedUnsignedIntImpl ret(l);
    ret -= r;
    return ret;
  }
  friend inline ExtendedUnsignedIntImpl operator*(
      const ExtendedUnsignedIntImpl& l, const ExtendedUnsignedIntImpl& r) {
    ExtendedUnsignedIntImpl ret(l);
    ret *= r;
    return ret;
  }
  friend inline ExtendedUnsignedIntImpl operator/(
      const ExtendedUnsignedIntImpl& l, const ExtendedUnsignedIntImpl& r) {
    ExtendedUnsignedIntImpl ret(l);
    ret /= r;
    return ret;
  }
  friend inline ExtendedUnsignedIntImpl operator%(
      const ExtendedUnsignedIntImpl& l, const ExtendedUnsignedIntImpl& r) {
    ExtendedUnsignedIntImpl ret(l);
    ret %= r;
    return ret;
  }
  friend inline ExtendedUnsignedIntImpl operator&(
      const ExtendedUnsignedIntImpl& l, const ExtendedUnsignedIntImpl& r) {
    ExtendedUnsignedIntImpl ret(l);
    ret &= r;
    return ret;
  }
  friend inline ExtendedUnsignedIntImpl operator^(
      const ExtendedUnsignedIntImpl& l, const ExtendedUnsignedIntImpl& r) {
    ExtendedUnsignedIntImpl ret(l);
    ret ^= r;
    return ret;
  }
  friend inline ExtendedUnsignedIntImpl operator|(
      const ExtendedUnsignedIntImpl& l, const ExtendedUnsignedIntImpl& r) {
    ExtendedUnsignedIntImpl ret(l);
    ret |= r;
    return ret;
  }
  friend inline ExtendedUnsignedIntImpl operator<<(
      const ExtendedUnsignedIntImpl& l, const int cnt) {
    ExtendedUnsignedIntImpl ret(l);
    ret <<= cnt;
    return ret;
  }
  friend inline ExtendedUnsignedIntImpl operator>>(
      const ExtendedUnsignedIntImpl& l, const int cnt) {
    ExtendedUnsignedIntImpl ret(l);
    ret >>= cnt;
    return ret;
  }
  friend inline std::ostream& operator<<(std::ostream& o,
                                         const ExtendedUnsignedIntImpl& n) {
    return o << n.ToString();
  }
};

template <typename ET>
struct ExtendedUnsignedIntImpl<ET, false> : public UIntPairImpl<ET, false> {
  using NT = typename ET::NT;
  using base = UIntPairImpl<ET, false>;

 public:
  ExtendedUnsignedIntImpl(ET low = 0) : base(low) {}
  ExtendedUnsignedIntImpl(ET low, ET hi) : base(low, hi) {}

  template <typename T,
            typename TT = REQUIRES((is_native_integer<T>::value)) RETURN(T)>
  ExtendedUnsignedIntImpl(T v) : base(v) {}

  ExtendedUnsignedIntImpl(const std::string& str) : base(str) {}

  ExtendedUnsignedIntImpl(const ExtendedUnsignedIntImpl& other) : base(other) {}

  ExtendedUnsignedIntImpl& operator=(const ExtendedUnsignedIntImpl& other) {
    base::low_ = other.low();
    base::hi_ = other.hi();
    return *this;
  }

  ExtendedUnsignedIntImpl& operator=(const ExtendedUnsignedIntImpl&& other) {
    base::low_ = std::move(other.low());
    base::hi_ = std::move(other.hi());
    return *this;
  }

  ExtendedUnsignedIntImpl& operator=(const ET& other) {
    base::low_ = other;
    base::hi_.MakeZeroBits();
    return *this;
  }

  template <typename T,
            typename TT = REQUIRES((is_native_integer<T>::value)) RETURN(T)>
  ExtendedUnsignedIntImpl& operator=(const T& other) {
    base::MakeZeroBits();
    base::template FromNativeInt<T>(other);
    return *this;
  }

 public:
  void MakeAbs() {}

  ExtendedUnsignedIntImpl& DividedBy(const ExtendedUnsignedIntImpl& other) {
    base::DividedBy(other);
    return *this;
  }

  ExtendedUnsignedIntImpl& DividedBy(const ExtendedUnsignedIntImpl& other,
                                     ExtendedUnsignedIntImpl& r) {
    base::DividedBy(other);
    return *this;
  }

  ExtendedUnsignedIntImpl& Modulo(const ExtendedUnsignedIntImpl& other) {
    base::Modulo(other);
    return *this;
  }

 public:
  using base::low;

  using base::hi;

  int sign() const {
    return base::low_.IntSign() || base::hi_.IntSign() ? 1 : 0;
  }

  int CompareTo(const ExtendedUnsignedIntImpl& other) const {
    int t = base::hi_.CompareTo(other.hi_);
    if (t != 0) {
      return t;
    }
    return base::low_.CompareTo(other.low_);
  }

  int IntSign() const {
    return base::low_.IntSign() || base::hi_.IntSign() ? 1 : 0;
  }

  using base::IsZero;

  using base::IsEven;

  using base::IsOdd;

  using base::LowerBits;

  ExtendedUnsignedIntImpl Abs() const { return *this; }

  ExtendedUnsignedIntImpl FAbs() const { return *this; }

  using base::ToInt;

  using base::ToFloat;

  using base::SetBit;

  using base::ResetBit;

  using base::GetBit;

  using base::RevBit;

  using base::BitCount;

  using base::ToString;

  using base::to_string;

  ExtendedUnsignedIntImpl Difference(
      const ExtendedUnsignedIntImpl& other) const {
    auto t = base::Difference(other);
    return ExtendedUnsignedIntImpl(t.low(), t.hi());
  }

 public:
  // Operators
  ExtendedUnsignedIntImpl operator+() const { return *this; }

  ExtendedUnsignedIntImpl operator-() const {
    ExtendedUnsignedIntImpl ret(*this);
    base::FlipBits();
    base::AddOne();
    return ret;
  }

  ExtendedUnsignedIntImpl operator~() const {
    return ExtendedUnsignedIntImpl(~base::low_, ~base::hi_);
  }

  ExtendedUnsignedIntImpl& operator+=(const ExtendedUnsignedIntImpl& other) {
    base::AddedBy(other);
    return *this;
  }

  ExtendedUnsignedIntImpl& operator+=(const ET& other) {
    return *this += ExtendedUnsignedIntImpl(other);
  }

  template <typename T>
  REQUIRES((is_native_integer<T>::value))
  RETURN(ExtendedUnsignedIntImpl&) operator+=(const T& other) {
    return *this += ExtendedUnsignedIntImpl(other);
  }

  ExtendedUnsignedIntImpl& operator-=(const ExtendedUnsignedIntImpl& other) {
    base::Substract(other);
    return *this;
  }

  ExtendedUnsignedIntImpl& operator-=(const ET& other) {
    return *this -= ExtendedUnsignedIntImpl(other);
  }

  template <typename T>
  REQUIRES((is_native_integer<T>::value))
  RETURN(ExtendedUnsignedIntImpl&) operator-=(const T& other) {
    return *this -= ExtendedUnsignedIntImpl(other);
  }

  ExtendedUnsignedIntImpl& operator*=(const ExtendedUnsignedIntImpl& other) {
    base::MultipliedBy(other);
    return *this;
  }

  ExtendedUnsignedIntImpl& operator*=(const ET& other) {
    return *this *= ExtendedUnsignedIntImpl(other);
  }

  template <typename T>
  REQUIRES((is_native_integer<T>::value))
  RETURN(ExtendedUnsignedIntImpl&) operator*=(const T& other) {
    return *this *= ExtendedUnsignedIntImpl(other);
  }

  ExtendedUnsignedIntImpl& operator/=(const ExtendedUnsignedIntImpl& other) {
    return DividedBy(other);
  }

  ExtendedUnsignedIntImpl& operator/=(const ET& other) {
    return *this /= ExtendedUnsignedIntImpl(other);
  }

  template <typename T>
  REQUIRES((is_native_integer<T>::value))
  RETURN(ExtendedUnsignedIntImpl&) operator/=(const T& other) {
    return *this /= ExtendedUnsignedIntImpl(other);
  }

  ExtendedUnsignedIntImpl& operator%=(const ExtendedUnsignedIntImpl& other) {
    return Modulo(other);
  }

  ExtendedUnsignedIntImpl& operator%=(const ET& other) {
    return *this %= ExtendedUnsignedIntImpl(other);
  }

  template <typename T>
  REQUIRES((is_native_integer<T>::value))
  RETURN(ExtendedUnsignedIntImpl&) operator%=(const T& other) {
    return *this %= ExtendedUnsignedIntImpl(other);
  }

  ExtendedUnsignedIntImpl& operator&=(const ExtendedUnsignedIntImpl& other) {
    base::low_ &= other.low();
    base::hi_ &= other.hi();
    return *this;
  }

  template <typename T>
  REQUIRES((is_native_integer<T>::value))
  RETURN(ExtendedUnsignedIntImpl&) operator&=(const T& other) {
    return *this &= ExtendedUnsignedIntImpl(other);
  }

  ExtendedUnsignedIntImpl& operator&=(const ET& other) {
    return *this &= ExtendedUnsignedIntImpl(other);
  }

  ExtendedUnsignedIntImpl& operator^=(const ExtendedUnsignedIntImpl& other) {
    base::low_ ^= other.low();
    base::hi_ ^= other.hi();
    return *this;
  }

  ExtendedUnsignedIntImpl& operator^=(const ET& other) {
    return *this ^= ExtendedUnsignedIntImpl(other);
  }

  template <typename T>
  REQUIRES((is_native_integer<T>::value))
  RETURN(ExtendedUnsignedIntImpl&) operator^=(const T& other) {
    return *this ^= ExtendedUnsignedIntImpl(other);
  }

  ExtendedUnsignedIntImpl& operator|=(const ExtendedUnsignedIntImpl& other) {
    base::low_ |= other.low();
    base::hi_ |= other.hi();
    return *this;
  }

  ExtendedUnsignedIntImpl& operator|=(const ET& other) {
    return *this |= ExtendedUnsignedIntImpl(other);
  }

  template <typename T>
  REQUIRES((is_native_integer<T>::value))
  RETURN(ExtendedUnsignedIntImpl&) operator|=(const T& other) {
    return *this |= ExtendedUnsignedIntImpl(other);
  }

  ExtendedUnsignedIntImpl& operator>>=(int cnt) {
    base::ShiftRight(cnt);
    return *this;
  }

  ExtendedUnsignedIntImpl& operator<<=(int cnt) {
    base::ShiftLeft(cnt);
    return *this;
  }

  ExtendedUnsignedIntImpl& operator++() {
    base::AddOne();
    return *this;
  }

  ExtendedUnsignedIntImpl operator++(int) {
    ExtendedUnsignedIntImpl ret(*this);
    *this += 1;
    return ret;
  }

  ExtendedUnsignedIntImpl& operator--() {
    if (!base::low_.IsZero()) {
      --base::low_;
    } else {
      --base::low_;
      --base::hi_;
    }
    return *this;
  }

  ExtendedUnsignedIntImpl operator--(int) {
    ExtendedUnsignedIntImpl ret(*this);
    *this -= 1;
    return ret;
  }

 public:
  // All the binary operators are friend operators
  // Comparison operators
#if PE_HAS_CPP20
  friend inline int operator<=>(const ExtendedUnsignedIntImpl& l,
                                const ExtendedUnsignedIntImpl& r) {
    return l.CompareTo(r);
  }
  friend inline int operator==(const ExtendedUnsignedIntImpl& l,
                               const ExtendedUnsignedIntImpl& r) {
    return l.CompareTo(r) == 0;
  }
  friend inline int operator!=(const ExtendedUnsignedIntImpl& l,
                               const ExtendedUnsignedIntImpl& r) {
    return l.CompareTo(r) != 0;
  }
#else
  friend inline int operator<(const ExtendedUnsignedIntImpl& l,
                              const ExtendedUnsignedIntImpl& r) {
    return l.CompareTo(r) < 0;
  }
  friend inline int operator<=(const ExtendedUnsignedIntImpl& l,
                               const ExtendedUnsignedIntImpl& r) {
    return l.CompareTo(r) <= 0;
  }
  friend inline int operator>(const ExtendedUnsignedIntImpl& l,
                              const ExtendedUnsignedIntImpl& r) {
    return l.CompareTo(r) > 0;
  }
  friend inline int operator>=(const ExtendedUnsignedIntImpl& l,
                               const ExtendedUnsignedIntImpl& r) {
    return l.CompareTo(r) >= 0;
  }
  friend inline int operator==(const ExtendedUnsignedIntImpl& l,
                               const ExtendedUnsignedIntImpl& r) {
    return l.CompareTo(r) == 0;
  }
  friend inline int operator!=(const ExtendedUnsignedIntImpl& l,
                               const ExtendedUnsignedIntImpl& r) {
    return l.CompareTo(r) != 0;
  }
#endif
  friend inline ExtendedUnsignedIntImpl operator+(
      const ExtendedUnsignedIntImpl& l, const ExtendedUnsignedIntImpl& r) {
    ExtendedUnsignedIntImpl ret(l);
    ret += r;
    return ret;
  }
  friend inline ExtendedUnsignedIntImpl operator-(
      const ExtendedUnsignedIntImpl& l, const ExtendedUnsignedIntImpl& r) {
    ExtendedUnsignedIntImpl ret(l);
    ret -= r;
    return ret;
  }
  friend inline ExtendedUnsignedIntImpl operator*(
      const ExtendedUnsignedIntImpl& l, const ExtendedUnsignedIntImpl& r) {
    ExtendedUnsignedIntImpl ret(l);
    ret *= r;
    return ret;
  }
  friend inline ExtendedUnsignedIntImpl operator/(
      const ExtendedUnsignedIntImpl& l, const ExtendedUnsignedIntImpl& r) {
    ExtendedUnsignedIntImpl ret(l);
    ret /= r;
    return ret;
  }
  friend inline ExtendedUnsignedIntImpl operator%(
      const ExtendedUnsignedIntImpl& l, const ExtendedUnsignedIntImpl& r) {
    ExtendedUnsignedIntImpl ret(l);
    ret %= r;
    return ret;
  }
  friend inline ExtendedUnsignedIntImpl operator&(
      const ExtendedUnsignedIntImpl& l, const ExtendedUnsignedIntImpl& r) {
    ExtendedUnsignedIntImpl ret(l);
    ret &= r;
    return ret;
  }
  friend inline ExtendedUnsignedIntImpl operator^(
      const ExtendedUnsignedIntImpl& l, const ExtendedUnsignedIntImpl& r) {
    ExtendedUnsignedIntImpl ret(l);
    ret ^= r;
    return ret;
  }
  friend inline ExtendedUnsignedIntImpl operator|(
      const ExtendedUnsignedIntImpl& l, const ExtendedUnsignedIntImpl& r) {
    ExtendedUnsignedIntImpl ret(l);
    ret |= r;
    return ret;
  }
  friend inline ExtendedUnsignedIntImpl operator<<(
      const ExtendedUnsignedIntImpl& l, const int cnt) {
    ExtendedUnsignedIntImpl ret(l);
    ret <<= cnt;
    return ret;
  }
  friend inline ExtendedUnsignedIntImpl operator>>(
      const ExtendedUnsignedIntImpl& l, const int cnt) {
    ExtendedUnsignedIntImpl ret(l);
    ret >>= cnt;
    return ret;
  }
  friend inline std::ostream& operator<<(std::ostream& o,
                                         const ExtendedUnsignedIntImpl& n) {
    return o << n.ToString();
  }
};

template <typename ET, bool is_native_integer>
SL int IsZero(const ExtendedUnsignedIntImpl<ET, is_native_integer>& x) {
  return x.IsZero();
}

template <typename ET, bool is_native_integer>
SL int IntSign(const ExtendedUnsignedIntImpl<ET, is_native_integer>& x) {
  return x.IntSign();
}

template <typename ET, bool is_native_integer>
SL int IsEven(const ExtendedUnsignedIntImpl<ET, is_native_integer>& x) {
  return x.IsEven();
}

template <typename ET, bool is_native_integer>
SL int IsOdd(const ExtendedUnsignedIntImpl<ET, is_native_integer>& x) {
  return x.IsOdd();
}

template <typename ET, bool is_native_integer>
SL unsigned int LowerBits(
    const ExtendedUnsignedIntImpl<ET, is_native_integer>& x) {
  return x.LowerBits();
}

template <typename ET, bool is_native_integer>
SL ExtendedUnsignedIntImpl<ET, is_native_integer> Abs(
    const ExtendedUnsignedIntImpl<ET, is_native_integer>& x) {
  return x;
}

template <typename ET, bool is_native_integer>
SL ExtendedUnsignedIntImpl<ET, is_native_integer> FAbs(
    const ExtendedUnsignedIntImpl<ET, is_native_integer>& x) {
  return x;
}

template <typename ET, bool is_native_integer>
SL int SameParity(const ExtendedUnsignedIntImpl<ET, is_native_integer>& l,
                  const ExtendedUnsignedIntImpl<ET, is_native_integer>& r) {
  return SameParity(l.LowerBits(), r.LowerBits());
}

template <typename ET, bool is_native_integer>
SL std::tuple<ExtendedUnsignedIntImpl<ET, is_native_integer>,
              ExtendedUnsignedIntImpl<ET, is_native_integer>>
Div(const ExtendedUnsignedIntImpl<ET, is_native_integer>& l,
    const ExtendedUnsignedIntImpl<ET, is_native_integer>& r) {
  ExtendedUnsignedIntImpl<ET, is_native_integer> remain;
  ExtendedUnsignedIntImpl<ET, is_native_integer> d(l);
  d.DividedBy(r, remain);
  return {d, remain};
}

template <typename T, typename ET, bool is_native_integer>
SL T ToInt(const ExtendedUnsignedIntImpl<ET, is_native_integer>& x) {
  return x.template ToInt<T>();
}

template <typename T, typename ET, bool is_native_integer>
SL T ToFloat(const ExtendedUnsignedIntImpl<ET, is_native_integer>& x) {
  return x.template ToFloat<T>();
}

template <typename ET, bool is_native_integer>
SL std::string ToString(
    const ExtendedUnsignedIntImpl<ET, is_native_integer>& x) {
  return x.ToString();
}

template <typename ET, bool is_native_integer>
SL std::string to_string(
    const ExtendedUnsignedIntImpl<ET, is_native_integer>& x) {
  return ToString(x);
}

template <typename ET, bool is_native_integer, typename T2>
SL REQUIRES((pe::is_native_integer<T2>::value))
    RETURN(ExtendedUnsignedIntImpl<ET, is_native_integer>)
        Power(ExtendedUnsignedIntImpl<ET, is_native_integer> x, T2 n) {
  PE_ASSERT(n >= 0);
  ExtendedUnsignedIntImpl<ET, is_native_integer> ret = 1;
  for (; n > 0; n >>= 1) {
    if (n & 1) ret *= x;
    if (n > 1) x *= x;
  }
  return ret;
}

template <typename ET, bool is_native_integer, typename T2, typename T3>
SL REQUIRES((pe::is_native_integer<T2>::value))
    RETURN(ExtendedUnsignedIntImpl<ET, is_native_integer>)
        Power(ExtendedUnsignedIntImpl<ET, is_native_integer> x, T2 n, T3 mod) {
  PE_ASSERT(n >= 0);
  ExtendedUnsignedIntImpl<ET, is_native_integer> ret = 1;
  for (; n > 0; n >>= 1) {
    if (n & 1) ret = ret * x % mod;
    if (n > 1) x = x * x % mod;
  }
  return ret;
}

template <typename ET>
using ExtendedUnsignedInt =
    ExtendedUnsignedIntImpl<ET, is_native_integer<ET>::value>;

#if PE_HAS_CPP20
static_assert(PeNumberUtil<ExtendedUnsignedInt<uint64>>);
#if PE_HAS_INT128
static_assert(PeNumberUtil<ExtendedUnsignedInt<uint128>>);
#endif
#endif
}  // namespace pe

#endif
