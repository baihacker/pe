#ifndef PE_MOD_
#define PE_MOD_

#include "pe_base"
#include "pe_type_traits"
#include "pe_bit"

namespace pe {
// Modular arithmetic
template <typename T, typename TM>
SL constexpr REQUIRES((is_builtin_integer_v<T> && is_builtin_integer_v<TM> &&
                       pe_is_signed_v<T> && pe_is_signed_v<TM>))
    RETURN(int_promotion_t<T, TM>) Mod(T a, TM mod) {
  PE_ASSERT(mod >= 1);
  ASSUME(mod >= 1);
  if (a >= 0) {
    return a >= mod ? a % mod : a;
  } else {
    auto tmp = a % mod;
    if (tmp < 0) tmp += mod;
    return tmp;
  }
}

template <typename T, typename TM>
SL constexpr REQUIRES((is_builtin_integer_v<T> && is_builtin_integer_v<TM> &&
                       pe_is_signed_v<T> && pe_is_unsigned_v<TM>))
    RETURN(int_promotion_t<T, TM>) Mod(T a, TM mod) {
  PE_ASSERT(mod >= 1);
  ASSUME(mod >= 1);
  if (a >= 0) {
    return a >= mod ? a % mod : a;
  } else {
    auto t = -a;
    if (t >= mod) t %= mod;
    return t == 0 ? 0 : mod - t;
  }
}

template <typename T, typename TM>
SL constexpr REQUIRES((is_builtin_integer_v<T> && is_builtin_integer_v<TM> &&
                       pe_is_unsigned_v<T>)) RETURN(int_promotion_t<T, TM>)
    Mod(T a, TM mod) {
  PE_ASSERT(mod >= 1);
  ASSUME(mod >= 1);
  using ResultType = int_promotion_t<T, TM>;
  ResultType b = a, m = mod;
  if (b >= m) b %= m;
  return b;
}

template <typename T>
SL constexpr REQUIRES((is_builtin_integer_v<T>)) RETURN(T) Mod(T a, T mod) {
  return Mod<T, T>(a, mod);
}

namespace internal {
template <typename T, typename TM>
SL constexpr REQUIRES((is_builtin_integer_v<T> && is_builtin_integer_v<TM>))
    RETURN(int_promotion_t<T, TM>) AddModImpl(T a, T b, TM mod) {
  using ResultType = int_promotion_t<T, TM>;
  ASSUME(mod >= 1);
#if 0
  auto t0 = a;
  t0 += b;
  ResultType t1 = t0, m = mod;
  if (t1 >= m) t1 -= m;
  return t1;
#else
  ResultType a0 = a, b0 = b, m0 = mod;
  a0 += b0;
  if (a0 >= m0) a0 -= m0;
  return a0;
#endif
}
}  // namespace internal

template <typename T1, typename T2, typename TM>
SL constexpr REQUIRES((is_builtin_integer_v<T1> && is_builtin_integer_v<T2> &&
                       is_builtin_integer_v<TM>))
    RETURN(int_promotion_t<T1, T2, TM>) AddMod(T1 a, T2 b, TM mod) {
  using T = int_promotion_t<T1, T2>;
  return internal::AddModImpl<T, TM>(a, b, mod);
}

template <typename TM, typename T>
SL constexpr T SumMod(TM /*mod*/, T a) {
  return a;
}

template <typename TM, typename TH, typename... TT>
SL constexpr int_promotion_t<TH, TT...> SumMod(TM mod, TH a, TT... b) {
  return AddMod(a, SumMod(mod, b...), mod);
}

template <typename TM, typename T>
SL constexpr REQUIRES((is_builtin_integer_v<T>)) RETURN(T)
    SumMod(TM mod, std::initializer_list<T> init) {
  T ret = 0;
  for (auto& v : init) {
    ret = AddMod(ret, v, mod);
  }
  return ret;
}

namespace internal {
template <typename T, typename TM>
SL constexpr REQUIRES((is_builtin_integer_v<T> && is_builtin_integer_v<TM>))
    RETURN(int_promotion_t<T, TM>) SubModImpl(T a, T b, TM mod) {
  return a >= b ? a - b : mod - b + a;
}
}  // namespace internal

template <typename T1, typename T2, typename TM>
SL constexpr REQUIRES((is_builtin_integer_v<T1> && is_builtin_integer_v<T2> &&
                       is_builtin_integer_v<TM>))
    RETURN(int_promotion_t<T1, T2, TM>) SubMod(T1 a, T2 b, TM mod) {
  using T = int_promotion_t<T1, T2>;
  return internal::SubModImpl<T, TM>(a, b, mod);
}

namespace internal {
template <typename T, typename TM>
SL constexpr REQUIRES((is_builtin_integer_v<T> && is_builtin_integer_v<TM>))
    RETURN(int_promotion_t<T, TM>) MulModImpl(T a, T b, TM mod) {
  ASSUME(mod >= 1);
  return a * b % mod;
}
}  // namespace internal

#if PE_HAS_INT128
// Returns a % b.
// If possible, it uses an assembly language implementation which requires a / b
// <= uint64_max, otherwise an exception is thrown.
// The common use case is a = x * y whwere x < b and y < b.
SL uint64 Uint128ModUint64(uint128 a, uint64 b) {
#if defined(COMPILER_GNU) && PE_X86_64
  uint64 q, r;
  __asm__("divq\t%4"
          : "=a"(q), "=d"(r)
          : "0"(uint64(a)), "1"(uint64(a >> 64)), "rm"(b));
  return r;
#else
  return a % b;
#endif
}
#endif

SL constexpr uint32 MulModUint32(uint32 a, uint32 b, uint32 mod) {
  if (mod >> 16) {
    return uint64(a) * b % mod;
  } else {
    return a * b % mod;
  }
}

SL constexpr int32 MulModInt32(int32 a, int32 b, int32 mod) {
  if (static_cast<uint32>(mod) >> 15) {
    return int64(a) * b % mod;
  } else {
    return a * b % mod;
  }
}

#define PE_MUL_MOD_PREFER_TO_SHELL_CODE 0
#define USE_MSVC_VERSION_SHELL_CODE 1

// Gnu assembly language implementation
#if defined(COMPILER_GNU) && PE_X86_64
SL uint64 MulModUint64GnuAsm(uint64 a, uint64 b, uint64 mod) {
  if (!(mod >> 32)) {
    uint32 q, r;
    __asm__(
        "movl %2,%%eax\n\t"
        "mull %3\n\t"
        "divl %4\n\t"
        : "=a"(q), "=d"(r)
        : "0"(uint32(a)), "1"(uint32(b)), "rm"(uint32(mod)));
    return r;

  } else {
    uint64 q, r;
    __asm__(
        "movq %2,%%rax\n\t"
        "mulq %3\n\t"
        "divq %4\n\t"
        : "=a"(q), "=d"(r)
        : "0"(uint64(a)), "1"(uint64(b)), "rm"(uint64(mod)));
    return r;
  }
}

SL int64 MulModInt64GnuAsm(int64 a, int64 b, int64 mod) {
  if (!(static_cast<uint64>(mod) >> 31)) {
    int32 q, r;
    __asm__(
        "movl %2,%%eax\n\t"
        "imull %3\n\t"
        "idivl %4\n\t"
        : "=a"(q), "=d"(r)
        : "0"(int32(a)), "1"(int32(b)), "rm"(int32(mod)));
    return r;

  } else {
    int64 q, r;
    __asm__(
        "movq %2,%%rax\n\t"
        "imulq %3\n\t"
        "idivq %4\n\t"
        : "=a"(q), "=d"(r)
        : "0"(a), "1"(b), "rm"(mod));
    return r;
  }
}

#define PE_MUL_MOD_GNU_ASM_AVAILABLE 1
#else
#define PE_MUL_MOD_GNU_ASM_AVAILABLE 0
#endif

// Shell code implementation
#if OS_TYPE_WIN && PE_X86_64

namespace internal {
extern "C" {
using MulModUint64FunctionPointerType = uint64 (*)(uint64, uint64, uint64);
using MulModInt64FunctionPointerType = int64 (*)(int64, int64, int64);
}

#if USE_MSVC_VERSION_SHELL_CODE

// ml64.exe -c <source_code>
/**
.CODE

MulModUint64 PROC
  mov         rax,rcx
  mov         rcx,r8
  shr         rcx,20h
  jne         LB0
  mov         eax,eax
  mul         edx
  div         r8d
  mov         eax,edx
  ret
  LB0:
  mov         rax,rax
  mul         rdx
  div         r8
  mov         rax,rdx
  ret
MulModUint64 ENDP

END
*/

constexpr char __MulModUint64ShellCode[] =
    "\x48\x8b\xc1\x49\x8b\xc8\x48\xc1\xe9\x20\x75\x0a\x8b\xc0\xf7\xe2"
    "\x41\xf7\xf0\x8b\xc2\xc3\x48\x8b\xc0\x48\xf7\xe2\x49\xf7\xf0\x48"
    "\x8b\xc2\xc3";

// ml64.exe -c <source_code>
/**
.CODE

MulModInt64 PROC
  mov         rax,rcx
  mov         rcx,r8
  shr         rcx,1Fh
  jne         LB1
  mov         eax,eax
  imul        edx
  idiv        r8d
  movsxd      rax,edx
  ret
  LB1:
  mov         rax,rax
  imul        rdx
  idiv        r8
  mov         rax,rdx
  ret
MulModInt64 ENDP

END
*/

constexpr char __MulModInt64ShellCode[] =
    "\x48\x8b\xc1\x49\x8b\xc8\x48\xc1\xe9\x1f\x75\x0b\x8b\xc0\xf7\xea"
    "\x41\xf7\xf8\x48\x63\xc2\xc3\x48\x8b\xc0\x48\xf7\xea\x49\xf7\xf8"
    "\x48\x8b\xc2\xc3";
#else

// Built from MulModUint64GnuAsm
/**
  mov         rax,rcx
  mov         rcx,r8
  shr         rcx,20h
  jne         MulModUint64GnuAsm+20h
  mov         eax,eax
  mul         eax,edx
  div         eax,r8d
  mov         eax,edx
  ret
  nop         word ptr cs:[rax+rax]
  mov         rax,rax
  mul         rax,rdx
  div         rax,r8
  mov         rax,rdx
  ret
*/

constexpr char __MulModUint64ShellCode[] =
    "\x48\x89\xc8\x4c\x89\xc1\x48\xc1\xe9\x20\x75\x14\x89\xc0\xf7\xe2"
    "\x41\xf7\xf0\x89\xd0\xc3\x66\x2e\x0f\x1f\x84\x00\x00\x00\x00\x00"
    "\x48\x89\xc0\x48\xf7\xe2\x49\xf7\xf0\x48\x89\xd0\xc3";

// Built from MulModInt64GnuAsm
/**
  mov         rax,rcx
  mov         rcx,r8
  shr         rcx,1Fh
  jne         MulModInt64GnuAsm+20h
  mov         eax,eax
  imul        edx
  idiv        eax,r8d
  movsxd      rax,edx
  ret
  nop         word ptr [rax+rax]
  mov         rax,rax
  imul        rdx
  idiv        rax,r8
  mov         rax,rdx
  ret
*/

constexpr char __MulModInt64ShellCode[] =
    "\x48\x89\xc8\x4c\x89\xc1\x48\xc1\xe9\x1f\x75\x14\x89\xc0\xf7\xea"
    "\x41\xf7\xf8\x48\x63\xc2\xc3\x66\x0f\x1f\x84\x00\x00\x00\x00\x00"
    "\x48\x89\xc0\x48\xf7\xea\x49\xf7\xf8\x48\x89\xd0\xc3";
#endif

SL int __MakeMulModShellCodeExecutable() {
  DWORD dwOld = 0;
  VirtualProtect(
      reinterpret_cast<void*>(const_cast<char*>(&__MulModUint64ShellCode[0])),
      sizeof(__MulModUint64ShellCode), PAGE_EXECUTE_READWRITE, &dwOld);
  dwOld = 0;
  VirtualProtect(
      reinterpret_cast<void*>(const_cast<char*>(&__MulModInt64ShellCode[0])),
      sizeof(__MulModInt64ShellCode), PAGE_EXECUTE_READWRITE, &dwOld);
  return 0;
}
const static int __init_code_data_once = __MakeMulModShellCodeExecutable();
}  // namespace internal

SL uint64 MulModUint64ShellCode(uint64 a, uint64 b, uint64 mod) {
  auto code = reinterpret_cast<internal::MulModUint64FunctionPointerType>(
      reinterpret_cast<unsigned char*>(
          const_cast<char*>(&internal::__MulModUint64ShellCode[0])));
  return code(a, b, mod);
}

SL int64 MulModInt64ShellCode(int64 a, int64 b, int64 mod) {
  auto code = reinterpret_cast<internal::MulModInt64FunctionPointerType>(
      reinterpret_cast<unsigned char*>(
          const_cast<char*>(&internal::__MulModInt64ShellCode[0])));
  return code(a, b, mod);
}
#define PE_MUL_MOD_SHELL_CODE_AVAILABLE 1
#else
#define PE_MUL_MOD_SHELL_CODE_AVAILABLE 0
#endif

#if PE_MUL_MOD_SHELL_CODE_AVAILABLE || PE_MUL_MOD_GNU_ASM_AVAILABLE
SL uint64 MulModUint64(uint64 a, uint64 b, uint64 mod) {
#if PE_MUL_MOD_SHELL_CODE_AVAILABLE && \
    (!PE_MUL_MOD_GNU_ASM_AVAILABLE ||  \
     PE_MUL_MOD_GNU_ASM_AVAILABLE && PE_MUL_MOD_PREFER_TO_SHELL_CODE)
  return MulModUint64ShellCode(a, b, mod);
#else
  return MulModUint64GnuAsm(a, b, mod);
#endif
}

SL int64 MulModInt64(int64 a, int64 b, int64 mod) {
#if PE_MUL_MOD_SHELL_CODE_AVAILABLE && \
    (!PE_MUL_MOD_GNU_ASM_AVAILABLE ||  \
     PE_MUL_MOD_GNU_ASM_AVAILABLE && PE_MUL_MOD_PREFER_TO_SHELL_CODE)
  return MulModInt64ShellCode(a, b, mod);
#else
  return MulModInt64GnuAsm(a, b, mod);
#endif
}
#endif

std::once_flag show_mul_mod_slow_warning_flag;

SL void MulModSlowWarningOnce() {
  std::call_once(show_mul_mod_slow_warning_flag,
                 []() { fprintf(stderr, "MulMod may be very slow.\n"); });
}

// If the biggest operand size is greater than sizeof(int64), just convert every
// operand to that and multiply them directly.
template <typename T1, typename T2, typename TM>
SL constexpr REQUIRES((is_builtin_integer_v<T1> && is_builtin_integer_v<T2> &&
                       is_builtin_integer_v<TM> &&
                       (sizeof(T1) > sizeof(int64) ||
                        sizeof(T2) > sizeof(int64) ||
                        sizeof(TM) > sizeof(int64))))
    RETURN(int_promotion_t<T1, T2, TM>) MulMod(T1 a, T2 b, TM mod) {
  using ResultType = int_promotion_t<T1, T2, TM>;
  ASSUME(mod >= 1);
  return static_cast<ResultType>(a) * static_cast<ResultType>(b) %
         static_cast<ResultType>(mod);
}

// If all the operand size is no more than sizeof(int32), use uint32
// implementation.
template <typename T1, typename T2, typename TM>
SL constexpr REQUIRES((is_builtin_integer_v<T1> && is_builtin_integer_v<T2> &&
                       is_builtin_integer_v<TM> &&
                       (sizeof(T1) <= sizeof(int32) &&
                        sizeof(T2) <= sizeof(int32) &&
                        sizeof(TM) <= sizeof(int32)))) RETURN(uint32)
    MulMod(T1 a, T2 b, TM mod) {
  return MulModUint32(a, b, mod);
}

// At least one of the operand size is sizeof(int64) and all are no more than
// sizeof(int64).
template <typename T1, typename T2, typename TM>
SL REQUIRES((is_builtin_integer_v<T1> && is_builtin_integer_v<T2> &&
             is_builtin_integer_v<TM> &&
             (sizeof(T1) > sizeof(int32) || sizeof(T2) > sizeof(int32) ||
              sizeof(TM) > sizeof(int32)) &&
             (sizeof(T1) <= sizeof(int64) && sizeof(T2) <= sizeof(int64) &&
              sizeof(TM) <= sizeof(int64))))
    RETURN(int_promotion_t<T1, T2, int64, TM>) MulMod(T1 a, T2 b, TM mod) {
  using T = int_promotion_t<T1, T2>;
  using AtLeastInt64T = at_least_int64_t<T>;
  using ResultType = int_promotion_t<AtLeastInt64T, T>;
  ASSUME(mod >= 1);

#if PE_MUL_MOD_SHELL_CODE_AVAILABLE && \
    (!PE_MUL_MOD_GNU_ASM_AVAILABLE ||  \
     PE_MUL_MOD_GNU_ASM_AVAILABLE && PE_MUL_MOD_PREFER_TO_SHELL_CODE)
  return static_cast<ResultType>(MulModUint64ShellCode(a, b, mod));
#elif PE_MUL_MOD_GNU_ASM_AVAILABLE
  return static_cast<ResultType>(MulModUint64GnuAsm(a, b, mod));
#else
  if (mod <= PE_SOI63) {
    return internal::MulModImpl<AtLeastInt64T, TM>(a, b, mod);
  }
#if PE_HAS_INT128
  return static_cast<ResultType>(internal::MulModImpl<int128, TM>(a, b, mod));
#else

  // The openmp has issue about long double on windows.
  // Seems caused by thread library.
  // https://sourceforge.net/p/mingw-w64/bugs/678/
#if defined(COMPILER_GNU) && OS_TYPE_WIN && ENABLE_OPENMP
  constexpr bool GNU_ON_WINDOWS_WITH_OPENMP = true;
#else
  constexpr bool GNU_ON_WINDOWS_WITH_OPENMP = false;
#endif
  constexpr bool CAN_USE_LONG_DOUBLE =
      sizeof(long double) > sizeof(double) && !GNU_ON_WINDOWS_WITH_OPENMP;

  if (CAN_USE_LONG_DOUBLE) {
    const int64 x = a, y = b, m = mod;
    int64 r = (x * y - static_cast<int64>(((long double)x * y) / m) * m);
    if (r >= m) r -= r / m * m;
    if (r < 0) r += m;
    return r;
  }

  MulModSlowWarningOnce();
// 3 other implementations
#if 0
  // Mpz based implementation
  // GMP_LIMB_BITS == 64 and GMP_NAIL_BITS == 0
  mpz_t A;
  mpz_init2(A, 64);
  mpz_t B;
  mpz_init2(B, 64);
  A[0]._mp_size = 1;
  A[0]._mp_d[0] = a;

  B[0]._mp_size = 1;
  B[0]._mp_d[0] = b;

  mpz_t M;
  mpz_init2(M, 64);
  M[0]._mp_size = 1;
  M[0]._mp_d[0] = mod;

  mpz_mul(A, A, B);
  mpz_mod(A, A, M);

  auto ret = A[0]._mp_d[0];
  mpz_clear(A);
  mpz_clear(B);
  mpz_clear(M);
  return ret;
#elif 1
  const uint64 ua = static_cast<uint64>(a);
  const uint64 ub = static_cast<uint64>(b);
  const uint64 umod = static_cast<uint64>(mod);
  if (ua == 0 || ub == 0) {
    return 0;
  }
  if (ua <= ub) {
    uint64 ret = 0;
    int used = pe_clzll(ua);
    const int d = pe_clzll(ub);
    const uint64 mask = (1ULL << d) - 1;
    while (used < 64) {
      const int now = std::min(64 - used, d);
      const uint64 t0 = (ua >> (64 - used - now)) & mask;
      const uint64 t1 = t0 * ub % umod;
      ret = (ret << now) % umod;
      ret += t1;
      if (ret >= umod) ret -= umod;
      used += now;
    }
    return static_cast<ResultType>(ret);
  } else {
    uint64 ret = 0;
    int used = pe_clzll(ub);
    const int d = pe_clzll(ua);
    const uint64 mask = (1ULL << d) - 1;
    while (used < 64) {
      const int now = std::min(64 - used, d);
      const uint64 t0 = (ub >> (64 - used - now)) & mask;
      const uint64 t1 = t0 * ua % umod;
      ret = (ret << now) % umod;
      ret += t1;
      if (ret >= umod) ret -= umod;
      used += now;
    }
    return static_cast<ResultType>(ret);
  }
#elif 0
  AtLeastInt64T ret = 0;
  AtLeastInt64T flag = b;
  for (AtLeastInt64T d = 1; d <= (AtLeastInt64T)a; d <<= 1) {
    if (d & a) {
      ret = (ret + flag) % mod;
    }
    flag = (flag << 1) % mod;
  }
  return static_cast<ResultType>(ret);
#endif

#endif

#endif
}

template <typename TM, typename T>
SL T ProdMod(TM /*mod*/, T a) {
  return a;
}

template <typename TM, typename TH, typename... TT>
SL int_promotion_t<TH, TT...> ProdMod(TM mod, TH a, TT... b) {
  return MulMod(a, ProdMod(mod, b...), mod);
}

template <typename TM, typename T>
SL REQUIRES((is_builtin_integer_v<T>)) RETURN(T)
    ProdMod(TM mod, std::initializer_list<T> init) {
  T ret = 1;
  if (mod == 1) {
    return 0;
  }
  for (auto& v : init) {
    ret = MulMod(ret, v, mod);
  }
  return ret;
}

namespace internal {
template <typename T, typename TN, typename TM>
SL REQUIRES((is_builtin_integer_v<T> && is_builtin_integer_v<TN> &&
             is_builtin_integer_v<TM>)) RETURN(int_promotion_t<T, TM>)
    PowerModImpl(T x, TN n, TM mod) {
  PE_ASSERT(n >= 0);
  if (mod == 1) return 0;
  using ResultType = int_promotion_t<T, TM>;

  ResultType ret = 1;
  auto y = Mod(x, mod);
  for (; n; n >>= 1) {
    if (n & 1) ret = MulMod(ret, y, mod);
    y = MulMod(y, y, mod);
  }
  return ret;
}
}  // namespace internal

template <typename T, typename TN, typename TM>
SL REQUIRES((is_builtin_integer_v<T> && is_builtin_integer_v<TN> &&
             is_builtin_integer_v<TM>)) RETURN(int_promotion_t<T, int64, TM>)
    PowerMod(T x, TN n, TM mod) {
  using AtLeastInt64T = at_least_int64_t<T>;
  return internal::PowerModImpl<AtLeastInt64T, TN, TM>(x, n, mod);
}

template <typename T>
SL REQUIRES((is_builtin_or_extended_integer_v<T>)) RETURN(T) Gcd(T m, T n);

template <typename GBI>
SL REQUIRES((is_gbi_v<GBI>)) RETURN(GBI) Gcd(GBI m, GBI n);

template <typename T0, typename T1>
SL REQUIRES((is_general_integer_v<T0> && is_general_integer_v<T1>))
    RETURN(int_promotion_t<T0, T1>) Gcd(const T0& m, const T1& n);

template <typename T>
SL REQUIRES((is_general_integer_v<T>)) RETURN(T) Gcd(const T& a);

template <typename TH, typename... TT>
SL REQUIRES(((sizeof...(TT) >= 2) && (is_general_integer_v<TH>) &&
             (predicate_all_v<is_general_integer, TT...>)))
    RETURN(int_promotion_t<TH, TT...>) Gcd(TH a, TT... b);

namespace internal {
template <typename T, typename TM>
SL REQUIRES((is_builtin_integer_v<T> && is_builtin_integer_v<TM>))
    RETURN(int_promotion_t<T, TM>)
        FracModImpl(const std::vector<T>& a, std::vector<T> b, TM mod) {
  using ResultType = int_promotion_t<T, TM>;
  ResultType ret = 1;
  const int size = static_cast<int>(std::size(b));
  int remain = size;
  for (auto iter : a) {
    for (int i = 0; iter > 1 && remain > 0 && i < size; ++i) {
      if (b[i] == 1) continue;
      while (b[i] != 1 && iter != 1) {
        ResultType d = Gcd(iter, b[i]);
        if (d == 1) {
          break;
        }
        iter /= d;
        b[i] /= d;
      }
      if (b[i] == 1) {
        --remain;
      }
    }
    ret = MulMod(ret, iter % mod, mod);
  }
  return ret;
}
}  // namespace internal

template <typename T1, typename T2 = T1, typename TM>
SL REQUIRES((is_builtin_integer_v<T1> && is_builtin_integer_v<T2> &&
             is_builtin_integer_v<TM>))
    RETURN(int_promotion_t<T1, T2, int64, TM>)
        FracMod(const std::vector<T1>& a, const std::vector<T2>& b, TM mod) {
  using T = int_promotion_t<T1, T2>;
  using AtLeastInt64T = at_least_int64_t<T>;
  return internal::FracModImpl<AtLeastInt64T, TM>(
      std::vector<AtLeastInt64T>(a.begin(), a.end()),
      std::vector<AtLeastInt64T>(b.begin(), b.end()), mod);
}

namespace internal {
struct init_direct_t {};
static const init_direct_t __init_direct{};
}  // namespace internal

struct fake_int128 {};
enum class ModContextType { STATIC, DYNAMIC };

// Mod context provides modulus type and value.
// If ModContextType is STATIC, the modulus is not associated with an instance.
// If ModContextType is DYNAMIC, the modulus is associated with a mod context
// instance. This context can only be used with NModNumberM. NModNumberM is
// not used in most cases.

// 1. If the modulus is a compiling-time integer, use CCMod<T, value>.
// 2. If the modulus is a runtime integer accessed by a single thread or
// multiple threads share the same modulus, use GlobalMod<T>.
// Call GlobalMod<T>::Set(mod_value) to initialize the modulus once.
// 3. If the modulus is a runtime integer accessed by multithreads, use
// TLMod<T>.
// Call TLMod<T>::Set(mod_value) to initialize the modulus in each thread.
// 4. MemMod<T> is a DYNAMIC ModContextType and it is rarely used.

// The modulus is a global variable.
template <typename T>
struct GlobalMod {
  using ModType = int64;
  using BigType = fake_int128;
  static constexpr ModContextType mc_type = ModContextType::STATIC;
  static int64 Mod() { return mod_value; }
  static void Set(int64 v) { mod_value = v; }
  inline static T mod_value = 1;
};

using DefaultMod = GlobalMod<int64>;
using GlobalMod64 = GlobalMod<int64>;

// The modulus is a compiling time constant.
template <typename M, M mod_value = 0>
struct CCMod {
  using ModType = M;
  using BigType = M;
  static constexpr ModContextType mc_type = ModContextType::STATIC;
  static constexpr int64 Mod() { return mod_value; }
};

template <int64 mod_value>
using CCMod64 = CCMod<int64, mod_value>;

// The modulus is a thread local variable.
template <typename T>
struct TLMod {
  using ModType = T;
  using BigType = T;
  static constexpr ModContextType mc_type = ModContextType::STATIC;
  static T Mod() { return mod_value; }
  static void Set(T v) { mod_value = v; }
  inline static thread_local T mod_value = 1;
};

using TLMod64 = TLMod<int64>;

// The modulus is a field of an instance.
template <typename T>
struct MemMod {
  using ModType = T;
  using BigType = T;
  static constexpr ModContextType mc_type = ModContextType::DYNAMIC;
  MemMod(T mod_value = DefaultMod::Mod()) : mod_value(mod_value) {}
  T Mod() const { return mod_value; }
  T mod_value;
};

using MemMod64 = MemMod<int64>;

// Arithmetic policy implementations
template <typename S, typename B>
struct APSB {
  using ints = S;
  using intb = B;
  static ints Add(ints a, ints b, ints mod) {
    intb c = static_cast<intb>(a) + b;
    if (c >= mod) c -= mod;
    return static_cast<ints>(c);
  }
  static ints Sub(ints a, ints b, ints mod) {
    intb c = static_cast<intb>(a) - b;
    if (c < 0) c += mod;
    return static_cast<ints>(c);
  }
  static ints Mul(ints a, ints b, ints mod) {
    intb c = static_cast<intb>(a) * b % mod;
    return static_cast<ints>(c);
  }
  static void FixValue(ints& v, ints mod) {
    // Do nothing
  }
};

template <typename S>
struct APSB<S, S> {
  using ints = S;
  using intb = S;
  static ints Add(ints a, ints b, ints mod) {
    a += b;
    if (a >= mod) a -= mod;
    return a;
  }
  static ints Sub(ints a, ints b, ints mod) {
    a -= b;
    if (a < 0) a += mod;
    return a;
  }
  static ints Mul(ints a, ints b, ints mod) {
    a = a * b % mod;
    return a;
  }
  static void FixValue(ints& v, ints mod) {
    // Do nothing
  }
};

template <typename S>
struct APSB<S, fake_int128> {
  using ints = S;
  using intb = fake_int128;
  static ints Add(ints a, ints b, ints mod) {
    a += b;
    if (a >= mod) a -= mod;
    return a;
  }
  static ints Sub(ints a, ints b, ints mod) {
    a -= b;
    if (a < 0) a += mod;
    return a;
  }
  static ints Mul(ints a, ints b, ints mod) { return MulMod(a, b, mod); }
  static void FixValue(ints& v, ints mod) {
    // Do nothing
  }
};

template <typename S>
struct APSBL {
  using ints = S;
  using intb = fake_int128;
  static ints Add(ints a, ints b, ints /*mod*/) { return a + b; }
  static ints Sub(ints a, ints b, ints /*mod*/) { return a - b; }
  static ints Mul(ints a, ints b, ints /*mod*/) { return a * b; }
  static void FixValue(ints& v, ints mod) { v = Mod(v, mod); }
};

// Forward declarations related to NModNumber;
template <typename MC, typename AP>
struct NModNumber;

// MC = mod context
// AP = arithmetic policy
// Use MC::mod() to get the modulus, i.e. the modulus can be retrieve from a
// static context (not related to an instance of the mod context)
template <typename MC,
          typename AP = APSB<typename MC::ModType, typename MC::BigType>>
struct NModNumber {
  using ints = typename AP::ints;
  static_assert(MC::mc_type == ModContextType::STATIC);

  NModNumber(ints value = 0) {
    const ints M = MC::Mod();
    if (value >= 0) {
      value_ = value >= M ? value % M : value;
    } else {
      value_ = value <= -M ? value % M + M : value + M;
    }
  }

  template <typename T,
            typename TT = REQUIRES((is_builtin_integer_v<T>)) RETURN(T)>
  NModNumber(T value) : NModNumber(static_cast<ints>(value % MC::Mod())) {}

  NModNumber(ints value, internal::init_direct_t) : value_(value) {}

  static NModNumber OfValue(const ints value) { return NModNumber(value); }

  static constexpr ints Mod() { return MC::Mod(); }

  NModNumber& operator+=(const NModNumber& y) {
    value_ = AP::Add(value_, y.value_, Mod());
    return *this;
  }

  NModNumber& operator++() {
    value_ = AP::Add(value_, 1, Mod());
    return *this;
  }

  NModNumber operator++(int) {
    NModNumber t(value_, internal::__init_direct);
    ++*this;
    return t;
  }

  NModNumber& operator-=(const NModNumber& y) {
    value_ = AP::Sub(value_, y.value_, Mod());
    return *this;
  }

  NModNumber& operator--() {
    value_ = AP::Sub(value_, 1, Mod());
    return *this;
  }

  NModNumber operator--(int) {
    NModNumber t(value_, internal::__init_direct);
    --*this;
    return t;
  }

  NModNumber operator+() const {
    return NModNumber(value_, internal::__init_direct);
  }

  NModNumber operator-() const {
    return NModNumber(AP::Sub(0, value_, Mod()), internal::__init_direct);
  }

  NModNumber& operator*=(const NModNumber& y) {
    value_ = AP::Mul(value_, y.value_, Mod());
    return *this;
  }

  template <typename T>
  REQUIRES((is_builtin_integer_v<T>))
  RETURN(NModNumber) Power(T n) const {
    NModNumber ret(1);
    NModNumber x(*this);
    for (; n; n >>= 1) {
      if (n & 1) {
        ret = ret * x;
      }
      x = x * x;
    }
    return ret;
  }

  ints value() const { return value_; }

  const NModNumber& FixValue() const {
    AP::FixValue(value_, Mod());
    return *this;
  }

  NModNumber& FixValue() {
    AP::FixValue(value_, Mod());
    return *this;
  }

  void SetValue(const ints value) { value_ = value; }

 public:
  friend NModNumber operator+(const NModNumber& x, const NModNumber& y) {
    return NModNumber(AP::Add(x.value_, y.value_, MC::Mod()),
                      internal::__init_direct);
  }

  template <typename T>
  friend REQUIRES((is_builtin_integer_v<T>))
      RETURN(NModNumber) operator+(const NModNumber & x, T y) {
    return x + NModNumber(y);
  }

  template <typename T>
  friend REQUIRES((is_builtin_integer_v<T>))
      RETURN(NModNumber) operator+(T x, const NModNumber & y) {
    return NModNumber(x) + y;
  }

  friend NModNumber operator-(const NModNumber& x, const NModNumber& y) {
    return NModNumber(AP::Sub(x.value_, y.value_, Mod()),
                      internal::__init_direct);
  }

  friend NModNumber operator*(const NModNumber& x, const NModNumber& y) {
    return NModNumber(AP::Mul(x.value_, y.value_, Mod()),
                      internal::__init_direct);
  }

  friend std::ostream& operator<<(std::ostream& o, const NModNumber& m) {
    return o << m.value_;
  }

 private:
  mutable ints value_;
};

template <typename MC, typename AP>
int operator==(const NModNumber<MC, AP>& x, const NModNumber<MC, AP>& y) {
  return x.FixValue().value() == y.FixValue().value();
}

template <typename MC, typename AP>
int operator!=(const NModNumber<MC, AP>& x, const NModNumber<MC, AP>& y) {
  return x.FixValue().value() != y.FixValue().value();
}

template <typename MC, typename AP>
int operator<(const NModNumber<MC, AP>& x, const NModNumber<MC, AP>& y) {
  return x.FixValue().value() < y.FixValue().value();
}

template <typename MC, typename AP>
int operator<=(const NModNumber<MC, AP>& x, const NModNumber<MC, AP>& y) {
  return x.FixValue().value() <= y.FixValue().value();
}

template <typename MC, typename AP>
int operator>(const NModNumber<MC, AP>& x, const NModNumber<MC, AP>& y) {
  return x.FixValue().value() > y.FixValue().value();
}

template <typename MC, typename AP>
int operator>=(const NModNumber<MC, AP>& x, const NModNumber<MC, AP>& y) {
  return x.FixValue().value() >= y.FixValue().value();
}

template <typename M, M mod_value, typename AP = APSB<M, M>>
using NMod = NModNumber<CCMod<M, mod_value>, AP>;

template <int64 mod_value, typename AP = APSB<int64, fake_int128>>
using NMod64 = NModNumber<CCMod<int64, mod_value>, AP>;

template <int64 mod_value, typename AP = APSB<int64, int64>>
using NMod64Lite = NModNumber<CCMod<int64, mod_value>, AP>;

template <typename M = int64, typename AP = APSB<M, M>>
using TLNMod = NModNumber<TLMod<M>, AP>;

template <typename AP = APSB<int64, fake_int128>>
using TLNMod64 = NModNumber<TLMod<int64>, AP>;

template <typename AP = APSB<int64, int64>>
using TLNMod64Lite = NModNumber<TLMod<int64>, AP>;

// Forward declarations related to NModNumberM;
template <typename MC, typename AP>
struct NModNumberM;

// MC = mod context
// AP = arithmetic policy
// Use mc.mod() to get the modulus. i.e. the modulus is associated with
// an instance of mod context.
template <typename MC,
          typename AP = APSB<typename MC::ModType, typename MC::BigType>>
struct NModNumberM {
  using ints = typename AP::ints;
  static_assert(MC::mc_type == ModContextType::STATIC ||
                MC::mc_type == ModContextType::DYNAMIC);

  NModNumberM(ints value = 0, const MC& mc = MC()) : mc(mc) {
    const ints M = Mod();
    if (value >= 0) {
      value_ = value >= M ? value % M : value;
    } else {
      value_ = value <= -M ? value % M + M : value + M;
    }
  }

  template <typename T,
            typename TT = REQUIRES((is_builtin_integer_v<T>)) RETURN(T)>
  NModNumberM(T value, const MC& mc = MC())
      : NModNumberM(static_cast<ints>(value % mc.Mod()), mc) {}

  NModNumberM(ints value, const MC& mc, internal::init_direct_t)
      : value_(value), mc(mc) {}

  NModNumberM OfValue(const ints value) const { return NModNumberM(value, mc); }

  ints Mod() const { return mc.Mod(); }

  NModNumberM& operator+=(const NModNumberM& y) {
    value_ = AP::Add(value_, y.value_, Mod());
    return *this;
  }

  NModNumberM& operator++() {
    value_ = AP::Add(value_, 1, Mod());
    return *this;
  }

  NModNumberM operator++(int) {
    NModNumberM t(value_, mc, internal::__init_direct);
    ++*this;
    return t;
  }

  NModNumberM& operator-=(const NModNumberM& y) {
    value_ = AP::Sub(value_, y.value_, Mod());
    return *this;
  }

  NModNumberM& operator--() {
    value_ = AP::Sub(value_, 1, Mod());
    return *this;
  }

  NModNumberM operator--(int) {
    NModNumberM t(value_, internal::__init_direct);
    --*this;
    return t;
  }

  NModNumberM operator+() const {
    return NModNumberM(value_, mc, internal::__init_direct);
  }

  NModNumberM operator-() const {
    return NModNumberM(AP::Sub(0, value_, Mod()), mc, internal::__init_direct);
  }

  NModNumberM& operator*=(const NModNumberM& y) {
    value_ = AP::Mul(value_, y.value_, Mod());
    return *this;
  }

  template <typename T>
  REQUIRES((is_builtin_integer_v<T>))
  RETURN(NModNumberM) Power(T n) const {
    NModNumberM ret(1, mc);
    NModNumberM x(*this);
    for (; n; n >>= 1) {
      if (n & 1) {
        ret = ret * x;
      }
      x = x * x;
    }
    return ret;
  }

  ints value() const { return value_; }

  const NModNumberM& FixValue() const {
    AP::FixValue(value_, Mod());
    return *this;
  }

  NModNumberM& FixValue() {
    AP::FixValue(value_, Mod());
    return *this;
  }

  void SetValue(const ints value) { value_ = value; }

 public:
  friend NModNumberM operator+(const NModNumberM& x, const NModNumberM& y) {
    return NModNumberM(AP::Add(x.value_, y.value_, x.Mod()), x.mc,
                       internal::__init_direct);
  }

  template <typename T>
  friend REQUIRES((is_builtin_integer_v<T>))
      RETURN(NModNumberM) operator+(const NModNumberM & x, T y) {
    return x + NModNumberM(y, x.mc);
  }

  template <typename T>
  friend REQUIRES((is_builtin_integer_v<T>))
      RETURN(NModNumberM) operator+(T x, const NModNumberM & y) {
    return NModNumberM(x, y.mc) + y;
  }

  friend NModNumberM operator-(const NModNumberM& x, const NModNumberM& y) {
    return NModNumberM(AP::Sub(x.value_, y.value_, x.Mod()), x.mc,
                       internal::__init_direct);
  }

  template <typename T>
  friend REQUIRES((is_builtin_integer_v<T>))
      RETURN(NModNumberM) operator-(const NModNumberM & x, T y) {
    return x - NModNumberM(y, x.mc);
  }

  template <typename T>
  friend REQUIRES((is_builtin_integer_v<T>))
      RETURN(NModNumberM) operator-(T x, const NModNumberM & y) {
    return NModNumberM(x, y.mc) - y;
  }

  friend NModNumberM operator*(const NModNumberM& x, const NModNumberM& y) {
    return NModNumberM(AP::Mul(x.value_, y.value_, x.Mod()), x.mc,
                       internal::__init_direct);
  }

  template <typename T>
  friend REQUIRES((is_builtin_integer_v<T>))
      RETURN(NModNumberM) operator*(const NModNumberM & x, T y) {
    return x * NModNumberM(y, x.mc);
  }

  template <typename T>
  friend REQUIRES((is_builtin_integer_v<T>))
      RETURN(NModNumberM) operator*(T x, const NModNumberM & y) {
    return NModNumberM(x, y.mc) * y;
  }

  friend std::ostream& operator<<(std::ostream& o, const NModNumberM& m) {
    return o << m.value_;
  }

 private:
  mutable ints value_;
  MC mc;
};

template <typename MC, typename AP>
int operator==(const NModNumberM<MC, AP>& x, const NModNumberM<MC, AP>& y) {
  return x.FixValue().value() == y.FixValue().value();
}

template <typename MC, typename AP>
int operator!=(const NModNumberM<MC, AP>& x, const NModNumberM<MC, AP>& y) {
  return x.FixValue().value() != y.FixValue().value();
}

template <typename MC, typename AP>
int operator<(const NModNumberM<MC, AP>& x, const NModNumberM<MC, AP>& y) {
  return x.FixValue().value() < y.FixValue().value();
}

template <typename MC, typename AP>
int operator<=(const NModNumberM<MC, AP>& x, const NModNumberM<MC, AP>& y) {
  return x.FixValue().value() <= y.FixValue().value();
}

template <typename MC, typename AP>
int operator>(const NModNumberM<MC, AP>& x, const NModNumberM<MC, AP>& y) {
  return x.FixValue().value() > y.FixValue().value();
}

template <typename MC, typename AP>
int operator>=(const NModNumberM<MC, AP>& x, const NModNumberM<MC, AP>& y) {
  return x.FixValue().value() >= y.FixValue().value();
}

template <typename M, M mod_value, typename AP = APSB<M, M>>
using NModM = NModNumberM<CCMod<M, mod_value>, AP>;

template <int64 M, typename AP = APSB<int64, fake_int128>>
using NModM64 = NModNumberM<CCMod<int64, M>, AP>;

template <int64 M, typename AP = APSB<int64, int64>>
using NModM64Lite = NModNumberM<CCMod<int64, M>, AP>;

template <typename M = int64, typename AP = APSB<M, M>>
using TLNModM = NModNumber<TLMod<M>, AP>;

template <typename AP = APSB<int64, fake_int128>>
using TLNModM64 = NModNumber<TLMod<int64>, AP>;

template <typename AP = APSB<int64, int64>>
using TLNModM64Lite = NModNumber<TLMod<int64>, AP>;

template <typename X>
struct IsNModNumber {
  static constexpr std::false_type NModNumberMatch(...);

  template <typename MC, typename AP>
  static constexpr std::true_type NModNumberMatch(NModNumber<MC, AP>);

  template <typename MC, typename AP>
  static constexpr std::true_type NModNumberMatch(NModNumberM<MC, AP>);

  using result_type = decltype(NModNumberMatch(std::declval<X>()));

  static constexpr bool value = result_type::value;
};

template <typename T>
inline constexpr bool IsNModNumberV = IsNModNumber<T>::value;

template <typename X>
struct IsNModNumberCCModOrGlobalMod {
  static constexpr std::false_type NModNumberCCmodOrGlobalModMatch(...);

  template <typename T, T V, typename AP>
  static constexpr std::true_type NModNumberCCmodOrGlobalModMatch(
      NModNumber<CCMod<T, V>, AP>);

  template <typename T, T V, typename AP>
  static constexpr std::true_type NModNumberCCmodOrGlobalModMatch(
      NModNumberM<CCMod<T, V>, AP>);

  template <typename AP>
  static constexpr std::true_type NModNumberCCmodOrGlobalModMatch(
      NModNumber<DefaultMod, AP>);

  template <typename AP>
  static constexpr std::true_type NModNumberCCmodOrGlobalModMatch(
      NModNumberM<DefaultMod, AP>);

  using result_type =
      decltype(NModNumberCCmodOrGlobalModMatch(std::declval<X>()));

  static constexpr bool value = result_type::value;
};

template <typename T>
inline constexpr bool IsNModNumberCCModOrGlobalModV =
    IsNModNumberCCModOrGlobalMod<T>::value;

template <typename T>
SL REQUIRES((IsNModNumberV<T>)) RETURN(typename T::ints)
    ExtractValue(const T& t) {
  return t.FixValue().value();
}

template <typename T>
SL REQUIRES((!IsNModNumberV<T>)) RETURN(T) ExtractValue(const T& t) {
  return t;
}

template <typename T>
struct ModValueFixer {
  static void Fix(T& v) {}
};

template <typename MC, typename S>
struct ModValueFixer<NModNumber<MC, APSBL<S>>> {
  static void Fix(NModNumber<MC, APSBL<S>>& v) { v.FixValue(); }
};

template <typename MC, typename S>
struct ModValueFixer<NModNumberM<MC, APSBL<S>>> {
  static void Fix(NModNumberM<MC, APSBL<S>>& v) { v.FixValue(); }
};

template <typename T, typename TN>
SL REQUIRES((IsNModNumberV<T> && is_builtin_integer_v<TN>)) RETURN(T)
    Power(T x, TN n) {
  return x.Power(n);
}

template <typename T, typename TN>
SL REQUIRES((IsNModNumberV<T> && is_builtin_integer_v<TN>)) RETURN(T)
    PowerMod(T x, TN n) {
  return x.Power(n);
}

template <typename T, typename TN, typename TM>
SL REQUIRES((IsNModNumberV<T> && is_builtin_integer_v<TN> &&
             is_builtin_integer_v<TM>)) RETURN(T) PowerMod(T x, TN n, TM mod) {
  PE_ASSERT(mod == x.Mod());
  return x.Power(n);
}

// Returns maximum x such that x <= maxv and x = v (mod m)
template <typename T>
SL REQUIRES((is_general_integer_v<T>)) RETURN(T) ModNoMore(T maxv, T v, T m) {
  if (maxv >= v) {
    return v + (maxv - v) / m * m;
  } else {
    return v - (v - maxv + m - 1) / m * m;
  }
}

template <typename T, typename TM>
SL REQUIRES((is_general_integer_v<T> && IsNModNumberV<TM>)) RETURN(T)
    ModNoMore(T maxv, TM v) {
  return ModNoMore<T>(maxv, ExtractValue(v), v.Mod());
}

// Returns minimum x such that x >= minv and x = v (mod m)
template <typename T>
SL REQUIRES((is_general_integer_v<T>)) RETURN(T) ModAtLeast(T minv, T v, T m) {
  if (minv >= v) {
    return v + (minv - v + m - 1) / m * m;
  } else {
    return v - (v - minv) / m * m;
  }
}

template <typename T, typename TM>
SL REQUIRES((is_general_integer_v<T> && IsNModNumberV<TM>)) RETURN(T)
    ModAtLeast(T minv, TM v) {
  return ModAtLeast<T>(minv, ExtractValue(v), v.Mod());
}

#if PE_HAS_CPP20
#define PE_MOD_ARTHMETIC_OPERATION_IMPL(type) \
  v + static_cast<type>(1);                   \
  v - static_cast<type>(1);                   \
  v* static_cast<type>(1);                    \
  static_cast<type>(1) + v;                   \
  static_cast<type>(1) - v;                   \
  static_cast<type>(1) * v

#define PE_MOD_SELF_ARTHMETIC_OPERATION_IMPL(type) \
  v += static_cast<type>(1);                       \
  v -= static_cast<type>(1);                       \
  v *= static_cast<type>(1)

template <class T>
concept PeModNumber = requires(T v) {
  requires static_cast<bool>(IsNModNumberV<T>);
  PE_MOD_ARTHMETIC_OPERATION_IMPL(char);
  PE_MOD_ARTHMETIC_OPERATION_IMPL(unsigned char);
  PE_MOD_ARTHMETIC_OPERATION_IMPL(signed char);
  PE_MOD_ARTHMETIC_OPERATION_IMPL(int);
  PE_MOD_ARTHMETIC_OPERATION_IMPL(unsigned int);
  PE_MOD_ARTHMETIC_OPERATION_IMPL(signed int);
  PE_MOD_ARTHMETIC_OPERATION_IMPL(short int);
  PE_MOD_ARTHMETIC_OPERATION_IMPL(unsigned short int);
  PE_MOD_ARTHMETIC_OPERATION_IMPL(long int);
  PE_MOD_ARTHMETIC_OPERATION_IMPL(signed long int);
  PE_MOD_ARTHMETIC_OPERATION_IMPL(unsigned long int);
  PE_MOD_ARTHMETIC_OPERATION_IMPL(long long int);
  PE_MOD_ARTHMETIC_OPERATION_IMPL(signed long long int);
  PE_MOD_ARTHMETIC_OPERATION_IMPL(unsigned long long int);
#if PE_HAS_INT128
  PE_MOD_ARTHMETIC_OPERATION_IMPL(int128);
  PE_MOD_ARTHMETIC_OPERATION_IMPL(uint128);
#endif
  v + v;
  v - v;
  v * v;
  PE_MOD_SELF_ARTHMETIC_OPERATION_IMPL(char);
  PE_MOD_SELF_ARTHMETIC_OPERATION_IMPL(unsigned char);
  PE_MOD_SELF_ARTHMETIC_OPERATION_IMPL(signed char);
  PE_MOD_SELF_ARTHMETIC_OPERATION_IMPL(int);
  PE_MOD_SELF_ARTHMETIC_OPERATION_IMPL(unsigned int);
  PE_MOD_SELF_ARTHMETIC_OPERATION_IMPL(signed int);
  PE_MOD_SELF_ARTHMETIC_OPERATION_IMPL(short int);
  PE_MOD_SELF_ARTHMETIC_OPERATION_IMPL(unsigned short int);
  PE_MOD_SELF_ARTHMETIC_OPERATION_IMPL(long int);
  PE_MOD_SELF_ARTHMETIC_OPERATION_IMPL(signed long int);
  PE_MOD_SELF_ARTHMETIC_OPERATION_IMPL(unsigned long int);
  PE_MOD_SELF_ARTHMETIC_OPERATION_IMPL(long long int);
  PE_MOD_SELF_ARTHMETIC_OPERATION_IMPL(signed long long int);
  PE_MOD_SELF_ARTHMETIC_OPERATION_IMPL(unsigned long long int);
#if PE_HAS_INT128
  PE_MOD_SELF_ARTHMETIC_OPERATION_IMPL(int128);
  PE_MOD_SELF_ARTHMETIC_OPERATION_IMPL(uint128);
#endif
  v += v;
  v -= v;
  v *= v;
  ++v;
  --v;
  v++;
  v--;
};
#undef PE_MOD_ARTHMETIC_OPERATION_IMPL
#undef PE_MOD_SELF_ARTHMETIC_OPERATION_IMPL

static_assert(PeModNumber<NMod64<1000000007>>);
static_assert(PeModNumber<TLNMod64<>>);
static_assert(PeModNumber<NModM64<1000000007>>);
static_assert(PeModNumber<TLNModM64<>>);
#endif
}  // namespace pe
#endif
