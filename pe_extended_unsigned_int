#ifndef PE_EXTENDED_UNSIGNED_INT_
#define PE_EXTENDED_UNSIGNED_INT_

#include "pe_base"
#include "pe_int128"
#include "pe_type_traits"
#include "pe_int"
#include "pe_bit"
#include "pe_uint_pair"

namespace pe {
// Extended integers

// Extended unsigned integer.
template <typename ET, bool is_native>
struct ExtendedUnsignedIntImpl;

template <typename ET>
struct ExtendedUnsignedIntImpl<ET, true> : public UIntPairImpl<ET, true> {
  // The corresponding native integer type.
  using NT = ET;
  using base = UIntPairImpl<ET, true>;

 public:
  ExtendedUnsignedIntImpl(ET low = 0) : base(low) {}
  ExtendedUnsignedIntImpl(ET low, ET hi) : base(low, hi) {}

  template <typename T,
            typename TT = REQUIRES((is_native_integer<T>::value)) RETURN(T)>
  ExtendedUnsignedIntImpl(T v) : base(v) {}

  ExtendedUnsignedIntImpl(const std::string& str) {
    const int n = static_cast<int>(str.size());
    if (n == 0) return;
    int idx = 0;
    int neg = 0;
    if (str[idx] == '-') {
      ++idx;
      neg = 1;
    } else if (str[idx] == '+') {
      ++idx;
    }
    while (idx < n && std::isdigit(str[idx])) {
      *this = *this * 10 + (str[idx] - '0');
      ++idx;
    }
    if (neg) {
      base::FlipBits();
      base::AddOne();
    }
  }

  ExtendedUnsignedIntImpl(const ExtendedUnsignedIntImpl& other) : base(other) {}

  ExtendedUnsignedIntImpl& operator=(const ExtendedUnsignedIntImpl& other) {
    base::low_ = other.low_;
    base::hi_ = other.hi_;
    return *this;
  }

  ExtendedUnsignedIntImpl& operator=(const ExtendedUnsignedIntImpl&& other) {
    base::low_ = std::move(other.low_);
    base::hi_ = std::move(other.hi_);
    return *this;
  }

  ExtendedUnsignedIntImpl& operator=(const ET& other) {
    base::low_ = other;
    base::hi_ = 0;
    return *this;
  }

  template <typename T,
            typename TT = REQUIRES((is_native_integer<T>::value)) RETURN(T)>
  ExtendedUnsignedIntImpl& operator=(const T& other) {
    base::MakeZeroBits();
    base::template FromNativeInt<T>(other);
    return *this;
  }

 public:
  ExtendedUnsignedIntImpl& DivImpl(const ExtendedUnsignedIntImpl& other) {
    base::UIntDividedBy(other);
    return *this;
  }

  ExtendedUnsignedIntImpl& DivImpl(const ExtendedUnsignedIntImpl& other,
                                   ExtendedUnsignedIntImpl& r) {
    base::UIntDividedBy(other);
    return *this;
  }

  ExtendedUnsignedIntImpl& ModImpl(const ExtendedUnsignedIntImpl& other) {
    base::UIntModulo(other);
    return *this;
  }

 public:
  using base::hi;
  using base::low;
  using base::sign;

  int CompareTo(const ExtendedUnsignedIntImpl& other) const {
    return base::UIntCompareTo(other);
  }

  using base::IntSign;
  using base::IsEven;
  using base::IsOdd;
  using base::IsZero;
  using base::LowerBits;

  ExtendedUnsignedIntImpl Abs() const { return *this; }

  ExtendedUnsignedIntImpl FAbs() const { return *this; }

  using base::BitCount;
  using base::GetBit;
  using base::ResetBit;
  using base::RevBit;
  using base::SetBit;
  using base::to_string;
  using base::ToFloat;
  using base::ToInt;
  using base::ToString;

  ExtendedUnsignedIntImpl Difference(
      const ExtendedUnsignedIntImpl& other) const {
    auto t = base::Difference(other);
    return ExtendedUnsignedIntImpl(t.low(), t.hi());
  }

 public:
  // Operators
  ExtendedUnsignedIntImpl operator+() const { return *this; }

  ExtendedUnsignedIntImpl operator-() const {
    ExtendedUnsignedIntImpl ret(*this);
    base::FlipBits();
    base::AddOne();
    return ret;
  }

  ExtendedUnsignedIntImpl operator~() const {
    return ExtendedUnsignedIntImpl(~base::low_, ~base::hi_);
  }

  ExtendedUnsignedIntImpl& operator+=(const ExtendedUnsignedIntImpl& other) {
    base::UIntAddedBy(other);
    return *this;
  }

  ExtendedUnsignedIntImpl& operator+=(const ET& other) {
    base::UIntAddedBy(other);
    return *this;
  }

  ExtendedUnsignedIntImpl& operator-=(const ExtendedUnsignedIntImpl& other) {
    base::UIntSubstract(other);
    return *this;
  }

  ExtendedUnsignedIntImpl& operator-=(const ET& other) {
    base::UIntSubstract(other);
    return *this;
  }

  ExtendedUnsignedIntImpl& operator*=(const ExtendedUnsignedIntImpl& other) {
    base::UIntMultiplyBy(other);
    return *this;
  }

  ExtendedUnsignedIntImpl& operator*=(const ET& other) {
    base::UIntMultiplyBy(other);
    return *this;
  }

  ExtendedUnsignedIntImpl& operator/=(const ExtendedUnsignedIntImpl& other) {
    return DivImpl(other);
  }

  ExtendedUnsignedIntImpl& operator/=(const ET& other) {
    return *this /= ExtendedUnsignedIntImpl(other);
  }

  ExtendedUnsignedIntImpl& operator%=(const ExtendedUnsignedIntImpl& other) {
    return ModImpl(other);
  }

  ExtendedUnsignedIntImpl& operator%=(const ET& other) {
    return *this %= ExtendedUnsignedIntImpl(other);
  }

  ExtendedUnsignedIntImpl& operator&=(const ExtendedUnsignedIntImpl& other) {
    base::low_ &= other.low();
    base::hi_ &= other.hi();
    return *this;
  }

  ExtendedUnsignedIntImpl& operator&=(const ET& other) {
    base::low_ &= other;
    base::hi_ = 0;
    return *this;
  }

  ExtendedUnsignedIntImpl& operator^=(const ExtendedUnsignedIntImpl& other) {
    base::low_ ^= other.low();
    base::hi_ ^= other.hi();
    return *this;
  }

  ExtendedUnsignedIntImpl& operator^=(const ET& other) {
    base::low_ ^= other;
    return *this;
  }

  ExtendedUnsignedIntImpl& operator|=(const ExtendedUnsignedIntImpl& other) {
    base::low_ |= other.low();
    base::hi_ |= other.hi();
    return *this;
  }

  ExtendedUnsignedIntImpl& operator|=(const ET& other) {
    base::low_ |= other;
    return *this;
  }

  ExtendedUnsignedIntImpl& operator>>=(int cnt) {
    base::ShiftRight(cnt);
    return *this;
  }

  ExtendedUnsignedIntImpl& operator<<=(int cnt) {
    base::ShiftLeft(cnt);
    return *this;
  }

  ExtendedUnsignedIntImpl& operator++() {
    base::AddOne();
    return *this;
  }

  ExtendedUnsignedIntImpl operator++(int) {
    ExtendedUnsignedIntImpl ret(*this);
    *this += 1;
    return ret;
  }

  ExtendedUnsignedIntImpl& operator--() {
    if (base::low_) {
      --base::low_;
    } else {
      --base::low_;
      --base::hi_;
    }
    return *this;
  }

  ExtendedUnsignedIntImpl operator--(int) {
    ExtendedUnsignedIntImpl ret(*this);
    *this -= 1;
    return ret;
  }

 public:
  // All the binary operators are friend operators
  // Comparison operators
#if PE_HAS_CPP20
  friend inline int operator<=>(const ExtendedUnsignedIntImpl& l,
                                const ExtendedUnsignedIntImpl& r) {
    return l.CompareTo(r);
  }
  friend inline int operator==(const ExtendedUnsignedIntImpl& l,
                               const ExtendedUnsignedIntImpl& r) {
    return l.CompareTo(r) == 0;
  }
  friend inline int operator!=(const ExtendedUnsignedIntImpl& l,
                               const ExtendedUnsignedIntImpl& r) {
    return l.CompareTo(r) != 0;
  }
#else
  friend inline int operator<(const ExtendedUnsignedIntImpl& l,
                              const ExtendedUnsignedIntImpl& r) {
    return l.CompareTo(r) < 0;
  }
  friend inline int operator<=(const ExtendedUnsignedIntImpl& l,
                               const ExtendedUnsignedIntImpl& r) {
    return l.CompareTo(r) <= 0;
  }
  friend inline int operator>(const ExtendedUnsignedIntImpl& l,
                              const ExtendedUnsignedIntImpl& r) {
    return l.CompareTo(r) > 0;
  }
  friend inline int operator>=(const ExtendedUnsignedIntImpl& l,
                               const ExtendedUnsignedIntImpl& r) {
    return l.CompareTo(r) >= 0;
  }
  friend inline int operator==(const ExtendedUnsignedIntImpl& l,
                               const ExtendedUnsignedIntImpl& r) {
    return l.CompareTo(r) == 0;
  }
  friend inline int operator!=(const ExtendedUnsignedIntImpl& l,
                               const ExtendedUnsignedIntImpl& r) {
    return l.CompareTo(r) != 0;
  }
#endif
  friend inline ExtendedUnsignedIntImpl operator+(
      const ExtendedUnsignedIntImpl& l, const ExtendedUnsignedIntImpl& r) {
    ExtendedUnsignedIntImpl ret(l);
    ret += r;
    return ret;
  }
  friend inline ExtendedUnsignedIntImpl operator-(
      const ExtendedUnsignedIntImpl& l, const ExtendedUnsignedIntImpl& r) {
    ExtendedUnsignedIntImpl ret(l);
    ret -= r;
    return ret;
  }
  friend inline ExtendedUnsignedIntImpl operator*(
      const ExtendedUnsignedIntImpl& l, const ExtendedUnsignedIntImpl& r) {
    ExtendedUnsignedIntImpl ret(l);
    ret *= r;
    return ret;
  }
  friend inline ExtendedUnsignedIntImpl operator/(
      const ExtendedUnsignedIntImpl& l, const ExtendedUnsignedIntImpl& r) {
    ExtendedUnsignedIntImpl ret(l);
    ret /= r;
    return ret;
  }
  friend inline ExtendedUnsignedIntImpl operator%(
      const ExtendedUnsignedIntImpl& l, const ExtendedUnsignedIntImpl& r) {
    ExtendedUnsignedIntImpl ret(l);
    ret %= r;
    return ret;
  }
  friend inline ExtendedUnsignedIntImpl operator&(
      const ExtendedUnsignedIntImpl& l, const ExtendedUnsignedIntImpl& r) {
    ExtendedUnsignedIntImpl ret(l);
    ret &= r;
    return ret;
  }
  friend inline ExtendedUnsignedIntImpl operator^(
      const ExtendedUnsignedIntImpl& l, const ExtendedUnsignedIntImpl& r) {
    ExtendedUnsignedIntImpl ret(l);
    ret ^= r;
    return ret;
  }
  friend inline ExtendedUnsignedIntImpl operator|(
      const ExtendedUnsignedIntImpl& l, const ExtendedUnsignedIntImpl& r) {
    ExtendedUnsignedIntImpl ret(l);
    ret |= r;
    return ret;
  }
  friend inline ExtendedUnsignedIntImpl operator<<(
      const ExtendedUnsignedIntImpl& l, const int cnt) {
    ExtendedUnsignedIntImpl ret(l);
    ret <<= cnt;
    return ret;
  }
  friend inline ExtendedUnsignedIntImpl operator>>(
      const ExtendedUnsignedIntImpl& l, const int cnt) {
    ExtendedUnsignedIntImpl ret(l);
    ret >>= cnt;
    return ret;
  }
  friend inline std::ostream& operator<<(std::ostream& o,
                                         const ExtendedUnsignedIntImpl& n) {
    return o << n.ToString();
  }
};

template <typename ET>
struct ExtendedUnsignedIntImpl<ET, false> : public UIntPairImpl<ET, false> {
  using NT = typename ET::NT;
  using base = UIntPairImpl<ET, false>;

 public:
  ExtendedUnsignedIntImpl(ET low = 0) : base(low) {}
  ExtendedUnsignedIntImpl(ET low, ET hi) : base(low, hi) {}

  template <typename T,
            typename TT = REQUIRES((is_native_integer<T>::value)) RETURN(T)>
  ExtendedUnsignedIntImpl(T v) : base(v) {}

  ExtendedUnsignedIntImpl(const std::string& str) : base(str) {
    const int n = static_cast<int>(str.size());
    if (n == 0) return;
    int idx = 0;
    int neg = 0;
    if (str[idx] == '-') {
      ++idx;
      neg = 1;
    } else if (str[idx] == '+') {
      ++idx;
    }
    while (idx < n && std::isdigit(str[idx])) {
      *this = *this * 10 + (str[idx] - '0');
      ++idx;
    }
    if (neg) {
      base::FlipBits();
      base::AddOne();
    }
  }

  ExtendedUnsignedIntImpl(const ExtendedUnsignedIntImpl& other) : base(other) {}

  ExtendedUnsignedIntImpl& operator=(const ExtendedUnsignedIntImpl& other) {
    base::low_ = other.low_;
    base::hi_ = other.hi_;
    return *this;
  }

  ExtendedUnsignedIntImpl& operator=(const ExtendedUnsignedIntImpl&& other) {
    base::low_ = std::move(other.low_);
    base::hi_ = std::move(other.hi_);
    return *this;
  }

  ExtendedUnsignedIntImpl& operator=(const ET& other) {
    base::low_ = other;
    base::hi_.MakeZeroBits();
    return *this;
  }

  template <typename T,
            typename TT = REQUIRES((is_native_integer<T>::value)) RETURN(T)>
  ExtendedUnsignedIntImpl& operator=(const T& other) {
    base::MakeZeroBits();
    base::template FromNativeInt<T>(other);
    return *this;
  }

 public:
  ExtendedUnsignedIntImpl& DivImpl(const ExtendedUnsignedIntImpl& other) {
    base::UIntDividedBy(other);
    return *this;
  }

  ExtendedUnsignedIntImpl& DivImpl(const ExtendedUnsignedIntImpl& other,
                                   ExtendedUnsignedIntImpl& r) {
    base::UIntDividedBy(other);
    return *this;
  }

  ExtendedUnsignedIntImpl& ModImpl(const ExtendedUnsignedIntImpl& other) {
    base::UIntModulo(other);
    return *this;
  }

 public:
  using base::hi;
  using base::low;

  int sign() const {
    return base::low_.IntSign() || base::hi_.IntSign() ? 1 : 0;
  }

  int CompareTo(const ExtendedUnsignedIntImpl& other) const {
    int t = base::hi_.UIntCompareTo(other.hi_);
    if (t != 0) {
      return t;
    }
    return base::low_.UIntCompareTo(other.low_);
  }

  int IntSign() const {
    return base::low_.IntSign() || base::hi_.IntSign() ? 1 : 0;
  }

  using base::IsEven;
  using base::IsOdd;
  using base::IsZero;
  using base::LowerBits;

  ExtendedUnsignedIntImpl Abs() const { return *this; }

  ExtendedUnsignedIntImpl FAbs() const { return *this; }

  using base::ToFloat;
  using base::ToInt;

  using base::BitCount;
  using base::GetBit;
  using base::ResetBit;
  using base::RevBit;
  using base::SetBit;

  using base::to_string;
  using base::ToString;

  ExtendedUnsignedIntImpl Difference(
      const ExtendedUnsignedIntImpl& other) const {
    auto t = base::Difference(other);
    return ExtendedUnsignedIntImpl(t.low(), t.hi());
  }

 public:
  // Operators
  const ExtendedUnsignedIntImpl& operator+() const { return *this; }

  const ExtendedUnsignedIntImpl& operator-() const {
    ExtendedUnsignedIntImpl ret(*this);
    base::FlipBits();
    base::AddOne();
    return ret;
  }

  ExtendedUnsignedIntImpl operator~() const {
    return ExtendedUnsignedIntImpl(~base::low_, ~base::hi_);
  }

  ExtendedUnsignedIntImpl& operator+=(const ExtendedUnsignedIntImpl& other) {
    base::UIntAddedBy(other);
    return *this;
  }

  ExtendedUnsignedIntImpl& operator+=(const ET& other) {
    return *this += ExtendedUnsignedIntImpl(other);
  }

  template <typename T>
  REQUIRES((is_native_integer<T>::value))
  RETURN(ExtendedUnsignedIntImpl&) operator+=(const T& other) {
    return *this += ExtendedUnsignedIntImpl(other);
  }

  ExtendedUnsignedIntImpl& operator-=(const ExtendedUnsignedIntImpl& other) {
    base::UIntSubstract(other);
    return *this;
  }

  ExtendedUnsignedIntImpl& operator-=(const ET& other) {
    return *this -= ExtendedUnsignedIntImpl(other);
  }

  template <typename T>
  REQUIRES((is_native_integer<T>::value))
  RETURN(ExtendedUnsignedIntImpl&) operator-=(const T& other) {
    return *this -= ExtendedUnsignedIntImpl(other);
  }

  ExtendedUnsignedIntImpl& operator*=(const ExtendedUnsignedIntImpl& other) {
    base::UIntMultiplyBy(other);
    return *this;
  }

  ExtendedUnsignedIntImpl& operator*=(const ET& other) {
    return *this *= ExtendedUnsignedIntImpl(other);
  }

  template <typename T>
  REQUIRES((is_native_integer<T>::value))
  RETURN(ExtendedUnsignedIntImpl&) operator*=(const T& other) {
    return *this *= ExtendedUnsignedIntImpl(other);
  }

  ExtendedUnsignedIntImpl& operator/=(const ExtendedUnsignedIntImpl& other) {
    return DivImpl(other);
  }

  ExtendedUnsignedIntImpl& operator/=(const ET& other) {
    return *this /= ExtendedUnsignedIntImpl(other);
  }

  template <typename T>
  REQUIRES((is_native_integer<T>::value))
  RETURN(ExtendedUnsignedIntImpl&) operator/=(const T& other) {
    return *this /= ExtendedUnsignedIntImpl(other);
  }

  ExtendedUnsignedIntImpl& operator%=(const ExtendedUnsignedIntImpl& other) {
    return ModImpl(other);
  }

  ExtendedUnsignedIntImpl& operator%=(const ET& other) {
    return *this %= ExtendedUnsignedIntImpl(other);
  }

  template <typename T>
  REQUIRES((is_native_integer<T>::value))
  RETURN(ExtendedUnsignedIntImpl&) operator%=(const T& other) {
    return *this %= ExtendedUnsignedIntImpl(other);
  }

  ExtendedUnsignedIntImpl& operator&=(const ExtendedUnsignedIntImpl& other) {
    base::low_ &= other.low();
    base::hi_ &= other.hi();
    return *this;
  }

  template <typename T>
  REQUIRES((is_native_integer<T>::value))
  RETURN(ExtendedUnsignedIntImpl&) operator&=(const T& other) {
    return *this &= ExtendedUnsignedIntImpl(other);
  }

  ExtendedUnsignedIntImpl& operator&=(const ET& other) {
    return *this &= ExtendedUnsignedIntImpl(other);
  }

  ExtendedUnsignedIntImpl& operator^=(const ExtendedUnsignedIntImpl& other) {
    base::low_ ^= other.low();
    base::hi_ ^= other.hi();
    return *this;
  }

  ExtendedUnsignedIntImpl& operator^=(const ET& other) {
    return *this ^= ExtendedUnsignedIntImpl(other);
  }

  template <typename T>
  REQUIRES((is_native_integer<T>::value))
  RETURN(ExtendedUnsignedIntImpl&) operator^=(const T& other) {
    return *this ^= ExtendedUnsignedIntImpl(other);
  }

  ExtendedUnsignedIntImpl& operator|=(const ExtendedUnsignedIntImpl& other) {
    base::low_ |= other.low();
    base::hi_ |= other.hi();
    return *this;
  }

  ExtendedUnsignedIntImpl& operator|=(const ET& other) {
    return *this |= ExtendedUnsignedIntImpl(other);
  }

  template <typename T>
  REQUIRES((is_native_integer<T>::value))
  RETURN(ExtendedUnsignedIntImpl&) operator|=(const T& other) {
    return *this |= ExtendedUnsignedIntImpl(other);
  }

  ExtendedUnsignedIntImpl& operator>>=(int cnt) {
    base::ShiftRight(cnt);
    return *this;
  }

  ExtendedUnsignedIntImpl& operator<<=(int cnt) {
    base::ShiftLeft(cnt);
    return *this;
  }

  ExtendedUnsignedIntImpl& operator++() {
    base::AddOne();
    return *this;
  }

  ExtendedUnsignedIntImpl operator++(int) {
    ExtendedUnsignedIntImpl ret(*this);
    *this += 1;
    return ret;
  }

  ExtendedUnsignedIntImpl& operator--() {
    if (!base::low_.IsZero()) {
      --base::low_;
    } else {
      --base::low_;
      --base::hi_;
    }
    return *this;
  }

  ExtendedUnsignedIntImpl operator--(int) {
    ExtendedUnsignedIntImpl ret(*this);
    *this -= 1;
    return ret;
  }

 public:
  // All the binary operators are friend operators
  // Comparison operators
#if PE_HAS_CPP20
  friend inline int operator<=>(const ExtendedUnsignedIntImpl& l,
                                const ExtendedUnsignedIntImpl& r) {
    return l.CompareTo(r);
  }
  friend inline int operator==(const ExtendedUnsignedIntImpl& l,
                               const ExtendedUnsignedIntImpl& r) {
    return l.CompareTo(r) == 0;
  }
  friend inline int operator!=(const ExtendedUnsignedIntImpl& l,
                               const ExtendedUnsignedIntImpl& r) {
    return l.CompareTo(r) != 0;
  }
#else
  friend inline int operator<(const ExtendedUnsignedIntImpl& l,
                              const ExtendedUnsignedIntImpl& r) {
    return l.CompareTo(r) < 0;
  }
  friend inline int operator<=(const ExtendedUnsignedIntImpl& l,
                               const ExtendedUnsignedIntImpl& r) {
    return l.CompareTo(r) <= 0;
  }
  friend inline int operator>(const ExtendedUnsignedIntImpl& l,
                              const ExtendedUnsignedIntImpl& r) {
    return l.CompareTo(r) > 0;
  }
  friend inline int operator>=(const ExtendedUnsignedIntImpl& l,
                               const ExtendedUnsignedIntImpl& r) {
    return l.CompareTo(r) >= 0;
  }
  friend inline int operator==(const ExtendedUnsignedIntImpl& l,
                               const ExtendedUnsignedIntImpl& r) {
    return l.CompareTo(r) == 0;
  }
  friend inline int operator!=(const ExtendedUnsignedIntImpl& l,
                               const ExtendedUnsignedIntImpl& r) {
    return l.CompareTo(r) != 0;
  }
#endif
  friend inline ExtendedUnsignedIntImpl operator+(
      const ExtendedUnsignedIntImpl& l, const ExtendedUnsignedIntImpl& r) {
    ExtendedUnsignedIntImpl ret(l);
    ret += r;
    return ret;
  }
  friend inline ExtendedUnsignedIntImpl operator-(
      const ExtendedUnsignedIntImpl& l, const ExtendedUnsignedIntImpl& r) {
    ExtendedUnsignedIntImpl ret(l);
    ret -= r;
    return ret;
  }
  friend inline ExtendedUnsignedIntImpl operator*(
      const ExtendedUnsignedIntImpl& l, const ExtendedUnsignedIntImpl& r) {
    ExtendedUnsignedIntImpl ret(l);
    ret *= r;
    return ret;
  }
  friend inline ExtendedUnsignedIntImpl operator/(
      const ExtendedUnsignedIntImpl& l, const ExtendedUnsignedIntImpl& r) {
    ExtendedUnsignedIntImpl ret(l);
    ret /= r;
    return ret;
  }
  friend inline ExtendedUnsignedIntImpl operator%(
      const ExtendedUnsignedIntImpl& l, const ExtendedUnsignedIntImpl& r) {
    ExtendedUnsignedIntImpl ret(l);
    ret %= r;
    return ret;
  }
  friend inline ExtendedUnsignedIntImpl operator&(
      const ExtendedUnsignedIntImpl& l, const ExtendedUnsignedIntImpl& r) {
    ExtendedUnsignedIntImpl ret(l);
    ret &= r;
    return ret;
  }
  friend inline ExtendedUnsignedIntImpl operator^(
      const ExtendedUnsignedIntImpl& l, const ExtendedUnsignedIntImpl& r) {
    ExtendedUnsignedIntImpl ret(l);
    ret ^= r;
    return ret;
  }
  friend inline ExtendedUnsignedIntImpl operator|(
      const ExtendedUnsignedIntImpl& l, const ExtendedUnsignedIntImpl& r) {
    ExtendedUnsignedIntImpl ret(l);
    ret |= r;
    return ret;
  }
  friend inline ExtendedUnsignedIntImpl operator<<(
      const ExtendedUnsignedIntImpl& l, const int cnt) {
    ExtendedUnsignedIntImpl ret(l);
    ret <<= cnt;
    return ret;
  }
  friend inline ExtendedUnsignedIntImpl operator>>(
      const ExtendedUnsignedIntImpl& l, const int cnt) {
    ExtendedUnsignedIntImpl ret(l);
    ret >>= cnt;
    return ret;
  }
  friend inline std::ostream& operator<<(std::ostream& o,
                                         const ExtendedUnsignedIntImpl& n) {
    return o << n.ToString();
  }
};

template <typename ET, bool is_native_integer>
SL int IsZero(const ExtendedUnsignedIntImpl<ET, is_native_integer>& x) {
  return x.IsZero();
}

template <typename ET, bool is_native_integer>
SL int IntSign(const ExtendedUnsignedIntImpl<ET, is_native_integer>& x) {
  return x.IntSign();
}

template <typename ET, bool is_native_integer>
SL int IsEven(const ExtendedUnsignedIntImpl<ET, is_native_integer>& x) {
  return x.IsEven();
}

template <typename ET, bool is_native_integer>
SL int IsOdd(const ExtendedUnsignedIntImpl<ET, is_native_integer>& x) {
  return x.IsOdd();
}

template <typename ET, bool is_native_integer>
SL unsigned int LowerBits(
    const ExtendedUnsignedIntImpl<ET, is_native_integer>& x) {
  return x.LowerBits();
}

template <typename ET, bool is_native_integer>
SL ExtendedUnsignedIntImpl<ET, is_native_integer> Abs(
    const ExtendedUnsignedIntImpl<ET, is_native_integer>& x) {
  return x;
}

template <typename ET, bool is_native_integer>
SL ExtendedUnsignedIntImpl<ET, is_native_integer> FAbs(
    const ExtendedUnsignedIntImpl<ET, is_native_integer>& x) {
  return x;
}

template <typename ET, bool is_native_integer>
SL int SameParity(const ExtendedUnsignedIntImpl<ET, is_native_integer>& l,
                  const ExtendedUnsignedIntImpl<ET, is_native_integer>& r) {
  return SameParity(l.LowerBits(), r.LowerBits());
}

template <typename ET, bool is_native_integer>
SL std::tuple<ExtendedUnsignedIntImpl<ET, is_native_integer>,
              ExtendedUnsignedIntImpl<ET, is_native_integer>>
Div(const ExtendedUnsignedIntImpl<ET, is_native_integer>& l,
    const ExtendedUnsignedIntImpl<ET, is_native_integer>& r) {
  ExtendedUnsignedIntImpl<ET, is_native_integer> remain;
  ExtendedUnsignedIntImpl<ET, is_native_integer> d(l);
  d.DivImpl(r, remain);
  return {d, remain};
}

template <typename T, typename ET, bool is_native_integer>
SL T ToInt(const ExtendedUnsignedIntImpl<ET, is_native_integer>& x) {
  return x.template ToInt<T>();
}

template <typename T, typename ET, bool is_native_integer>
SL T ToFloat(const ExtendedUnsignedIntImpl<ET, is_native_integer>& x) {
  return x.template ToFloat<T>();
}

template <typename ET, bool is_native_integer>
SL std::string ToString(
    const ExtendedUnsignedIntImpl<ET, is_native_integer>& x) {
  return x.ToString();
}

template <typename ET, bool is_native_integer>
SL std::string to_string(
    const ExtendedUnsignedIntImpl<ET, is_native_integer>& x) {
  return ToString(x);
}

template <typename ET, bool is_native_integer, typename T2>
SL REQUIRES((pe::is_native_integer<T2>::value))
    RETURN(ExtendedUnsignedIntImpl<ET, is_native_integer>)
        Power(ExtendedUnsignedIntImpl<ET, is_native_integer> x, T2 n) {
  PE_ASSERT(n >= 0);
  ExtendedUnsignedIntImpl<ET, is_native_integer> ret = 1;
  for (; n > 0; n >>= 1) {
    if (n & 1) ret *= x;
    if (n > 1) x *= x;
  }
  return ret;
}

template <typename ET, bool is_native_integer, typename T2, typename T3>
SL REQUIRES((pe::is_native_integer<T2>::value))
    RETURN(ExtendedUnsignedIntImpl<ET, is_native_integer>)
        Power(ExtendedUnsignedIntImpl<ET, is_native_integer> x, T2 n, T3 mod) {
  PE_ASSERT(n >= 0);
  ExtendedUnsignedIntImpl<ET, is_native_integer> ret = 1;
  for (; n > 0; n >>= 1) {
    if (n & 1) ret = ret * x % mod;
    if (n > 1) x = x * x % mod;
  }
  return ret;
}

template <typename ET>
using ExtendedUnsignedInt =
    ExtendedUnsignedIntImpl<ET, is_native_integer<ET>::value>;

#if PE_HAS_CPP20
static_assert(PeNumberUtil<ExtendedUnsignedInt<uint64>>);
#if PE_HAS_INT128
static_assert(PeNumberUtil<ExtendedUnsignedInt<uint128>>);
#endif
#endif
}  // namespace pe

#endif
