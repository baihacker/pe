#ifndef PE_EXTENDED_UNSIGNED_INT_
#define PE_EXTENDED_UNSIGNED_INT_

#include "pe_base"
#include "pe_int128"
#include "pe_type_traits"
#include "pe_int"
#include "pe_bit"

namespace pe {
// Extended integers

// Extended unsigned integer.

template <typename ET, bool is_native>
struct ExtendedUnsignedIntImpl;

template <typename ET, bool is_native>
struct ExtendedSignedIntImpl;

template <typename ET, bool is_native>
struct ExtractETImpl;

template <typename ET>
struct ExtractETImpl<ET, true> {
  using type = typename pe::pe_make_unsigned<ET>::type;
};

template <typename ET>
struct ExtractETImpl<ET, false> {
  using type = typename ET::UnsignedT;
};

template <typename ET>
struct ExtractET : public ExtractETImpl<ET, is_builtin_integer<ET>::value> {};

template <typename ET>
struct ExtendedUnsignedIntImpl<ET, true> {
  constexpr static int quarter_bitcount = sizeof(ET) * 4;
  constexpr static int half_bitcount = quarter_bitcount * 2;
  constexpr static int bitcount = half_bitcount * 2;

  constexpr static ET quarter_mask =
      (static_cast<ET>(1) << quarter_bitcount) - 1;

  constexpr static ET hibit_mask = (static_cast<ET>(1) << (half_bitcount - 1));

  using UnsignedT = ExtendedUnsignedIntImpl<ET, true>;
  using SignedT = ExtendedSignedIntImpl<ET, true>;

  // The corresponding native integer type.
  using NT = ET;

 private:
  template <typename T>
  REQUIRES((is_builtin_integer<T>::value && pe_is_unsigned<T>::value &&
            sizeof(T) <= sizeof(ET)))
  RETURN(void) FromNativeInt(T v) {
    low_ = v;
  }

  template <typename T>
  REQUIRES((is_builtin_integer<T>::value && pe_is_unsigned<T>::value &&
            sizeof(T) > sizeof(ET)))
  RETURN(void) FromNativeInt(T v) {
    low_ = v;
    hi_ = v >> half_bitcount;
  }

  template <typename T>
  REQUIRES((is_builtin_integer<T>::value && pe_is_signed<T>::value &&
            sizeof(T) <= sizeof(ET)))
  RETURN(void) FromNativeInt(T v) {
    if (v >= 0) {
      low_ = v;
    } else {
      low_ = v;
      hi_ = -1;
    }
  }

  template <typename T>
  REQUIRES((is_builtin_integer<T>::value && pe_is_signed<T>::value &&
            sizeof(T) > sizeof(ET)))
  RETURN(void) FromNativeInt(T v) {
    using unsignedT = typename pe_make_unsigned<T>::type;
    FromNativeInt<unsignedT>(static_cast<unsignedT>(v));
  }

  void FromString(const std::string& str) {
    const int n = static_cast<int>(str.size());
    if (n == 0) return;
    int idx = 0;
    int neg = 0;
    if (str[idx] == '-') {
      ++idx;
      neg = 1;
    } else if (str[idx] == '+') {
      ++idx;
    }
    while (idx < n && std::isdigit(str[idx])) {
      *this *= 10;
      *this += str[idx] - '0';
      ++idx;
    }
    if (neg) {
      FlipBits();
      AddOne();
    }
  }

 public:
  ExtendedUnsignedIntImpl(ET low = 0) : low_(low), hi_(0) {}
  ExtendedUnsignedIntImpl(ET low, ET hi) : low_(low), hi_(hi) {}

  template <typename T,
            typename TT = REQUIRES((is_builtin_integer<T>::value)) RETURN(T)>
  ExtendedUnsignedIntImpl(T v) : low_(0), hi_(0) {
    FromNativeInt<T>(v);
  }

  ExtendedUnsignedIntImpl(const std::string& str) : low_(0), hi_(0) {
    FromString(str);
  }

  ExtendedUnsignedIntImpl(const ExtendedUnsignedIntImpl& other)
      : low_(other.low_), hi_(other.hi_) {}

  ExtendedUnsignedIntImpl& operator=(const ET& other) {
    low_ = other;
    hi_ = 0;
    return *this;
  }

  template <typename T,
            typename TT = REQUIRES((is_builtin_integer<T>::value)) RETURN(T)>
  ExtendedUnsignedIntImpl& operator=(const T& other) {
    low_ = hi_ = 0;
    FromNativeInt<T>(other);
    return *this;
  }

  ExtendedUnsignedIntImpl& operator=(const std::string& str) {
    MakeZeroBits();
    FromString(str);
    return *this;
  }

  ExtendedUnsignedIntImpl& operator=(const ExtendedUnsignedIntImpl& other) {
    low_ = other.low_;
    hi_ = other.hi_;
    return *this;
  }

  ExtendedUnsignedIntImpl& operator=(
      const ExtendedUnsignedIntImpl&& other) noexcept {
    low_ = std::move(other.low_);
    hi_ = std::move(other.hi_);
    return *this;
  }

 public:
  void MakeAbs() {}

  void FlipBits() {
    low_ = ~low_;
    hi_ = ~hi_;
  }

  void MakeZeroBits() {
    low_ = 0;
    hi_ = 0;
  }

  void AddOne() {
    ++low_;
    if (low_ == 0) {
      ++hi_;
    }
  }

  int GetHighestBit() const { return hi_ & hibit_mask ? 1 : 0; }

  void ResetHighestBit() { hi_ &= ~hibit_mask; }

  void SetHighestBit() { hi_ |= hibit_mask; }

  void SetBit(int idx) {
    if (idx < half_bitcount) {
      low_ |= static_cast<ET>(1) << idx;
    } else {
      hi_ |= static_cast<ET>(1) << (idx - half_bitcount);
    }
  }

  void ResetBit(int idx) {
    if (idx < half_bitcount) {
      low_ &= ~(static_cast<ET>(1) << idx);
    } else {
      hi_ &= ~(static_cast<ET>(1) << (idx - half_bitcount));
    }
  }

  int GetBit(int idx) const {
    if (idx < half_bitcount) {
      return low_ & (static_cast<ET>(1) << idx) ? 1 : 0;
    } else {
      return hi_ & (static_cast<ET>(1) << (idx - half_bitcount)) ? 1 : 0;
    }
  }

  void RevBit(int idx) {
    if (idx < half_bitcount) {
      low_ ^= static_cast<ET>(1) << idx;
    } else {
      hi_ ^= static_cast<ET>(1) << (idx - half_bitcount);
    }
  }

  int BitCount() const {
    const int each = sizeof(ET) / sizeof(uint32_t);

    int ret = 0;
    ET t = low_;
    for (int i = 0; t && i < each; ++i) {
      ret += pe_popcount(static_cast<uint32_t>(t));
#if defined(COMPILER_MSVC) || defined(COMPILER_CLANG)
      t >>= 16;
      t >>= 16;
#else
      t >>= 32;
#endif
    }

    t = hi_;
    for (int i = 0; t && i < each; ++i) {
      ret += pe_popcount(static_cast<uint32_t>(t));
#if defined(COMPILER_MSVC) || defined(COMPILER_CLANG)
      t >>= 16;
      t >>= 16;
#else
      t >>= 32;
#endif
    }

    return ret;
  }

  void ArithmeticShiftRight(int cnt) {
    if (GetHighestBit()) {
      FlipBits();
      AddOne();
      ShiftRight(cnt);
      FlipBits();
    } else {
      ShiftRight(cnt);
    }
  }

  void ShiftRight(int cnt) {
    if (cnt >= bitcount) {
      low_ = hi_ = 0;
    } else if (cnt >= half_bitcount) {
      low_ = hi_ >> (cnt - half_bitcount);
      hi_ = 0;
    } else {
      ET mask = (static_cast<ET>(1) << cnt) - 1;
      ET t = hi_ & mask;
      hi_ >>= cnt;
      low_ >>= cnt;
      low_ |= t << (half_bitcount - cnt);
    }
  }

  void ShiftLeft(int cnt) {
    if (cnt >= bitcount) {
      low_ = hi_ = 0;
    } else if (cnt >= half_bitcount) {
      hi_ = low_ << (cnt - half_bitcount);
      low_ = 0;
    } else {
      ET t = low_ >> (half_bitcount - cnt);
      hi_ = hi_ << cnt | t;
      low_ <<= cnt;
    }
  }

  ET GetQuarter(int i) const {
    switch (i & 3) {
      case 0:
        return low_ & quarter_mask;
      case 1:
        return low_ >> quarter_bitcount;
      case 2:
        return hi_ & quarter_mask;
      case 3:
        return hi_ >> quarter_bitcount;
    }
    return 0;
  }

  template <typename T>
  static void FixSize(std::vector<T>& v) {
    if (v.empty()) v.push_back(0);
    int now = static_cast<int>(v.size()) - 1;
    while (now > 0 && v[now] == 0) --now;
    v.resize(now + 1);
  }

  std::vector<uint32_t> ToUInt32Vector(int fix_size = 1) const {
    const int each = sizeof(ET) / sizeof(uint32_t);

    std::vector<uint32_t> r;
    r.reserve(each * 2);
    ET t = low_;
    for (int i = 0; i < each; ++i) {
      r.push_back(static_cast<uint32_t>(t));
#if defined(COMPILER_MSVC) || defined(COMPILER_CLANG)
      t >>= 16;
      t >>= 16;
#else
      t >>= 32;
#endif
    }
    if (!fix_size || hi_) {
      t = hi_;
      for (int i = 0; i < each; ++i) {
        r.push_back(static_cast<uint32_t>(t));
#if defined(COMPILER_MSVC) || defined(COMPILER_CLANG)
        t >>= 16;
        t >>= 16;
#else
        t >>= 32;
#endif
      }
    }
    if (fix_size) {
      FixSize(r);
    }
    return r;
  }

  void FromUInt32Vector(const std::vector<uint32_t>& bits32) {
    const int each = sizeof(ET) / sizeof(int32_t);

    hi_ = 0;
    for (int i = std::min(2 * each - 1, static_cast<int>(bits32.size()));
         i >= each; --i) {
#if defined(COMPILER_MSVC) || defined(COMPILER_CLANG)
      hi_ <<= 16;
      hi_ = (hi_ << 16) | bits32[i];
#else
      hi_ = (hi_ << 32) | bits32[i];
#endif
    }

    low_ = 0;
    for (int i = std::min(each - 1, static_cast<int>(bits32.size())); i >= 0;
         --i) {
#if defined(COMPILER_MSVC) || defined(COMPILER_CLANG)
      low_ <<= 16;
      low_ = (low_ << 16) | bits32[i];
#else
      low_ = (low_ << 32) | bits32[i];
#endif
    }
  }

  std::vector<uint32_t> ToBinaryVector(int fix_size = 1) const {
    std::vector<uint32_t> r;
    r.reserve(bitcount);
    ET t = low_;
    for (int i = 0; i < half_bitcount; ++i) {
      r.push_back(t & 1);
      t >>= 1;
    }
    if (!fix_size || hi_) {
      t = hi_;
      for (int i = 0; i < half_bitcount; ++i) {
        r.push_back(t & 1);
        t >>= 1;
      }
    }
    if (fix_size) {
      FixSize(r);
    }
    return r;
  }

  void FromBinaryVector(const std::vector<uint32_t>& bits) {
    hi_ = 0;
    for (int i = std::min(bitcount - 1, static_cast<int>(bits.size()) - 1);
         i >= half_bitcount; --i) {
      hi_ = (hi_ << 1) | bits[i];
    }

    low_ = 0;
    for (int i = std::min(half_bitcount - 1, static_cast<int>(bits.size()) - 1);
         i >= 0; --i) {
      low_ = (low_ << 1) | bits[i];
    }
  }

  static std::vector<uint32_t> DivideInternal(const std::vector<uint32_t>& l,
                                              const std::vector<uint32_t>& r,
                                              std::vector<uint32_t>& remain) {
    std::vector<uint32_t> result;
    remain = l;

    const int r_size = static_cast<int>(r.size());
    int pos = static_cast<int>(l.size()) - 1;
    int end = pos - r_size + 1;
    for (; end >= 0;) {
      if (pos - end + 1 < r_size) {
        result.push_back(0);
        --end;
        continue;
      }
      if (remain[pos] == 0) {
        --pos;
        continue;
      }
      int gt = 1;
      if (pos - end + 1 == r_size) {
        for (int i = pos, j = r_size - 1; i >= end; --i, --j) {
          if (remain[i] < r[j]) {
            gt = 0;
            break;
          } else if (remain[i] > r[j]) {
            break;
          }
        }
      }
      result.push_back(gt);
      if (gt == 0) {
        --end;
        continue;
      }

      int borrow = 0;
      int i = end, j = 0;
      for (; j < r_size; ++i, ++j) {
        int next_borrow = 0;
        auto t = remain[i];
        while (t < r[j] + borrow) {
          t += 2;
          ++next_borrow;
        }
        remain[i] = t - r[j] - borrow;
        borrow = next_borrow;
      }

      for (; i <= pos; ++i) {
        int next_borrow = 0;
        int t = remain[i];
        while (t < borrow) {
          t += 2;
          ++next_borrow;
        }
        remain[i] = t - borrow;
        borrow = next_borrow;
      }
      --end;
    }

    if (result.size() == 0) result.push_back(0);
    std::reverse(result.begin(), result.end());

    return result;
  }

  static void DivideInplace(ExtendedUnsignedIntImpl& self,
                            const ExtendedUnsignedIntImpl& other) {
    if (self.IsZero()) {
      return;
    }
    PE_ASSERT(!other.IsZero());

    if (other.hi_ == 0 && other.low_ == 1) {
      return;
    }

    int t = self.CompareTo(other);
    if (t == 0) {
      self.low_ = 1;
      self.hi_ = 0;
      return;
    }

    if (t < 0) {
      self.low_ = self.hi_ = 0;
      return;
    }

    if (self.hi_ == 0) {
      self.low_ /= other.low_;
      return;
    }

    std::vector<uint32_t> remain;

    std::vector<uint32_t> result =
        DivideInternal(self.ToBinaryVector(), other.ToBinaryVector(), remain);

    self.FromBinaryVector(result);
  }

  static void DivideInplace(ExtendedUnsignedIntImpl& self,
                            const ExtendedUnsignedIntImpl& other,
                            ExtendedUnsignedIntImpl& remain) {
    if (self.IsZero()) {
      remain = 0;
      return;
    }
    PE_ASSERT(!other.IsZero());

    if (other.hi_ == 0 && other.low_ == 1) {
      remain = 0;
      return;
    }

    int t = self.CompareTo(other);
    if (t == 0) {
      self.low_ = 1;
      self.hi_ = 0;
      remain = 0;
      return;
    }

    if (t < 0) {
      remain = self;
      self.low_ = self.hi_ = 0;
      return;
    }

    if (self.hi_ == 0) {
      remain = self.low_ % other.low_;
      self.low_ /= other.low_;
      return;
    }

    std::vector<uint32_t> r;

    std::vector<uint32_t> result =
        DivideInternal(self.ToBinaryVector(), other.ToBinaryVector(), r);

    self.FromBinaryVector(result);
    remain.FromBinaryVector(r);
  }

  static void RemainInplace(ExtendedUnsignedIntImpl& self,
                            const ExtendedUnsignedIntImpl& other) {
    if (self.IsZero()) {
      return;
    }
    PE_ASSERT(!other.IsZero());

    if (other.hi_ == 0 && other.low_ == 1) {
      self.low_ = self.hi_ = 0;
      return;
    }

    int t = self.CompareTo(other);
    if (t == 0) {
      self.low_ = self.hi_ = 0;
      return;
    }

    if (t < 0) {
      return;
    }

    if (self.hi_ == 0) {
      self.low_ %= other.low_;
      return;
    }

    std::vector<uint32_t> remain;

    DivideInternal(self.ToBinaryVector(), other.ToBinaryVector(), remain);

    self.FromBinaryVector(remain);
  }

 public:
  ET& low() { return low_; }

  ET& hi() { return hi_; }

  ET low() const { return low_; }

  ET hi() const { return hi_; }

  int sign() const { return low_ || hi_ ? 1 : 0; }

  int CompareTo(const ExtendedUnsignedIntImpl& other) const {
    if (hi_ != other.hi_) {
      return hi_ < other.hi_ ? -1 : hi_ > other.hi_;
    } else {
      return low_ < other.low_ ? -1 : low_ > other.low_;
    }
  }

  int IntSign() const { return low_ || hi_ ? 1 : 0; }

  int IsZero() const { return low_ == 0 && hi_ == 0; }

  int IsEven() const { return low_ & 1 ? 0 : 1; }

  int IsOdd() const { return low_ & 1 ? 1 : 0; }

  unsigned int LowerBits() const { return static_cast<uint32_t>(low_); }

  ExtendedUnsignedIntImpl Abs() const { return *this; }

  ExtendedUnsignedIntImpl FAbs() const { return *this; }

  template <typename T>
  REQUIRES((is_builtin_integer<T>::value && sizeof(T) <= sizeof(ET)))
  RETURN(T) ToInt() const {
    return static_cast<T>(low_);
  }

  template <typename T>
  REQUIRES((is_builtin_integer<T>::value && sizeof(T) > sizeof(ET)))
  RETURN(T) ToInt() const {
    using unsignedT = typename pe_make_unsigned<T>::type;
    return static_cast<T>((static_cast<unsignedT>(hi_) << half_bitcount) |
                          static_cast<unsignedT>(low_));
  }

  template <typename T>
  T ToFloat() const {
    auto t = ToUInt32Vector();
    const int size = static_cast<int>(t.size());
    T r = 0;
    for (int i = size - 1; i >= 0; --i) {
      r = r * 4294967296 + t[i];
    }
    return r;
  }

  std::string ToString() const {
    const uint32_t output_mod = 1000000000;
    if (IsZero()) {
      return "0";
    }
    if (hi_ == 0) {
      return pe::ToString(low_);
    }

    std::vector<uint32_t> bits32 = ToUInt32Vector();
    std::vector<uint32_t> mods;

    std::stringstream ss;

    int idx = bits32.size() - 1;
    while (bits32[idx] == 0) --idx;

    do {
      uint64 add = 0;
      for (int i = idx; i > 0; --i) {
        const uint64 x = add + bits32[i];
        const uint64 next_add = (x % output_mod) << 32;
        bits32[i] = static_cast<unsigned>(x / output_mod);
        add = next_add;
      }
      uint64 x = add + bits32[0];
      bits32[0] = static_cast<unsigned>(x / output_mod);
      mods.push_back(x % output_mod);
      while (idx >= 0 && bits32[idx] == 0) --idx;
    } while (idx >= 0);

    idx = static_cast<int>(mods.size()) - 1;
    char buff[32];
    sprintf(buff, "%u", mods[idx--]);
    ss << buff;
    for (; idx >= 0; --idx) {
      sprintf(buff, "%09u", mods[idx]);
      ss << buff;
    }
    return ss.str();
  }

  std::string to_string() const { return ToString(); }

  ExtendedUnsignedIntImpl Difference(
      const ExtendedUnsignedIntImpl& other) const {
    int t = CompareTo(other);
    if (t == 0) {
      return 0;
    }
    if (t > 0) {
      ET x = hi_ - other.hi_;
      ET y;
      if (low_ >= other.low_) {
        y = low_ - other.low_;
      } else {
        y = low_ - other.low_;
        --x;
      }
      return ExtendedUnsignedIntImpl(y, x);
    } else {
      ET x = other.hi_ - hi_;
      ET y;
      if (other.low_ >= low_) {
        y = other.low_ - low_;
      } else {
        y = other.low_ - low_;
        --x;
      }
      return ExtendedUnsignedIntImpl(y, x);
    }
  }

 public:
  // Operators
  ExtendedUnsignedIntImpl operator+() const { return *this; }

  ExtendedUnsignedIntImpl operator-() const {
    ExtendedUnsignedIntImpl ret(*this);
    FlipBits();
    AddOne();
    return ret;
  }

  ExtendedUnsignedIntImpl operator~() const {
    return ExtendedUnsignedIntImpl(~low_, ~hi_);
  }

  ExtendedUnsignedIntImpl& operator+=(const ExtendedUnsignedIntImpl& other) {
    if (IsZero()) {
      low_ = other.low();
      hi_ = other.hi();
      return *this;
    }

    if (!other.IsZero()) {
      ET x = other.low() + low_;
      ET y = other.hi() + hi_;
      if (other.low_ && low_ && (x < other.low() || x < low_)) {
        ++y;
      }
      low_ = x;
      hi_ = y;
    }
    return *this;
  }

  ExtendedUnsignedIntImpl& operator+=(const ET& other) {
    if (IsZero()) {
      low_ = other;
      hi_ = 0;
      return *this;
    }

    if (other) {
      ET x = low_ + other;
      ET y = hi_;
      if (low_ && other && (x < low_ || x < other)) {
        ++y;
      }
      low_ = x;
      hi_ = y;
    }
    return *this;
  }

  ExtendedUnsignedIntImpl& operator-=(const ExtendedUnsignedIntImpl& other) {
    if (other.IsZero()) {
      return *this;
    }

    if (IsZero()) {
      low_ = other.low();
      hi_ = other.hi();
      FlipBits();
      AddOne();
      return *this;
    }

    int t = CompareTo(other);
    if (t == 0) {
      low_ = hi_ = 0;
      return *this;
    } else {
      ExtendedUnsignedIntImpl d = Difference(other);
      if (t < 0) {
        d.FlipBits();
        d.AddOne();
      }
      low_ = d.low();
      hi_ = d.hi();
    }

    return *this;
  }

  ExtendedUnsignedIntImpl& operator-=(const ET& other) {
    if (other == 0) {
      return *this;
    }

    if (IsZero()) {
      low_ = other;
      FlipBits();
      AddOne();
      return *this;
    }

    int t = CompareTo(other);
    if (t == 0) {
      low_ = hi_ = 0;
      return *this;
    } else {
      ExtendedUnsignedIntImpl d = Difference(other);
      if (t < 0) {
        d.FlipBits();
        d.AddOne();
      }
      low_ = d.low();
      hi_ = d.hi();
    }

    return *this;
  }

  ExtendedUnsignedIntImpl& operator*=(const ExtendedUnsignedIntImpl& other) {
    if (IsZero() || other.IsZero()) {
      low_ = hi_ = 0;
      return *this;
    }
    ET t[4] = {0};
    for (int i = 0; i < 4; ++i) {
      for (int j = 0; j + i < 4; ++j) {
        ET carry = GetQuarter(i) * other.GetQuarter(j);
        for (int now = i + j; now < 4; ++now) {
          ET x = t[now] + (carry & quarter_mask);
          t[now] = x & quarter_mask;
          carry = (x >> quarter_bitcount) + (carry >> quarter_bitcount);
          if (carry == 0) {
            break;
          }
        }
      }
    }
    low_ = t[0] | (t[1] << quarter_bitcount);
    hi_ = t[2] | (t[3] << quarter_bitcount);

    return *this;
  }

  ExtendedUnsignedIntImpl& operator*=(const ET& other) {
    if (IsZero() || other == 0) {
      low_ = hi_ = 0;
      return *this;
    }
    ET t[4] = {0};
    for (int i = 0; i < 4; ++i) {
      for (int j = 0; j < 2 && j + i < 4; ++j) {
        ET carry = GetQuarter(i) *
                   (j == 0 ? other & quarter_mask : other >> quarter_bitcount);
        for (int now = i + j; now < 4; ++now) {
          ET x = t[now] + (carry & quarter_mask);
          t[now] = x & quarter_mask;
          carry = (x >> quarter_bitcount) + (carry >> quarter_bitcount);
          if (carry == 0) {
            break;
          }
        }
      }
    }
    low_ = t[0] | (t[1] << quarter_bitcount);
    hi_ = t[2] | (t[3] << quarter_bitcount);
    return *this;
  }

  ExtendedUnsignedIntImpl& operator/=(const ExtendedUnsignedIntImpl& other) {
    DivideInplace(*this, other);
    return *this;
  }

  ExtendedUnsignedIntImpl& operator/=(const ET& other) {
    return *this /= ExtendedUnsignedIntImpl(other);
  }

  ExtendedUnsignedIntImpl& operator%=(const ExtendedUnsignedIntImpl& other) {
    RemainInplace(*this, other);
    return *this;
  }

  ExtendedUnsignedIntImpl& operator%=(const ET& other) {
    return *this %= ExtendedUnsignedIntImpl(other);
  }

  ExtendedUnsignedIntImpl& operator&=(const ExtendedUnsignedIntImpl& other) {
    low_ &= other.low();
    hi_ &= other.hi();
    return *this;
  }

  ExtendedUnsignedIntImpl& operator&=(const ET& other) {
    low_ &= other;
    hi_ = 0;
    return *this;
  }

  ExtendedUnsignedIntImpl& operator^=(const ExtendedUnsignedIntImpl& other) {
    low_ ^= other.low();
    hi_ ^= other.hi();
    return *this;
  }

  ExtendedUnsignedIntImpl& operator^=(const ET& other) {
    low_ ^= other;
    return *this;
  }

  ExtendedUnsignedIntImpl& operator|=(const ExtendedUnsignedIntImpl& other) {
    low_ |= other.low();
    hi_ |= other.hi();
    return *this;
  }

  ExtendedUnsignedIntImpl& operator|=(const ET& other) {
    low_ |= other;
    return *this;
  }

  ExtendedUnsignedIntImpl& operator>>=(int cnt) {
    ShiftRight(cnt);
    return *this;
  }

  ExtendedUnsignedIntImpl& operator<<=(int cnt) {
    ShiftLeft(cnt);
    return *this;
  }

  ExtendedUnsignedIntImpl& operator++() {
    AddOne();
    return *this;
  }

  ExtendedUnsignedIntImpl operator++(int) {
    ExtendedUnsignedIntImpl ret(*this);
    *this += 1;
    return ret;
  }

  ExtendedUnsignedIntImpl& operator--() {
    if (low_) {
      --low_;
    } else {
      --low_;
      --hi_;
    }
    return *this;
  }

  ExtendedUnsignedIntImpl operator--(int) {
    ExtendedUnsignedIntImpl ret(*this);
    *this -= 1;
    return ret;
  }

 public:
  // All the binary operators are friend operators
  // Comparison operators
#if PE_HAS_CPP20
  friend inline int operator<=>(const ExtendedUnsignedIntImpl& l,
                                const ExtendedUnsignedIntImpl& r) {
    return l.CompareTo(r);
  }
  friend inline int operator==(const ExtendedUnsignedIntImpl& l,
                               const ExtendedUnsignedIntImpl& r) {
    return l.CompareTo(r) == 0;
  }
  friend inline int operator!=(const ExtendedUnsignedIntImpl& l,
                               const ExtendedUnsignedIntImpl& r) {
    return l.CompareTo(r) != 0;
  }
#else
  friend inline int operator<(const ExtendedUnsignedIntImpl& l,
                              const ExtendedUnsignedIntImpl& r) {
    return l.CompareTo(r) < 0;
  }
  friend inline int operator<=(const ExtendedUnsignedIntImpl& l,
                               const ExtendedUnsignedIntImpl& r) {
    return l.CompareTo(r) <= 0;
  }
  friend inline int operator>(const ExtendedUnsignedIntImpl& l,
                              const ExtendedUnsignedIntImpl& r) {
    return l.CompareTo(r) > 0;
  }
  friend inline int operator>=(const ExtendedUnsignedIntImpl& l,
                               const ExtendedUnsignedIntImpl& r) {
    return l.CompareTo(r) >= 0;
  }
  friend inline int operator==(const ExtendedUnsignedIntImpl& l,
                               const ExtendedUnsignedIntImpl& r) {
    return l.CompareTo(r) == 0;
  }
  friend inline int operator!=(const ExtendedUnsignedIntImpl& l,
                               const ExtendedUnsignedIntImpl& r) {
    return l.CompareTo(r) != 0;
  }
#endif
  friend inline ExtendedUnsignedIntImpl operator+(
      const ExtendedUnsignedIntImpl& l, const ExtendedUnsignedIntImpl& r) {
    ExtendedUnsignedIntImpl ret(l);
    ret += r;
    return ret;
  }
  friend inline ExtendedUnsignedIntImpl operator-(
      const ExtendedUnsignedIntImpl& l, const ExtendedUnsignedIntImpl& r) {
    ExtendedUnsignedIntImpl ret(l);
    ret -= r;
    return ret;
  }
  friend inline ExtendedUnsignedIntImpl operator*(
      const ExtendedUnsignedIntImpl& l, const ExtendedUnsignedIntImpl& r) {
    ExtendedUnsignedIntImpl ret(l);
    ret *= r;
    return ret;
  }
  friend inline ExtendedUnsignedIntImpl operator/(
      const ExtendedUnsignedIntImpl& l, const ExtendedUnsignedIntImpl& r) {
    ExtendedUnsignedIntImpl ret(l);
    ret /= r;
    return ret;
  }
  friend inline ExtendedUnsignedIntImpl operator%(
      const ExtendedUnsignedIntImpl& l, const ExtendedUnsignedIntImpl& r) {
    ExtendedUnsignedIntImpl ret(l);
    ret %= r;
    return ret;
  }
  friend inline ExtendedUnsignedIntImpl operator&(
      const ExtendedUnsignedIntImpl& l, const ExtendedUnsignedIntImpl& r) {
    ExtendedUnsignedIntImpl ret(l);
    ret &= r;
    return ret;
  }
  friend inline ExtendedUnsignedIntImpl operator^(
      const ExtendedUnsignedIntImpl& l, const ExtendedUnsignedIntImpl& r) {
    ExtendedUnsignedIntImpl ret(l);
    ret ^= r;
    return ret;
  }
  friend inline ExtendedUnsignedIntImpl operator|(
      const ExtendedUnsignedIntImpl& l, const ExtendedUnsignedIntImpl& r) {
    ExtendedUnsignedIntImpl ret(l);
    ret |= r;
    return ret;
  }
  friend inline ExtendedUnsignedIntImpl operator<<(
      const ExtendedUnsignedIntImpl& l, const int cnt) {
    ExtendedUnsignedIntImpl ret(l);
    ret <<= cnt;
    return ret;
  }
  friend inline ExtendedUnsignedIntImpl operator>>(
      const ExtendedUnsignedIntImpl& l, const int cnt) {
    ExtendedUnsignedIntImpl ret(l);
    ret >>= cnt;
    return ret;
  }
  friend inline std::ostream& operator<<(std::ostream& o,
                                         const ExtendedUnsignedIntImpl& n) {
    return o << n.ToString();
  }

 protected:
#if PE_IS_LITTLE_ENDIAN
  ET low_;
  ET hi_;
#else
  ET hi_;
  ET low_;
#endif
};

template <typename ET>
struct ExtendedUnsignedIntImpl<ET, false> {
  constexpr static int quarter_bitcount = sizeof(ET) * 4;
  constexpr static int half_bitcount = quarter_bitcount * 2;
  constexpr static int bitcount = half_bitcount * 2;

  using NT = typename ET::NT;
  using UnsignedT = ExtendedUnsignedIntImpl<ET, false>;
  using SignedT = ExtendedSignedIntImpl<ET, false>;

 private:
  template <typename T>
  REQUIRES((is_builtin_integer<T>::value && pe_is_unsigned<T>::value &&
            sizeof(T) <= sizeof(ET)))
  RETURN(void) FromNativeInt(T v) {
    low_ = v;
  }

  template <typename T>
  REQUIRES((is_builtin_integer<T>::value && pe_is_unsigned<T>::value &&
            sizeof(T) > sizeof(ET)))
  RETURN(void) FromNativeInt(T v) {
    low_ = v;
    hi_ = v >> half_bitcount;
  }

  template <typename T>
  REQUIRES((is_builtin_integer<T>::value && pe_is_signed<T>::value &&
            sizeof(T) <= sizeof(ET)))
  RETURN(void) FromNativeInt(T v) {
    if (v >= 0) {
      low_ = v;
    } else {
      low_ = v;
      hi_.FlipBits();
    }
  }

  template <typename T>
  REQUIRES((is_builtin_integer<T>::value && pe_is_signed<T>::value &&
            sizeof(T) > sizeof(ET)))
  RETURN(void) FromNativeInt(T v) {
    using unsignedT = typename pe_make_unsigned<T>::type;
    FromNativeInt<unsignedT>(static_cast<unsignedT>(v));
  }

  void FromString(const std::string& str) {
    const int n = static_cast<int>(str.size());
    if (n == 0) return;
    int idx = 0;
    int neg = 0;
    if (str[idx] == '-') {
      ++idx;
      neg = 1;
    } else if (str[idx] == '+') {
      ++idx;
    }
    while (idx < n && std::isdigit(str[idx])) {
      *this *= 10;
      *this += str[idx] - '0';
      ++idx;
    }
    if (neg) {
      FlipBits();
      AddOne();
    }
  }

 public:
  ExtendedUnsignedIntImpl(ET low = 0) : low_(low), hi_(0) {}
  ExtendedUnsignedIntImpl(ET low, ET hi) : low_(low), hi_(hi) {}

  template <typename T,
            typename TT = REQUIRES((is_builtin_integer<T>::value)) RETURN(T)>
  ExtendedUnsignedIntImpl(T v) : low_(0), hi_(0) {
    FromNativeInt<T>(v);
  }

  ExtendedUnsignedIntImpl(const std::string& str) : low_(0), hi_(0) {
    FromString(str);
  }

  ExtendedUnsignedIntImpl(const ExtendedUnsignedIntImpl& other)
      : low_(other.low_), hi_(other.hi_) {}

  ExtendedUnsignedIntImpl& operator=(const ET& other) {
    low_ = other;
    hi_.MakeZeroBits();
    return *this;
  }

  template <typename T,
            typename TT = REQUIRES((is_builtin_integer<T>::value)) RETURN(T)>
  ExtendedUnsignedIntImpl& operator=(const T& other) {
    MakeZeroBits();
    FromNativeInt<T>(other);
    return *this;
  }

  ExtendedUnsignedIntImpl& operator=(const std::string& str) {
    MakeZeroBits();
    FromString(str);
    return *this;
  }

  ExtendedUnsignedIntImpl& operator=(const ExtendedUnsignedIntImpl& other) {
    low_ = other.low_;
    hi_ = other.hi_;
    return *this;
  }

  ExtendedUnsignedIntImpl& operator=(
      const ExtendedUnsignedIntImpl&& other) noexcept {
    low_ = std::move(other.low_);
    hi_ = std::move(other.hi_);
    return *this;
  }

 public:
  void MakeAbs();

  void FlipBits() {
    low_.FlipBits();
    hi_.FlipBits();
  }

  void MakeZeroBits() {
    low_.MakeZeroBits();
    hi_.MakeZeroBits();
  }

  void AddOne() {
    ++low_;
    if (low_.IsZero()) {
      ++hi_;
    }
  }

  int GetHighestBit() const { return hi_.GetHighestBit(); }

  void ResetHighestBit() { hi_.ResetHighestBit(); }

  void SetHighestBit() { hi_.SetHighestBit(); }

  void SetBit(int idx) {
    if (idx < half_bitcount) {
      low_.SetBit(idx);
    } else {
      hi_.SetBit(idx - half_bitcount);
    }
  }

  void ResetBit(int idx) {
    if (idx < half_bitcount) {
      low_.ResetBit(idx);
    } else {
      hi_.ResetBit(idx - half_bitcount);
    }
  }

  int GetBit(int idx) const {
    if (idx < half_bitcount) {
      return low_.GetBit(idx);
    } else {
      return hi_.GetBit(idx - half_bitcount);
    }
  }

  void RevBit(int idx) {
    if (idx < half_bitcount) {
      low_.RevBit(idx);
    } else {
      hi_.RevBit(idx - half_bitcount);
    }
  }

  int BitCount() const { return hi_.BitCount() + low_.BitCount(); }

  void ArithmeticShiftRight(int cnt) {
    if (GetHighestBit()) {
      FlipBits();
      AddOne();
      ShiftRight(cnt);
      FlipBits();
    } else {
      ShiftRight(cnt);
    }
  }

  void ShiftRight(int cnt) {
    if (cnt >= bitcount) {
      MakeZeroBits();
    } else if (cnt >= half_bitcount) {
      low_ = hi_ >> (cnt - half_bitcount);
      hi_.MakeZeroBits();
    } else {
      ET mask = (static_cast<ET>(1) << cnt) - 1;
      ET t = hi_ & mask;
      hi_ >>= cnt;
      low_ >>= cnt;
      low_ |= t << (half_bitcount - cnt);
    }
  }

  void ShiftLeft(int cnt) {
    if (cnt >= bitcount) {
      MakeZeroBits();
    } else if (cnt >= half_bitcount) {
      hi_ = low_ << (cnt - half_bitcount);
      low_.MakeZeroBits();
    } else {
      ET t = low_ >> (half_bitcount - cnt);
      hi_ = hi_ << cnt | t;
      low_ <<= cnt;
    }
  }

  ET GetQuarter(int i) const {
    switch (i & 3) {
      case 0:
        return low_.low();
      case 1:
        return low_.hi();
      case 2:
        return hi_.low();
      case 3:
        return hi_.hi();
    }
    return 0;
  }

  template <typename T>
  static void FixSize(std::vector<T>& v) {
    if (v.empty()) v.push_back(0);
    int now = static_cast<int>(v.size()) - 1;
    while (now > 0 && v[now] == 0) --now;
    v.resize(now + 1);
  }

  std::vector<uint32_t> ToUInt32Vector(int fix_size = 1) const {
    const int each = sizeof(ET) / sizeof(uint32_t);

    std::vector<uint32_t> r;
    r.reserve(each * 2);
    for (auto& iter : low_.ToUInt32Vector(0)) r.push_back(iter);
    if (!fix_size || !hi_.IsZero()) {
      for (auto& iter : hi_.ToUInt32Vector(0)) r.push_back(iter);
    }
    if (fix_size) {
      FixSize(r);
    }
    return r;
  }

  void FromUInt32Vector(const std::vector<uint32_t>& bits32) {
    const int each = sizeof(ET) / sizeof(int32_t);
    hi_.MakeZeroBits();
    for (int i = std::min(2 * each - 1, static_cast<int>(bits32.size()));
         i >= each; --i) {
      hi_ = (hi_ << 32) | bits32[i];
    }

    low_.MakeZeroBits();
    for (int i = std::min(each - 1, static_cast<int>(bits32.size())); i >= 0;
         --i) {
      low_ = (low_ << 32) | bits32[i];
    }
  }

  std::vector<uint32_t> ToBinaryVector(int fix_size = 1) const {
    std::vector<uint32_t> r;
    r.reserve(bitcount);
    for (auto& iter : low_.ToBinaryVector(0)) r.push_back(iter);
    if (!fix_size || !hi_.IsZero()) {
      for (auto& iter : hi_.ToBinaryVector(0)) r.push_back(iter);
    }
    if (fix_size) {
      FixSize(r);
    }
    return r;
  }

  void FromBinaryVector(const std::vector<uint32_t>& bits) {
    low_.MakeZeroBits();
    hi_.MakeZeroBits();
    for (int i = 0; i < bits.size(); ++i) {
      if (bits[i]) {
        if (i < half_bitcount) {
          low_.SetBit(i);
        } else if (i < bitcount) {
          hi_.SetBit(i - half_bitcount);
        }
      }
    }
  }

  static std::vector<uint32_t> DivideInternal(const std::vector<uint32_t>& l,
                                              const std::vector<uint32_t>& r,
                                              std::vector<uint32_t>& remain) {
    std::vector<uint32_t> result;
    remain = l;

    const int r_size = static_cast<int>(r.size());
    int pos = static_cast<int>(l.size()) - 1;
    int end = pos - r_size + 1;
    for (; end >= 0;) {
      if (pos - end + 1 < r_size) {
        result.push_back(0);
        --end;
        continue;
      }
      if (remain[pos] == 0) {
        --pos;
        continue;
      }
      int gt = 1;
      if (pos - end + 1 == r_size) {
        for (int i = pos, j = r_size - 1; i >= end; --i, --j) {
          if (remain[i] < r[j]) {
            gt = 0;
            break;
          } else if (remain[i] > r[j]) {
            break;
          }
        }
      }
      result.push_back(gt);
      if (gt == 0) {
        --end;
        continue;
      }

      int borrow = 0;
      int i = end, j = 0;
      for (; j < r_size; ++i, ++j) {
        int next_borrow = 0;
        auto t = remain[i];
        while (t < r[j] + borrow) {
          t += 2;
          ++next_borrow;
        }
        remain[i] = t - r[j] - borrow;
        borrow = next_borrow;
      }

      for (; i <= pos; ++i) {
        int next_borrow = 0;
        int t = remain[i];
        while (t < borrow) {
          t += 2;
          ++next_borrow;
        }
        remain[i] = t - borrow;
        borrow = next_borrow;
      }
      --end;
    }

    if (result.size() == 0) result.push_back(0);
    std::reverse(result.begin(), result.end());

    return result;
  }

  static void DivideInplace(ExtendedUnsignedIntImpl& self,
                            const ExtendedUnsignedIntImpl& other) {
    if (self.IsZero()) {
      return;
    }
    PE_ASSERT(!other.IsZero());

    if (other.hi_ == 0 && other.low_ == 1) {
      return;
    }

    int t = self.CompareTo(other);
    if (t == 0) {
      self.low_ = 1;
      self.hi_.MakeZeroBits();
      return;
    }

    if (t < 0) {
      self.low_.MakeZeroBits();
      self.hi_.MakeZeroBits();
      return;
    }

    if (self.hi_ == 0) {
      self.low_ /= other.low_;
      return;
    }

    std::vector<uint32_t> remain;

    std::vector<uint32_t> result =
        DivideInternal(self.ToBinaryVector(), other.ToBinaryVector(), remain);

    self.FromBinaryVector(result);
  }

  static void DivideInplace(ExtendedUnsignedIntImpl& self,
                            const ExtendedUnsignedIntImpl& other,
                            ExtendedUnsignedIntImpl& remain) {
    if (self.IsZero()) {
      remain.MakeZeroBits();
      return;
    }
    PE_ASSERT(!other.IsZero());

    if (other.hi_ == 0 && other.low_ == 1) {
      remain.MakeZeroBits();
      return;
    }

    int t = self.CompareTo(other);
    if (t == 0) {
      self.low_ = 1;
      self.hi_.MakeZeroBits();
      remain.MakeZeroBits();
      return;
    }

    if (t < 0) {
      remain = self;
      self.low_.MakeZeroBits();
      self.hi_.MakeZeroBits();
      return;
    }

    if (self.hi_ == 0) {
      remain = self.low_ % other.low_;
      self.low_ /= other.low_;
      return;
    }

    std::vector<uint32_t> r;

    std::vector<uint32_t> result =
        DivideInternal(self.ToBinaryVector(), other.ToBinaryVector(), r);

    self.FromBinaryVector(result);
    remain.FromBinaryVector(r);
  }

  static void RemainInplace(ExtendedUnsignedIntImpl& self,
                            const ExtendedUnsignedIntImpl& other) {
    if (self.IsZero()) {
      return;
    }
    PE_ASSERT(!other.IsZero());

    if (other.hi_ == 0 && other.low_ == 1) {
      self.low_.MakeZeroBits();
      self.hi_.MakeZeroBits();
      return;
    }

    int t = self.CompareTo(other);
    if (t == 0) {
      self.low_.MakeZeroBits();
      self.hi_.MakeZeroBits();
      return;
    }

    if (t < 0) {
      return;
    }

    if (self.hi_.IsZero()) {
      self.low_ %= other.low_;
      return;
    }

    std::vector<uint32_t> remain;

    DivideInternal(self.ToBinaryVector(), other.ToBinaryVector(), remain);

    self.FromBinaryVector(remain);
  }

 public:
  ET& low() { return low_; }

  ET& hi() { return hi_; }

  ET low() const { return low_; }

  ET hi() const { return hi_; }

  int sign() const { return low_.IsZero() || hi_.IsZero() ? 1 : 0; }

  int CompareTo(const ExtendedUnsignedIntImpl& other) const {
    int t = hi_.CompareTo(other.hi_);
    if (t != 0) {
      return t;
    }
    return low_.CompareTo(other.low_);
  }

  int IntSign() const { return low_.IsZero() || hi_.IsZero() ? 1 : 0; }

  int IsZero() const { return low_.IsZero() && hi_.IsZero(); }

  int IsEven() const { return LowerBits() & 1 ? 0 : 1; }

  int IsOdd() const { return LowerBits() & 1 ? 1 : 0; }

  unsigned int LowerBits() const { return low_.LowerBits(); }

  ExtendedUnsignedIntImpl Abs() const { return *this; }

  ExtendedUnsignedIntImpl FAbs() const { return *this; }

  template <typename T>
  REQUIRES((is_builtin_integer<T>::value && sizeof(T) <= sizeof(ET)))
  RETURN(T) ToInt() const {
    return low_.template ToInt<T>();
  }

  template <typename T>
  REQUIRES((is_builtin_integer<T>::value && sizeof(T) > sizeof(ET)))
  RETURN(T) ToInt() const {
    using unsignedT = typename pe_make_unsigned<T>::type;
    return static_cast<T>(hi_.template ToInt<unsignedT>() << half_bitcount |
                          low_.template ToInt<unsignedT>());
  }

  template <typename T>
  T ToFloat() const {
    auto t = ToUInt32Vector();
    const int size = static_cast<int>(t.size());
    T r = 0;
    for (int i = size - 1; i >= 0; --i) {
      r = r * 4294967296 + t[i];
    }
    return r;
  }

  std::string ToString() const {
    const uint32_t output_mod = 1000000000;
    if (IsZero()) {
      return "0";
    }
    if (hi_.IsZero()) {
      return low_.ToString();
    }

    std::vector<uint32_t> bits32 = ToUInt32Vector();
    std::vector<uint32_t> mods;

    std::stringstream ss;
    int idx = bits32.size() - 1;
    while (bits32[idx] == 0) --idx;
    do {
      uint64 add = 0;
      for (int i = idx; i > 0; --i) {
        const uint64 x = add + bits32[i];
        const uint64 next_add = (x % output_mod) << 32;
        bits32[i] = static_cast<unsigned>(x / output_mod);
        add = next_add;
      }
      uint64 x = add + bits32[0];
      bits32[0] = static_cast<unsigned>(x / output_mod);
      mods.push_back(x % output_mod);
      while (idx >= 0 && bits32[idx] == 0) --idx;
    } while (idx >= 0);

    idx = static_cast<int>(mods.size()) - 1;
    char buff[32];
    sprintf(buff, "%u", mods[idx--]);
    ss << buff;
    for (; idx >= 0; --idx) {
      sprintf(buff, "%09u", mods[idx]);
      ss << buff;
    }
    return ss.str();
  }

  std::string to_string() const { return ToString(); }

  ExtendedUnsignedIntImpl Difference(
      const ExtendedUnsignedIntImpl& other) const {
    int t = CompareTo(other);
    if (t == 0) {
      return 0;
    }
    if (t > 0) {
      ET x = hi_ - other.hi_;
      ET y;
      if (low_ >= other.low_) {
        y = low_ - other.low_;
      } else {
        y = low_ - other.low_;
        --x;
      }
      return ExtendedUnsignedIntImpl(y, x);
    } else {
      ET x = other.hi_ - hi_;
      ET y;
      if (other.low_ >= low_) {
        y = other.low_ - low_;
      } else {
        y = other.low_ - low_;
        --x;
      }
      return ExtendedUnsignedIntImpl(y, x);
    }
  }

 public:
  // Operators
  ExtendedUnsignedIntImpl operator+() const { return *this; }

  ExtendedUnsignedIntImpl operator-() const {
    ExtendedUnsignedIntImpl ret(*this);
    FlipBits();
    AddOne();
    return ret;
  }

  ExtendedUnsignedIntImpl operator~() const {
    return ExtendedUnsignedIntImpl(~low_, ~hi_);
  }

  ExtendedUnsignedIntImpl& operator+=(const ExtendedUnsignedIntImpl& other) {
    if (IsZero()) {
      low_ = other.low();
      hi_ = other.hi();
      return *this;
    }

    if (!other.IsZero()) {
      ET x = other.low() + low_;
      ET y = other.hi() + hi_;
      if (!other.low().IsZero() && !low_.IsZero() &&
          (x < other.low() || x < low_)) {
        ++y;
      }
      low_ = x;
      hi_ = y;
    }
    return *this;
  }

  ExtendedUnsignedIntImpl& operator+=(const ET& other) {
    return *this += ExtendedUnsignedIntImpl(other);
  }

  template <typename T>
  REQUIRES((is_builtin_integer<T>::value))
  RETURN(ExtendedUnsignedIntImpl&) operator+=(const T& other) {
    return *this += ExtendedUnsignedIntImpl(other);
  }

  ExtendedUnsignedIntImpl& operator-=(const ExtendedUnsignedIntImpl& other) {
    if (other.IsZero()) {
      return *this;
    }

    if (IsZero()) {
      low_ = other.low();
      hi_ = other.hi();
      FlipBits();
      AddOne();
      return *this;
    }

    int t = CompareTo(other);
    if (t == 0) {
      low_.MakeZeroBits();
      hi_.MakeZeroBits();
      return *this;
    } else {
      ExtendedUnsignedIntImpl d = Difference(other);
      if (t < 0) {
        d.FlipBits();
        d.AddOne();
      }
      low_ = d.low_;
      hi_ = d.hi_;
    }

    return *this;
  }

  ExtendedUnsignedIntImpl& operator-=(const ET& other) {
    return *this -= ExtendedUnsignedIntImpl(other);
  }

  template <typename T>
  REQUIRES((is_builtin_integer<T>::value))
  RETURN(ExtendedUnsignedIntImpl&) operator-=(const T& other) {
    return *this -= ExtendedUnsignedIntImpl(other);
  }

  ExtendedUnsignedIntImpl& operator*=(const ExtendedUnsignedIntImpl& other) {
    if (IsZero() || other.IsZero()) {
      low_.MakeZeroBits();
      hi_.MakeZeroBits();
      return *this;
    }
    ET t[4];
    for (int i = 0; i < 4; ++i) {
      for (int j = 0; j + i < 4; ++j) {
        ET carry = GetQuarter(i) * other.GetQuarter(j);
        for (int now = i + j; now < 4; ++now) {
          ET x = ET(t[now]) + ET(carry.low());
          t[now] = x.low();
          carry = ET(x.hi()) + ET(carry.hi());
          if (carry.IsZero()) {
            break;
          }
        }
      }
    }
    low_ = t[0] | (t[1] << quarter_bitcount);
    hi_ = t[2] | (t[3] << quarter_bitcount);

    return *this;
  }

  ExtendedUnsignedIntImpl& operator*=(const ET& other) {
    return *this *= ExtendedUnsignedIntImpl(other);
  }

  template <typename T>
  REQUIRES((is_builtin_integer<T>::value))
  RETURN(ExtendedUnsignedIntImpl&) operator*=(const T& other) {
    return *this *= ExtendedUnsignedIntImpl(other);
  }

  ExtendedUnsignedIntImpl& operator/=(const ExtendedUnsignedIntImpl& other) {
    DivideInplace(*this, other);
    return *this;
  }

  ExtendedUnsignedIntImpl& operator/=(const ET& other) {
    return *this /= ExtendedUnsignedIntImpl(other);
  }

  template <typename T>
  REQUIRES((is_builtin_integer<T>::value))
  RETURN(ExtendedUnsignedIntImpl&) operator/=(const T& other) {
    return *this /= ExtendedUnsignedIntImpl(other);
  }

  ExtendedUnsignedIntImpl& operator%=(const ExtendedUnsignedIntImpl& other) {
    RemainInplace(*this, other);
    return *this;
  }

  ExtendedUnsignedIntImpl& operator%=(const ET& other) {
    return *this %= ExtendedUnsignedIntImpl(other);
  }

  template <typename T>
  REQUIRES((is_builtin_integer<T>::value))
  RETURN(ExtendedUnsignedIntImpl&) operator%=(const T& other) {
    return *this %= ExtendedUnsignedIntImpl(other);
  }

  ExtendedUnsignedIntImpl& operator&=(const ExtendedUnsignedIntImpl& other) {
    low_ &= other.low();
    hi_ &= other.hi();
    return *this;
  }

  template <typename T>
  REQUIRES((is_builtin_integer<T>::value))
  RETURN(ExtendedUnsignedIntImpl&) operator&=(const T& other) {
    return *this &= ExtendedUnsignedIntImpl(other);
  }

  ExtendedUnsignedIntImpl& operator&=(const ET& other) {
    return *this &= ExtendedUnsignedIntImpl(other);
  }

  ExtendedUnsignedIntImpl& operator^=(const ExtendedUnsignedIntImpl& other) {
    low_ ^= other.low();
    hi_ ^= other.hi();
    return *this;
  }

  ExtendedUnsignedIntImpl& operator^=(const ET& other) {
    return *this ^= ExtendedUnsignedIntImpl(other);
  }

  template <typename T>
  REQUIRES((is_builtin_integer<T>::value))
  RETURN(ExtendedUnsignedIntImpl&) operator^=(const T& other) {
    return *this ^= ExtendedUnsignedIntImpl(other);
  }

  ExtendedUnsignedIntImpl& operator|=(const ExtendedUnsignedIntImpl& other) {
    low_ |= other.low();
    hi_ |= other.hi();
    return *this;
  }

  ExtendedUnsignedIntImpl& operator|=(const ET& other) {
    return *this |= ExtendedUnsignedIntImpl(other);
  }

  template <typename T>
  REQUIRES((is_builtin_integer<T>::value))
  RETURN(ExtendedUnsignedIntImpl&) operator|=(const T& other) {
    return *this |= ExtendedUnsignedIntImpl(other);
  }

  ExtendedUnsignedIntImpl& operator>>=(int cnt) {
    ShiftRight(cnt);
    return *this;
  }

  ExtendedUnsignedIntImpl& operator<<=(int cnt) {
    ShiftLeft(cnt);
    return *this;
  }

  ExtendedUnsignedIntImpl& operator++() {
    AddOne();
    return *this;
  }

  ExtendedUnsignedIntImpl operator++(int) {
    ExtendedUnsignedIntImpl ret(*this);
    *this += 1;
    return ret;
  }

  ExtendedUnsignedIntImpl& operator--() {
    if (!low_.IsZero()) {
      --low_;
    } else {
      --low_;
      --hi_;
    }
    return *this;
  }

  ExtendedUnsignedIntImpl operator--(int) {
    ExtendedUnsignedIntImpl ret(*this);
    *this -= 1;
    return ret;
  }

 public:
  // All the binary operators are friend operators
  // Comparison operators
#if PE_HAS_CPP20
  friend inline int operator<=>(const ExtendedUnsignedIntImpl& l,
                                const ExtendedUnsignedIntImpl& r) {
    return l.CompareTo(r);
  }
  friend inline int operator==(const ExtendedUnsignedIntImpl& l,
                               const ExtendedUnsignedIntImpl& r) {
    return l.CompareTo(r) == 0;
  }
  friend inline int operator!=(const ExtendedUnsignedIntImpl& l,
                               const ExtendedUnsignedIntImpl& r) {
    return l.CompareTo(r) != 0;
  }
#else
  friend inline int operator<(const ExtendedUnsignedIntImpl& l,
                              const ExtendedUnsignedIntImpl& r) {
    return l.CompareTo(r) < 0;
  }
  friend inline int operator<=(const ExtendedUnsignedIntImpl& l,
                               const ExtendedUnsignedIntImpl& r) {
    return l.CompareTo(r) <= 0;
  }
  friend inline int operator>(const ExtendedUnsignedIntImpl& l,
                              const ExtendedUnsignedIntImpl& r) {
    return l.CompareTo(r) > 0;
  }
  friend inline int operator>=(const ExtendedUnsignedIntImpl& l,
                               const ExtendedUnsignedIntImpl& r) {
    return l.CompareTo(r) >= 0;
  }
  friend inline int operator==(const ExtendedUnsignedIntImpl& l,
                               const ExtendedUnsignedIntImpl& r) {
    return l.CompareTo(r) == 0;
  }
  friend inline int operator!=(const ExtendedUnsignedIntImpl& l,
                               const ExtendedUnsignedIntImpl& r) {
    return l.CompareTo(r) != 0;
  }
#endif
  friend inline ExtendedUnsignedIntImpl operator+(
      const ExtendedUnsignedIntImpl& l, const ExtendedUnsignedIntImpl& r) {
    ExtendedUnsignedIntImpl ret(l);
    ret += r;
    return ret;
  }
  friend inline ExtendedUnsignedIntImpl operator-(
      const ExtendedUnsignedIntImpl& l, const ExtendedUnsignedIntImpl& r) {
    ExtendedUnsignedIntImpl ret(l);
    ret -= r;
    return ret;
  }
  friend inline ExtendedUnsignedIntImpl operator*(
      const ExtendedUnsignedIntImpl& l, const ExtendedUnsignedIntImpl& r) {
    ExtendedUnsignedIntImpl ret(l);
    ret *= r;
    return ret;
  }
  friend inline ExtendedUnsignedIntImpl operator/(
      const ExtendedUnsignedIntImpl& l, const ExtendedUnsignedIntImpl& r) {
    ExtendedUnsignedIntImpl ret(l);
    ret /= r;
    return ret;
  }
  friend inline ExtendedUnsignedIntImpl operator%(
      const ExtendedUnsignedIntImpl& l, const ExtendedUnsignedIntImpl& r) {
    ExtendedUnsignedIntImpl ret(l);
    ret %= r;
    return ret;
  }
  friend inline ExtendedUnsignedIntImpl operator&(
      const ExtendedUnsignedIntImpl& l, const ExtendedUnsignedIntImpl& r) {
    ExtendedUnsignedIntImpl ret(l);
    ret &= r;
    return ret;
  }
  friend inline ExtendedUnsignedIntImpl operator^(
      const ExtendedUnsignedIntImpl& l, const ExtendedUnsignedIntImpl& r) {
    ExtendedUnsignedIntImpl ret(l);
    ret ^= r;
    return ret;
  }
  friend inline ExtendedUnsignedIntImpl operator|(
      const ExtendedUnsignedIntImpl& l, const ExtendedUnsignedIntImpl& r) {
    ExtendedUnsignedIntImpl ret(l);
    ret |= r;
    return ret;
  }
  friend inline ExtendedUnsignedIntImpl operator<<(
      const ExtendedUnsignedIntImpl& l, const int cnt) {
    ExtendedUnsignedIntImpl ret(l);
    ret <<= cnt;
    return ret;
  }
  friend inline ExtendedUnsignedIntImpl operator>>(
      const ExtendedUnsignedIntImpl& l, const int cnt) {
    ExtendedUnsignedIntImpl ret(l);
    ret >>= cnt;
    return ret;
  }
  friend inline std::ostream& operator<<(std::ostream& o,
                                         const ExtendedUnsignedIntImpl& n) {
    return o << n.ToString();
  }

 protected:
#if PE_IS_LITTLE_ENDIAN
  ET low_;
  ET hi_;
#else
  ET hi_;
  ET low_;
#endif
};

template <typename ET, bool is_builtin_integer>
SL int IsZero(const ExtendedUnsignedIntImpl<ET, is_builtin_integer>& x) {
  return x.IsZero();
}

template <typename ET, bool is_builtin_integer>
SL int IntSign(const ExtendedUnsignedIntImpl<ET, is_builtin_integer>& x) {
  return x.IntSign();
}

template <typename ET, bool is_builtin_integer>
SL int IsEven(const ExtendedUnsignedIntImpl<ET, is_builtin_integer>& x) {
  return x.IsEven();
}

template <typename ET, bool is_builtin_integer>
SL int IsOdd(const ExtendedUnsignedIntImpl<ET, is_builtin_integer>& x) {
  return x.IsOdd();
}

template <typename ET, bool is_builtin_integer>
SL unsigned int LowerBits(
    const ExtendedUnsignedIntImpl<ET, is_builtin_integer>& x) {
  return x.LowerBits();
}

template <typename ET, bool is_builtin_integer>
SL ExtendedUnsignedIntImpl<ET, is_builtin_integer> Abs(
    const ExtendedUnsignedIntImpl<ET, is_builtin_integer>& x) {
  return x;
}

template <typename ET, bool is_builtin_integer>
SL ExtendedUnsignedIntImpl<ET, is_builtin_integer> FAbs(
    const ExtendedUnsignedIntImpl<ET, is_builtin_integer>& x) {
  return x;
}

template <typename ET, bool is_builtin_integer>
SL int SameParity(const ExtendedUnsignedIntImpl<ET, is_builtin_integer>& l,
                  const ExtendedUnsignedIntImpl<ET, is_builtin_integer>& r) {
  return SameParity(l.LowerBits(), r.LowerBits());
}

template <typename ET, bool is_builtin_integer>
SL std::tuple<ExtendedUnsignedIntImpl<ET, is_builtin_integer>,
              ExtendedUnsignedIntImpl<ET, is_builtin_integer>>
Div(const ExtendedUnsignedIntImpl<ET, is_builtin_integer>& l,
    const ExtendedUnsignedIntImpl<ET, is_builtin_integer>& r) {
  ExtendedUnsignedIntImpl<ET, is_builtin_integer> remain;
  ExtendedUnsignedIntImpl<ET, is_builtin_integer> d(l);
  ExtendedUnsignedIntImpl<ET, is_builtin_integer>::DivideInplace(d, r, remain);
  return {d, remain};
}

template <typename T, typename ET, bool is_builtin_integer>
SL T ToInt(const ExtendedUnsignedIntImpl<ET, is_builtin_integer>& x) {
  return x.template ToInt<T>();
}

template <typename T, typename ET, bool is_builtin_integer>
SL T ToFloat(const ExtendedUnsignedIntImpl<ET, is_builtin_integer>& x) {
  return x.template ToFloat<T>();
}

template <typename ET, bool is_builtin_integer>
SL std::string ToString(
    const ExtendedUnsignedIntImpl<ET, is_builtin_integer>& x) {
  return x.ToString();
}

template <typename ET, bool is_builtin_integer>
SL std::string to_string(
    const ExtendedUnsignedIntImpl<ET, is_builtin_integer>& x) {
  return ToString(x);
}

template <typename ET, bool is_builtin_integer, typename T2>
SL REQUIRES((pe::is_builtin_integer<T2>::value))
    RETURN(ExtendedUnsignedIntImpl<ET, is_builtin_integer>)
        Power(ExtendedUnsignedIntImpl<ET, is_builtin_integer> x, T2 n) {
  PE_ASSERT(n >= 0);
  ExtendedUnsignedIntImpl<ET, is_builtin_integer> ret = 1;
  for (; n > 0; n >>= 1) {
    if (n & 1) ret *= x;
    if (n > 1) x *= x;
  }
  return ret;
}

template <typename ET, bool is_builtin_integer, typename T2>
SL REQUIRES((pe::is_builtin_integer<T2>::value))
    RETURN(ExtendedUnsignedIntImpl<ET, is_builtin_integer>)
        PowerMod(ExtendedUnsignedIntImpl<ET, is_builtin_integer> x, T2 n,
                 const ExtendedUnsignedIntImpl<ET, is_builtin_integer>& mod) {
  PE_ASSERT(n >= 0);
  ExtendedUnsignedIntImpl<ET, is_builtin_integer> ret = 1;
  for (; n > 0; n >>= 1) {
    if (n & 1) ret = ret * x % mod;
    if (n > 1) x = x * x % mod;
  }
  return ret;
}

template <typename ET, bool is_builtin_integer, typename T2, typename T3>
SL REQUIRES((pe::is_builtin_integer<T2>::value &&
             pe::is_builtin_integer<T3>::value))
    RETURN(ExtendedUnsignedIntImpl<ET, is_builtin_integer>)
        PowerMod(ExtendedUnsignedIntImpl<ET, is_builtin_integer> x, T2 n,
                 T3 mod) {
  PE_ASSERT(n >= 0);
  ExtendedUnsignedIntImpl<ET, is_builtin_integer> ret = 1;
  for (; n > 0; n >>= 1) {
    if (n & 1) ret = ret * x % mod;
    if (n > 1) x = x * x % mod;
  }
  return ret;
}

template <typename ET>
using ExtendedUnsignedInt =
    ExtendedUnsignedIntImpl<typename ExtractET<ET>::type,
                            is_builtin_integer<ET>::value>;

#if PE_HAS_CPP20
static_assert(PeNumberUtil<ExtendedUnsignedInt<uint64>>);
#if PE_HAS_INT128
static_assert(PeNumberUtil<ExtendedUnsignedInt<uint128>>);
#endif
#endif
}  // namespace pe

#endif
