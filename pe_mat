#ifndef PE_MAT_
#define PE_MAT_

#include "pe_base"
#include "pe_type_traits"
#include "pe_mod"

template <typename T, int D>
SL void MatMulMat(T (*a)[D], T (*b)[D], T (*c)[D], int N = D) {
  for (int i = 0; i < N; ++i) {
    for (int j = 0; j < N; ++j) {
      T s = 0;
      for (int k = 0; k < N; ++k) {
        s += a[i][k] * b[k][j];
      }
      c[i][j] = s;
    }
  }
}

template <typename T>
SL void MatMulMat(T* aa, T* bb, T* cc, int N) {
  for (int i = 0; i < N; ++i) {
    for (int j = 0; j < N; ++j) {
      T* a = aa + i * N;
      T* c = cc + i * N;
      T s = 0;
      for (int k = 0; k < N; ++k) {
        s += a[k] * (bb + k * N)[j];
      }
      c[j] = s;
    }
  }
}

template <typename T, int D>
SL void MatMulVec(T (*a)[D], T (*b)[D], T (*c)[D], int N = D) {
  for (int i = 0; i < N; ++i) {
    T s = 0;
    for (int k = 0; k < N; ++k) {
      s += a[i][k] * b[k][0];
    }
    c[i][0] = s;
  }
}

template <typename T, int D>
SL void MatMulVec(T (*a)[D], T* b, T* c, int N = D) {
  for (int i = 0; i < N; ++i) {
    T s = 0;
    for (int k = 0; k < N; ++k) {
      s += a[i][k] * b[k];
    }
    c[i] = s;
  }
}

template <typename T>
SL void MatMulVec(T* aa, T* b, T* c, int N) {
  for (int i = 0; i < N; ++i) {
    T* a = aa + i * N;
    T s = 0;
    for (int k = 0; k < N; ++k) {
      s += a[k] * b[k];
    }
    c[i] = s;
  }
}

template <typename T, int D>
SL void MatMulMatMod(T (*a)[D], T (*b)[D], T (*c)[D], int64 mod, int N = D) {
  for (int i = 0; i < N; ++i) {
    for (int j = 0; j < N; ++j) {
      int64 s = 0;
      for (int k = 0; k < N; ++k) {
        s += MulMod(a[i][k], b[k][j], mod);
        if (s >= mod) {
          s -= mod;
        }
      }
      c[i][j] = s % mod;
    }
  }
}

template <typename T>
SL void MatMulMatMod(T* aa, T* bb, T* cc, int64 mod, int N) {
  for (int i = 0; i < N; ++i) {
    for (int j = 0; j < N; ++j) {
      T* a = aa + i * N;
      T* c = cc + i * N;
      int64 s = 0;
      for (int k = 0; k < N; ++k) {
        s += MulMod(a[k], (bb + k * N)[j], mod);
        if (s >= mod) {
          s -= mod;
        }
      }
      c[j] = s % mod;
    }
  }
}

template <typename T, int D>
SL void MatMulVecMod(T (*a)[D], T (*b)[D], T (*c)[D], int64 mod, int N = D) {
  for (int i = 0; i < N; ++i) {
    int64 s = 0;
    for (int k = 0; k < N; ++k) {
      s += MulMod(a[i][k], b[k][0], mod);
      if (s >= mod) {
        s -= mod;
      }
    }
    c[i][0] = s;
  }
}

template <typename T, int D>
SL void MatMulVecMod(T (*a)[D], T* b, T* c, int64 mod, int N = D) {
  for (int i = 0; i < N; ++i) {
    int64 s = 0;
    for (int k = 0; k < N; ++k) {
      s += MulMod(a[i][k], b[k], mod);
      if (s >= mod) {
        s -= mod;
      }
    }
    c[i] = s;
  }
}

template <typename T>
SL void MatMulVecMod(T* aa, T* b, T* c, int64 mod, int N) {
  for (int i = 0; i < N; ++i) {
    T* a = aa + i * N;
    int64 s = 0;
    for (int k = 0; k < N; ++k) {
      s += MulMod(a[k], b[k], mod);
      if (s >= mod) {
        s -= mod;
      }
    }
    c[i] = s;
  }
}

template <typename T, int C = -1>
struct PeMatrixStorage {
  PeMatrixStorage(T* data, const int r, const int c)
      : data_(data), own_(0), r_(r) {
    PE_ASSERT(c == C);
  }

  PeMatrixStorage(const int r, const int c) : own_(1), r_(r) {
    PE_ASSERT(c == C);
    data_ = new T[r_ * C];
  }

  PeMatrixStorage(const int r, const int c, T v) : own_(1), r_(r) {
    PE_ASSERT(c == C);
    data_ = new T[r_ * C];
    std::fill(data_, data_ + r_ * C, v);
  }

  PeMatrixStorage(const PeMatrixStorage& storage)
      : PeMatrixStorage(storage.r_, storage.column()) {
    PE_ASSERT(storage.column() == C);
    std::copy(storage.data_, storage.data_ + r_ * C, data_);
  }

  PeMatrixStorage(PeMatrixStorage&& storage) noexcept
      : data_(storage.data_), own_(storage.own_), r_(storage.r_) {
    PE_ASSERT(storage.column() == C);
    storage.own_ = 0;
  }

  PeMatrixStorage& operator=(PeMatrixStorage& storage) {
    if (&storage != this) {
      Release();
      ::new (this) PeMatrixStorage(storage);
    }
    return *this;
  }

  PeMatrixStorage& operator=(PeMatrixStorage&& storage) noexcept {
    if (&storage != this) {
      Release();
      ::new (this) PeMatrixStorage(std::move(storage));
    }
    return *this;
  }

  template <int C1>
  PeMatrixStorage(const PeMatrixStorage<T, C1>& storage)
      : PeMatrixStorage(storage.row(), storage.column()) {
    PE_ASSERT(storage.column() == C);
    std::copy(storage.data(), storage.data() + r_ * C, data_);
  }

  template <int C1>
  PeMatrixStorage(PeMatrixStorage<T, C1>&& storage)
      : data_(storage.data()), own_(storage.own()), r_(storage.row()) {
    PE_ASSERT(storage.column() == C);
    storage.set_own(0);
  }

  template <int C1>
  PeMatrixStorage& operator=(PeMatrixStorage<T, C1>& storage) {
    if (&storage != this) {
      Release();
      ::new (this) PeMatrixStorage(storage);
    }
    return *this;
  }

  template <int C1>
  PeMatrixStorage& operator=(PeMatrixStorage<T, C1>&& storage) {
    if (&storage != this) {
      Release();
      ::new (this) PeMatrixStorage(std::move(storage));
    }
    return *this;
  }

  ~PeMatrixStorage() { Release(); }

  void Release() {
    if (own_) {
      delete[] data_;
    }
  }

  const int row() const { return r_; }

  const int column() const { return C; }

  T* data() { return data_; }

  T& at(const int x, const int y) { return at(data_, x, y); }

  T& at(T* data, const int x, const int y) { return data[x * column() + y]; }

  const T& at(const T* data, const int x, const int y) const {
    return data[x * column() + y];
  }

  const int own() const { return own_; }

  void set_own(int own) { own_ = own; }

 private:
  T* data_;
  int own_;
  int r_;
};

template <typename T>
struct PeMatrixStorage<T, -1> {
  PeMatrixStorage(T* data, const int r, const int c)
      : data_(data), own_(0), r_(r), c_(c) {}

  PeMatrixStorage(const int r, const int c) : own_(1), r_(r), c_(c) {
    data_ = new T[r_ * c_];
  }

  PeMatrixStorage(const int r, const int c, T v) : own_(1), r_(r), c_(c) {
    data_ = new T[r_ * c_];
    std::fill(data_, data_ + r_ * c_, v);
  }

  PeMatrixStorage(const PeMatrixStorage& storage)
      : PeMatrixStorage(storage.r_, storage.column()) {
    std::copy(storage.data_, storage.data_ + r_ * c_, data_);
  }

  PeMatrixStorage(PeMatrixStorage&& storage) noexcept
      : data_(storage.data_),
        own_(storage.own_),
        r_(storage.r_),
        c_(storage.column()) {
    storage.own_ = 0;
  }

  PeMatrixStorage& operator=(PeMatrixStorage& storage) {
    if (&storage != this) {
      Release();
      ::new (this) PeMatrixStorage(storage);
    }
    return *this;
  }

  PeMatrixStorage& operator=(PeMatrixStorage&& storage) noexcept {
    if (&storage != this) {
      Release();
      ::new (this) PeMatrixStorage(std::move(storage));
    }
    return *this;
  }

  template <int C>
  PeMatrixStorage(PeMatrixStorage<T, C>&& storage)
      : data_(storage.data()),
        own_(storage.own()),
        r_(storage.row()),
        c_(storage.column()) {
    storage.set_own(0);
  }

  template <int C>
  PeMatrixStorage(const PeMatrixStorage<T, C>& storage)
      : PeMatrixStorage(storage.row(), storage.column()) {
    std::copy(storage.data(), storage.data() + r_ * c_, data_);
  }

  template <int C>
  PeMatrixStorage& operator=(PeMatrixStorage<T, C>& storage) {
    Release();
    ::new (this) PeMatrixStorage(storage);
    return *this;
  }

  template <int C>
  PeMatrixStorage& operator=(PeMatrixStorage<T, C>&& storage) {
    Release();
    ::new (this) PeMatrixStorage(std::move(storage));
    return *this;
  }

  ~PeMatrixStorage() { Release(); }

  void Release() {
    if (own_) {
      delete[] data_;
    }
  }

  const int row() const { return r_; }

  const int column() const { return c_; }

  T* data() { return data_; }

  T& at(const int x, const int y) { return at(data_, x, y); }

  T& at(T* data, const int x, const int y) { return data[x * column() + y]; }

  const T& at(const T* data, const int x, const int y) const {
    return data[x * column() + y];
  }

  const int own() const { return own_; }

  void set_own(int own) { own_ = own; }

 private:
  T* data_;
  int own_;
  int r_;
  int c_;
};

static const struct MatrixNoInit {
} matrix_no_init;

template <typename T, int C = -1>
struct PeMatrix {
  PeMatrix(const int r, const int c, MatrixNoInit)
      : storage_(r, c), row_(r), col_(c) {
    data_ = storage_.data();
    if (C != -1) {
      PE_ASSERT(C == c);
    }
  }

  PeMatrix(const int r, const int c, T v = T())
      : storage_(r, c, v), row_(r), col_(c) {
    data_ = storage_.data();
    if (C != -1) {
      PE_ASSERT(C == c);
    }
  }

  PeMatrix(T* data, const int r, const int c)
      : storage_(data, r, c), row_(r), col_(c) {
    data_ = storage_.data();
    if (C != -1) {
      PE_ASSERT(C == c);
    }
  }

  template <int D>
  PeMatrix(T (*a)[D], const int r, const int c)
      : storage_(&a[0][0], r, D), row_(r), col_(c) {
    data_ = storage_.data();
    if (C != -1) {
      PE_ASSERT(C == c);
    }
  }

  PeMatrix(const PeMatrix& mat)
      : storage_(mat.storage_), row_(mat.row()), col_(mat.col()) {
    data_ = storage_.data();
  }

  PeMatrix(PeMatrix&& mat) noexcept
      : storage_(std::move(mat.storage_)), row_(mat.row()), col_(mat.col()) {
    data_ = storage_.data();
  }

  PeMatrix& operator=(PeMatrix& mat) {
    if (&mat != this) {
      storage_.Release();
      new (this) PeMatrix(mat);
    }
    return *this;
  }

  PeMatrix& operator=(PeMatrix&& mat) noexcept {
    if (&mat != this) {
      storage_.Release();
      new (this) PeMatrix(std::move(mat));
    }
    return *this;
  }

  template <int C1>
  PeMatrix(const PeMatrix<T, C1>& mat)
      : storage_(mat.storage()), row_(mat.row()), col_(mat.col()) {
    data_ = storage_.data();
  }

  template <int C1>
  PeMatrix(PeMatrix<T, C1>&& mat)
      : storage_(std::move(mat.storage())), row_(mat.row()), col_(mat.col()) {
    data_ = storage_.data();
  }

  template <int C1>
  PeMatrix& operator=(PeMatrix<T, C1>& mat) {
    storage_.Release();
    new (this) PeMatrix(mat);
    return *this;
  }

  template <int C1>
  PeMatrix& operator=(PeMatrix<T, C1>&& mat) {
    storage_.Release();
    new (this) PeMatrix(std::move(mat));
    return *this;
  }

  ~PeMatrix() = default;

  T& at(const int x, const int y) { return storage_.at(data_, x, y); }

  const T& at(const int x, const int y) const {
    return storage_.at(data_, x, y);
  }

  T& operator()(const int x, const int y) { return storage_.at(data_, x, y); }

  const T& operator()(const int x, const int y) const {
    return storage_.at(data_, x, y);
  }

  const int row() const { return row_; }

  const int col() const { return col_; }

  const PeMatrixStorage<T, C>& storage() const { return storage_; }

  PeMatrixStorage<T, C>& storage() { return storage_; }

  PeMatrix& FillValue(const T v = T()) {
    for (int i = 0; i < row_; ++i) {
      for (int j = 0; j < col_; ++j) {
        at(i, j) = v;
      }
    }
    return *this;
  }

 private:
  PeMatrixStorage<T, C> storage_;
  T* data_;
  int row_;
  int col_;
};

template <typename T, int C = -1>
SL ostream& operator<<(ostream& o, const PeMatrix<T, C>& mat) {
  o << "{";
  const int row = mat.row();
  const int col = mat.col();
  for (int i = 0; i < row; ++i) {
    if (i > 0) {
      o << "\n";
    }
    o << "{";
    for (int j = 0; j < col; ++j) {
      if (j > 0) {
        o << ", ";
      }
      o << mat(i, j);
    }
    o << "}";
  }
  o << "}";
  return o;
}

template <typename T, int C1, int C2>
SL REQUIRES((!IsNModNumber<T>::value)) RETURN(PeMatrix<T, -1>)
    MatrixMul(const PeMatrix<T, C1>& m1, const PeMatrix<T, C2>& m2) {
  PE_ASSERT(m1.col() == m2.row());
  const int r = m1.row();
  const int cr = m1.col();
  const int c = m2.col();
  PeMatrix<T, -1> result(r, c, matrix_no_init);
#if ENABLE_OPENMP
#pragma omp parallel for schedule(dynamic, 70) num_threads(8)
#endif
  for (int i = 0; i < r; ++i) {
    for (int j = 0; j < c; ++j) {
      T s = 0;
      for (int k = 0; k < cr; ++k) {
        s += m1(i, k) * m2(k, j);
      }
      result(i, j) = s;
    }
  }
  return result;
}

template <typename T, int C1, int C2>
SL REQUIRES((IsNModNumber<T>::value && IsNModNumberCCModOrGlobalMod<T>::value))
    RETURN(PeMatrix<T, -1>)
        MatrixMul(const PeMatrix<T, C1>& m1, const PeMatrix<T, C2>& m2) {
  PE_ASSERT(m1.col() == m2.row());
  const int r = m1.row();
  const int cr = m1.col();
  const int c = m2.col();
  PeMatrix<T, -1> result(r, c, matrix_no_init);
#if ENABLE_OPENMP
#pragma omp parallel for schedule(dynamic, 70) num_threads(8)
#endif
  for (int i = 0; i < r; ++i) {
    for (int j = 0; j < c; ++j) {
      T s = 0;
      for (int k = 0; k < cr; ++k) {
        s += m1(i, k) * m2(k, j);
      }
      ModValueFixer<T>::Fix(s);
      result(i, j) = s;
    }
  }
  return result;
}

template <typename T, int C1, int C2>
SL REQUIRES((IsNModNumber<T>::value && !IsNModNumberCCModOrGlobalMod<T>::value))
    RETURN(PeMatrix<T, -1>)
        MatrixMul(const PeMatrix<T, C1>& m1, const PeMatrix<T, C2>& m2) {
  PE_ASSERT(m1.col() == m2.row());
  const int r = m1.row();
  const int cr = m1.col();
  const int c = m2.col();
  PeMatrix<T, -1> result(r, c, matrix_no_init);
  for (int i = 0; i < r; ++i) {
    for (int j = 0; j < c; ++j) {
      T s = 0;
      for (int k = 0; k < cr; ++k) {
        s += m1(i, k) * m2(k, j);
      }
      ModValueFixer<T>::Fix(s);
      result(i, j) = s;
    }
  }
  return result;
}

template <typename T, int C1, int C2>
SL REQUIRES((is_native_integer<T>::value)) RETURN(PeMatrix<T, -1>)
    MatrixMul(const PeMatrix<T, C1>& m1, const PeMatrix<T, C2>& m2, T mod) {
  PE_ASSERT(m1.col() == m2.row());
  const int r = m1.row();
  const int cr = m1.col();
  const int c = m2.col();
  PeMatrix<T, -1> result(r, c, matrix_no_init);
#if ENABLE_OPENMP
#pragma omp parallel for schedule(dynamic, 70) num_threads(8)
#endif
  for (int i = 0; i < r; ++i) {
    for (int j = 0; j < c; ++j) {
      T s = 0;
      for (int k = 0; k < cr; ++k) {
        s += MulModEx(m1(i, k), m2(k, j), mod);
      }
      result(i, j) = s % mod;
    }
  }
  return result;
}

template <typename T, int C1, int C2>
SL REQUIRES((!is_native_integer<T>::value)) RETURN(PeMatrix<T, -1>)
    MatrixMul(const PeMatrix<T, C1>& m1, const PeMatrix<T, C2>& m2, T mod) {
  PE_ASSERT(m1.col() == m2.row());
  const int r = m1.row();
  const int cr = m1.col();
  const int c = m2.col();
  PeMatrix<T, -1> result(r, c, matrix_no_init);
#if ENABLE_OPENMP
#pragma omp parallel for schedule(dynamic, 70) num_threads(8)
#endif
  for (int i = 0; i < r; ++i) {
    for (int j = 0; j < c; ++j) {
      T s = 0;
      for (int k = 0; k < cr; ++k) {
        s += m1(i, k) * m2(k, j) % mod;
      }
      result(i, j) = s % mod;
    }
  }
  return result;
}

template <typename T, int C>
SL REQUIRES((!IsNModNumber<T>::value)) RETURN(vector<T>)
    MatrixMulVec(const PeMatrix<T, C>& m1, const vector<T>& m2) {
  PE_ASSERT(m1.col() == m2.size());
  const int r = m1.row();
  const int cr = m1.col();
  vector<T> result(r);
  for (int i = 0; i < r; ++i) {
    T s = 0;
    for (int k = 0; k < cr; ++k) {
      s += m1(i, k) * m2[k];
    }
    result[i] = s;
  }
  return result;
}

template <typename T, int C>
SL REQUIRES((IsNModNumber<T>::value)) RETURN(vector<T>)
    MatrixMulVec(const PeMatrix<T, C>& m1, const vector<T>& m2) {
  PE_ASSERT(m1.col() == m2.size());
  const int r = m1.row();
  const int cr = m1.col();
  vector<T> result(r);
  for (int i = 0; i < r; ++i) {
    T s = 0;
    for (int k = 0; k < cr; ++k) {
      s += m1(i, k) * m2[k];
    }
    ModValueFixer<T>::Fix(s);
    result[i] = s;
  }
  return result;
}

template <typename T, int C>
SL REQUIRES((is_native_integer<T>::value)) RETURN(vector<T>)
    MatrixMulVec(const PeMatrix<T, C>& m1, const vector<T>& m2, T mod) {
  PE_ASSERT(m1.col() == m2.size());
  const int r = m1.row();
  const int cr = m1.col();
  vector<T> result(r);
  for (int i = 0; i < r; ++i) {
    T s = 0;
    for (int k = 0; k < cr; ++k) {
      s += MulModEx(m1(i, k), m2[k], mod);
    }
    result[i] = s % mod;
  }
  return result;
}

template <typename T, int C>
SL REQUIRES((!is_native_integer<T>::value)) RETURN(vector<T>)
    MatrixMulVec(const PeMatrix<T, C>& m1, const vector<T>& m2, T mod) {
  PE_ASSERT(m1.col() == m2.size());
  const int r = m1.row();
  const int cr = m1.col();
  vector<T> result(r);
  for (int i = 0; i < r; ++i) {
    T s = 0;
    for (int k = 0; k < cr; ++k) {
      s += m1(i, k) * m2[k] % mod;
    }
    result[i] = s % mod;
  }
  return result;
}

template <typename T, int C>
SL PeMatrix<T, -1> MatrixPower(const PeMatrix<T, C>& m, int64 n) {
  const int r = m.row();
  const int c = m.col();

  PE_ASSERT(n >= 0);
  PE_ASSERT(r == c);

  PeMatrix<T, -1> result(r, r);
  PeMatrix<T, C> t(m);

  const T ONE = 1;
  for (int i = 0; i < r; ++i) {
    result(i, i) = ONE;
  }

  for (; n; n >>= 1) {
    if (n & 1) {
      result = MatrixMul(t, result);
    }
    if (n > 1) {
      t = MatrixMul(t, t);
    }
  }

  return result;
}

template <typename T, int C>
SL PeMatrix<T, -1> MatrixPower(const PeMatrix<T, C>& m, int64 n, T mod) {
  const int r = m.row();
  const int c = m.col();

  PE_ASSERT(n >= 0);
  PE_ASSERT(r == c);

  PeMatrix<T, -1> result(r, r);
  PeMatrix<T, C> t(m);

  const T ONE = 1;
  for (int i = 0; i < r; ++i) {
    result(i, i) = ONE;
  }

  for (; n; n >>= 1) {
    if (n & 1) {
      result = MatrixMul(t, result, mod);
    }
    if (n > 1) {
      t = MatrixMul(t, t, mod);
    }
  }

  return result;
}

template <typename T, int C>
SL vector<T> MatrixPower(const PeMatrix<T, C>& m, int64 n, const vector<T>& v) {
  const int r = m.row();
  const int c = m.col();

  PE_ASSERT(n >= 0);
  PE_ASSERT(r == c);
  PE_ASSERT(r == v.size());

  vector<T> result(v);
  PeMatrix<T, C> t(m);

  for (; n; n >>= 1) {
    if (n & 1) {
      result = MatrixMulVec(t, result);
    }
    if (n > 1) {
      t = MatrixMul(t, t);
    }
  }

  return result;
}

template <typename T, int C>
SL vector<T> MatrixPower(const PeMatrix<T, C>& m, int64 n, const vector<T>& v,
                         T mod) {
  const int r = m.row();
  const int c = m.col();

  PE_ASSERT(n >= 0);
  PE_ASSERT(r == c);
  PE_ASSERT(r == v.size());

  vector<T> result(v);
  PeMatrix<T, C> t(m);

  for (; n; n >>= 1) {
    if (n & 1) {
      result = MatrixMulVec(t, result, mod);
    }
    if (n > 1) {
      t = MatrixMul(t, t, mod);
    }
  }

  return result;
}

// Helper method for matrix multiplication
// 1. Compiling time mod version.
// 2. Customized element type version. The mod is associated with element type.
// It is also possible that element type has no mod associated with.
// 3. Explicit runtime mod version: use int128 (if available) or
// NModNumber<DefaultMod> (slow).
//
// For pe implementation:
// If ENABLE_OPENMP, multi-thread implementation is not applied if the element
// type is NModNumber other than CCMod and DefaultMod.
//
// For eigen implementation:
// If the element type is NModNumber other than CCMod and DefaultMod, the caller
// should guarantee Eigen::nbThreads() == 1. (Call Eigen::setNbThreads(1))
//
// For both implementations:
// The caller is responsible for keeping DefaultMod thread-safe. In another
// words, it is not modified when MatrixPowerMod is running.
//
// See example/matrix_power.c.
// Version 1:
// auto res0 = MatrixPowerMod<1000000007>(
//     [=](auto& m) {
//       m(0, 0) = 1;
//       m(0, 1) = 1;
//       m(1, 0) = 1;
//     },
//     2, 100000);
// auto res1 = MatrixPowerMod<1000000007>(
//     [=](auto& m, auto& v) {
//       m(0, 0) = 1;
//       m(0, 1) = 1;
//       m(1, 0) = 1;
//       v[0] = 1;
//       v[1] = 1;
//     },
//     2, 100000);
// Version 2:
// auto res0 = MatrixPowerMod<NMod64<1000000007>>(
//     [=](auto& m) {
//       m(0, 0) = 1;
//       m(0, 1) = 1;
//       m(1, 0) = 1;
//     },
//     2, 100000);
// auto res1 = MatrixPowerMod<NMod64<1000000007>>(
//     [=](auto& m, auto& v) {
//       m(0, 0) = 1;
//       m(0, 1) = 1;
//       m(1, 0) = 1;
//       v[0] = 1;
//       v[1] = 1;
//     },
//     2, 100000);
// Version 3:
// auto res0 = MatrixPowerMod(
//     [=](auto& m) {
//       m(0, 0) = 1;
//       m(0, 1) = 1;
//       m(1, 0) = 1;
//     },
//     2, 100000, 1000000007);
// auto res1 = MatrixPowerMod(
//     [=](auto& m, auto& v) {
//       m(0, 0) = 1;
//       m(0, 1) = 1;
//       m(1, 0) = 1;
//       v[0] = 1;
//       v[1] = 1;
//     },
//     2, 100000, 1000000007);

// Version 1
// Mod is specified explicitly at compiling time.
template <int64 mod>
SL PeMatrix<int64> MatrixPowerModPe(
    const function<void(PeMatrix<NMod64<mod>>& mat)>& init, const int K,
    int64 n) {
  using T = NMod64<mod>;
  using MatrixT = PeMatrix<T>;

  MatrixT m(K, K);

  init(m);

  auto t = MatrixPower(m, n);

  PeMatrix<int64> res(K, K);
  for (int i = 0; i < K; ++i) {
    for (int j = 0; j < K; ++j) {
      res(i, j) = t(i, j).value();
    }
  }

  return res;
}

template <int64 mod>
SL vector<int64> MatrixPowerModPe(
    const function<void(PeMatrix<NMod64<mod>>& mat, vector<NMod64<mod>>& v)>&
        init,
    const int K, int64 n) {
  using T = NMod64<mod>;
  using MatrixT = PeMatrix<T>;

  vector<T> v(K, 0);
  MatrixT m(K, K);  // zero initialized

  init(m, v);

  auto t = MatrixPower(m, n, v);

  vector<int64> res(K, 0);
  for (int i = 0; i < K; ++i) {
    res[i] = t[i].value();
  }

  return res;
}

// Version 2
// Mod is associated with T at compiling time or runtime.
template <typename T>
SL REQUIRES((IsNModNumber<T>::value)) RETURN(PeMatrix<T>)
    MatrixPowerModPe(const function<void(PeMatrix<T>& mat)>& init, const int K,
                     int64 n) {
  using MatrixT = PeMatrix<T>;

  MatrixT m(K, K);

  init(m);

  return MatrixPower(m, n);
}

template <typename T>
SL REQUIRES((IsNModNumber<T>::value)) RETURN(vector<T>)
    MatrixPowerModPe(const function<void(PeMatrix<T>& mat, vector<T>& v)>& init,
                     const int K, int64 n) {
  using MatrixT = PeMatrix<T>;

  vector<T> v(K, 0);
  MatrixT m(K, K);

  init(m, v);

  return MatrixPower(m, n, v);
}

// Version 3
// Mod is specified at runtime.
#if PE_HAS_INT128
SL PeMatrix<int64> MatrixPowerModPe(
    const function<void(PeMatrix<int128>& mat)>& init, const int K, int64 n,
    int64 mod) {
  using T = int128;
  using MatrixT = PeMatrix<T>;

  MatrixT m(K, K);

  init(m);

  auto t = MatrixPower<int128>(m, n, mod);

  PeMatrix<int64> res(K, K);
  for (int i = 0; i < K; ++i) {
    for (int j = 0; j < K; ++j) {
      res(i, j) = static_cast<int64>(t(i, j));
    }
  }

  return res;
}

SL vector<int64> MatrixPowerModPe(
    const function<void(PeMatrix<int128>& mat, vector<int128>& v)>& init,
    const int K, int64 n, int64 mod) {
  using T = int128;
  using MatrixT = PeMatrix<T>;

  vector<T> v(K, 0);
  MatrixT m(K, K);

  init(m, v);

  auto t = MatrixPower<int128>(m, n, v, mod);

  vector<int64> res(K, 0);
  for (int i = 0; i < K; ++i) {
    res[i] = t[i];
  }

  return res;
}
#else
// mod == DefaultMod::mod()
SL PeMatrix<int64> MatrixPowerModPe(
    const function<void(PeMatrix<NModNumber<DefaultMod>>& mat)>& init,
    const int K, int64 n, int64 mod) {
  using T = NModNumber<DefaultMod>;
  using MatrixT = PeMatrix<T>;

  DefaultMod::Set(mod);
  PE_ASSERT(mod == DefaultMod::Mod());

  MatrixT m(K, K);

  init(m);

  auto t = MatrixPower(m, n);

  PeMatrix<int64> res(K, K);
  for (int i = 0; i < K; ++i)
    for (int j = 0; j < K; ++j) {
      res(i, j) = static_cast<int64>(t(i, j).value());
    }

  return res;
}
// mod == DefaultMod::mod()
SL vector<int64> MatrixPowerModPe(
    const function<void(PeMatrix<NModNumber<DefaultMod>>& mat,
                        vector<NModNumber<DefaultMod>>& v)>& init,
    const int K, int64 n, int64 mod) {
  using T = NModNumber<DefaultMod>;
  using MatrixT = PeMatrix<T>;

  DefaultMod::Set(mod);
  PE_ASSERT(mod == DefaultMod::Mod());

  vector<T> v(K, 0);
  MatrixT m(K, K);

  init(m, v);

  auto t = MatrixPower(m, n, v);

  vector<int64> res(K, 0);
  for (int i = 0; i < K; ++i) {
    res[i] = t[i].value();
  }

  return res;
}
#endif  // end PE_HAS_INT128

#if ENABLE_EIGEN

template <typename T>
using EigenMatrix = Eigen::Matrix<T, Eigen::Dynamic, Eigen::Dynamic>;

template <typename T>
struct NormalMatrixModFixer {
  static void Fix(EigenMatrix<T>& m, const int64 mod) {
    const auto r = m.rows();
    const auto c = m.cols();
    for (int i = 0; i < r; ++i) {
      for (int j = 0; j < c; ++j) {
        m(i, j) = RegulateMod(m(i, j), mod);
      }
    }
  }
};

template <typename T>
struct NModEigenMatrixModFixer {
  static void Fix(EigenMatrix<T>& m) {}
};

template <typename MC, typename S>
struct NModEigenMatrixModFixer<NModNumber<MC, APSBL<S>>> {
  static void Fix(EigenMatrix<NModNumber<MC, APSBL<S>>>& m) {
    const auto r = m.rows();
    const auto c = m.cols();
    for (int i = 0; i < r; ++i) {
      for (int j = 0; j < c; ++j) {
        m(i, j).FixValue();
      }
    }
  }
};

template <typename MC, typename S>
struct NModEigenMatrixModFixer<NModNumberM<MC, APSBL<S>>> {
  static void Fix(EigenMatrix<NModNumberM<MC, APSBL<S>>>& m) {
    const auto r = m.rows();
    const auto c = m.cols();
    for (int i = 0; i < r; ++i) {
      for (int j = 0; j < c; ++j) {
        m(i, j).FixValue();
      }
    }
  }
};

template <typename T>
SL EigenMatrix<T> MatrixPower(const EigenMatrix<T>& x, int64 n) {
  using MatrixT = EigenMatrix<T>;

  PE_ASSERT(n >= 0);
  if (IsNModNumber<T>::value && !IsNModNumberCCModOrGlobalMod<T>::value) {
    PE_ASSERT(Eigen::nbThreads() == 1);
  }

  const int K = static_cast<int>(x.rows());

  MatrixT e = MatrixT::Identity(K, K);
  MatrixT y = x;

  for (; n; n >>= 1) {
    // cout << "n = " << n << endl;
    if (n & 1) {
      e *= y;
      NModEigenMatrixModFixer<T>::Fix(e);
    }
    if (n > 1) {
      y *= y;
      NModEigenMatrixModFixer<T>::Fix(y);
    }
  }
  return e;
}

template <typename T>
SL EigenMatrix<T> MatrixPower(const EigenMatrix<T>& x, int64 n, int64 mod) {
  using MatrixT = EigenMatrix<T>;

  PE_ASSERT(n >= 0);
  if (IsNModNumber<T>::value && !IsNModNumberCCModOrGlobalMod<T>::value) {
    PE_ASSERT(Eigen::nbThreads() == 1);
  }

  const int K = x.rows();

  MatrixT e = MatrixT::Identity(K, K);

  MatrixT y = x;
  NormalMatrixModFixer<T>::Fix(y, mod);

  for (; n; n >>= 1) {
    // cout << "n = " << n << endl;
    if (n & 1) {
      e *= y;
      NormalMatrixModFixer<T>::Fix(e, mod);
    }
    if (n > 1) {
      y *= y;
      NormalMatrixModFixer<T>::Fix(y, mod);
    }
  }
  return e;
}

template <typename T>
SL vector<T> MatrixPower(const EigenMatrix<T>& x, int64 n, const vector<T>& v) {
  using MatrixT = EigenMatrix<T>;

  PE_ASSERT(n >= 0);
  if (IsNModNumber<T>::value && !IsNModNumberCCModOrGlobalMod<T>::value) {
    PE_ASSERT(Eigen::nbThreads() == 1);
  }

  const int K = static_cast<int>(x.rows());

  vector<T> result(v);
  MatrixT y = x;

  vector<T> temp(K, 0);

  for (; n; n >>= 1) {
    // cout << "n = " << n << endl;
    if (n & 1) {
      for (int i = 0; i < K; ++i) {
        T s = 0;
        for (int j = 0; j < K; ++j) {
          s += y(i, j) * result[j];
        }
        ModValueFixer<T>::Fix(s);
        temp[i] = s;
      }
      swap(result, temp);
    }
    if (n > 1) {
      y *= y;
      NModEigenMatrixModFixer<T>::Fix(y);
    }
  }
  return result;
}

template <typename T>
SL vector<T> MatrixPower(const EigenMatrix<T>& x, int64 n, const vector<T>& v,
                         int64 mod) {
  using MatrixT = EigenMatrix<T>;

  PE_ASSERT(n >= 0);
  if (IsNModNumber<T>::value && !IsNModNumberCCModOrGlobalMod<T>::value) {
    PE_ASSERT(Eigen::nbThreads() == 1);
  }

  const int K = x.rows();

  vector<T> result(v);
  for (auto& i : result) i = RegulateMod(i, mod);

  MatrixT y = x;
  NormalMatrixModFixer<T>::Fix(y, mod);

  vector<T> temp(K, 0);

  for (; n; n >>= 1) {
    // cout << "n = " << n << endl;
    if (n & 1) {
      for (int i = 0; i < K; ++i) {
        T s = 0;
        for (int j = 0; j < K; ++j) {
          s += y(i, j) * result[j];
        }
        temp[i] = s % mod;
      }
      swap(result, temp);
    }
    if (n > 1) {
      y *= y;
      NormalMatrixModFixer<T>::Fix(y, mod);
    }
  }
  return result;
}

// Version 1
// Mod is specified explicitly at compiling time.
template <int64 mod>
SL EigenMatrix<int64> MatrixPowerModEigen(
    const function<void(EigenMatrix<NMod64<mod>>& mat)>& init, const int K,
    int64 n) {
  using T = NMod64<mod>;
  using MatrixT = EigenMatrix<T>;

  MatrixT m = MatrixT::Zero(K, K);

  init(m);

  auto t = MatrixPower(m, n);

  EigenMatrix<int64> res(K, K);
  for (int i = 0; i < K; ++i) {
    for (int j = 0; j < K; ++j) {
      res(i, j) = t(i, j).value();
    }
  }

  return res;
}

template <int64 mod>
SL vector<int64> MatrixPowerModEigen(
    const function<void(EigenMatrix<NMod64<mod>>& mat, vector<NMod64<mod>>& v)>&
        init,
    const int K, int64 n) {
  using T = NMod64<mod>;
  using MatrixT = EigenMatrix<T>;

  vector<T> v(K, 0);
  MatrixT m = MatrixT::Zero(K, K);

  init(m, v);

  auto t = MatrixPower(m, n, v);

  vector<int64> res(K, 0);
  for (int i = 0; i < K; ++i) {
    res[i] = t[i].value();
  }

  return res;
}

// Version 2
// Mod is associated with T at compiling time or runtime.
template <typename T>
SL REQUIRES((IsNModNumber<T>::value)) RETURN(EigenMatrix<T>)
    MatrixPowerModEigen(const function<void(EigenMatrix<T>& mat)>& init,
                        const int K, int64 n) {
  using MatrixT = EigenMatrix<T>;

  MatrixT m = MatrixT::Zero(K, K);

  init(m);

  return MatrixPower(m, n);
}

template <typename T>
SL REQUIRES((IsNModNumber<T>::value)) RETURN(vector<T>) MatrixPowerModEigen(
    const function<void(EigenMatrix<T>& mat, vector<T>& v)>& init, const int K,
    int64 n) {
  using MatrixT = EigenMatrix<T>;

  vector<T> v(K, 0);
  MatrixT m = MatrixT::Zero(K, K);

  init(m, v);

  return MatrixPower(m, n, v);
}

// Version 3
// Mod is specified at runtime.
#if PE_HAS_INT128
SL EigenMatrix<int64> MatrixPowerModEigen(
    const function<void(EigenMatrix<int128>& mat)>& init, const int K, int64 n,
    int64 mod) {
  using T = int128;
  using MatrixT = EigenMatrix<T>;

  MatrixT m = MatrixT::Zero(K, K);

  init(m);

  auto t = MatrixPower(m, n, mod);

  EigenMatrix<int64> res(K, K);
  for (int i = 0; i < K; ++i) {
    for (int j = 0; j < K; ++j) {
      res(i, j) = static_cast<int64>(t(i, j));
    }
  }

  return res;
}

SL vector<int64> MatrixPowerModEigen(
    const function<void(EigenMatrix<int128>& mat, vector<int128>& v)>& init,
    const int K, int64 n, int64 mod) {
  using T = int128;
  using MatrixT = EigenMatrix<T>;

  vector<T> v(K, 0);
  MatrixT m = MatrixT::Zero(K, K);

  init(m, v);

  auto t = MatrixPower(m, n, v, mod);

  vector<int64> res(K, 0);
  for (int i = 0; i < K; ++i) {
    res[i] = t[i];
  }

  return res;
}
#else
// mod == DefaultMod::mod()
SL EigenMatrix<int64> MatrixPowerModEigen(
    const function<void(EigenMatrix<NModNumber<DefaultMod>>& mat)>& init,
    const int K, int64 n, int64 mod) {
  using T = NModNumber<DefaultMod>;
  using MatrixT = EigenMatrix<T>;

  DefaultMod::Set(mod);
  PE_ASSERT(mod == DefaultMod::Mod());

  MatrixT m = MatrixT::Zero(K, K);

  init(m);

  auto t = MatrixPower(m, n);

  EigenMatrix<int64> res(K, K);
  for (int i = 0; i < K; ++i)
    for (int j = 0; j < K; ++j) {
      res(i, j) = static_cast<int64>(t(i, j).value());
    }

  return res;
}

// mod == DefaultMod::mod()
SL vector<int64> MatrixPowerModEigen(
    const function<void(EigenMatrix<NModNumber<DefaultMod>>& mat,
                        vector<NModNumber<DefaultMod>>& v)>& init,
    const int K, int64 n, int64 mod) {
  using T = NModNumber<DefaultMod>;
  using MatrixT = EigenMatrix<T>;

  DefaultMod::Set(mod);
  PE_ASSERT(mod == DefaultMod::Mod());

  vector<T> v(K, 0);
  MatrixT m = MatrixT::Zero(K, K);

  init(m, v);

  auto t = MatrixPower(m, n, v);

  vector<int64> res(K, 0);
  for (int i = 0; i < K; ++i) {
    res[i] = t[i].value();
  }

  return res;
}
#endif  // end PE_HAS_INT128

#endif  // end ENABLE_EIGEN

#if ENABLE_EIGEN
#define MatrixPowerMod MatrixPowerModEigen
#else
#define MatrixPowerMod MatrixPowerModPe
#endif

#endif
