#ifndef PE_MEMORY_
#define PE_MEMORY_

#include "pe_base"

namespace pe {
#if OS_TYPE_WIN
class LargeMemory {
 public:
  LargeMemory() = default;

  ~LargeMemory() {
    std::lock_guard<std::mutex> lock(mtx_);

    for (auto& [ptr, hMapFile] : allocated_) {
      ::UnmapViewOfFile(ptr);
      ::CloseHandle(hMapFile);
    }
  }

  LargeMemory(const LargeMemory&) = delete;
  LargeMemory& operator=(const LargeMemory&) = delete;
  LargeMemory(LargeMemory&&) = delete;
  LargeMemory& operator=(LargeMemory&&) = delete;

  void* Allocate(int64_t size) {
    if (size <= 0) return nullptr;

    DWORD sizeHigh = static_cast<DWORD>(size >> 32);
    DWORD sizeLow = static_cast<DWORD>(size & 0xFFFFFFFF);

    HANDLE hMapFile = ::CreateFileMapping(INVALID_HANDLE_VALUE, nullptr,
                                          PAGE_READWRITE | SEC_COMMIT, sizeHigh,
                                          sizeLow, nullptr);

    if (hMapFile == NULL) {
      std::cerr << "CreateFileMapping failed with error: " << ::GetLastError()
                << std::endl;
      return nullptr;
    }

    void* ptr = ::MapViewOfFile(hMapFile, FILE_MAP_ALL_ACCESS, 0, 0, size);

    if (ptr == NULL) {
      std::cerr << "MapViewOfFile failed with error: " << ::GetLastError()
                << std::endl;
      ::CloseHandle(hMapFile);
      return nullptr;
    }

    {
      std::lock_guard<std::mutex> lock(mtx_);
      allocated_.insert({ptr, hMapFile});
    }

    return ptr;
  }

  void Deallocate(void* ptr) {
    if (ptr == nullptr) return;

    HANDLE hMapFile = NULL;

    {
      std::lock_guard<std::mutex> lock(mtx_);
      auto where = allocated_.find(ptr);
      if (where == std::end(allocated_)) {
        return;
      }
      hMapFile = where->second;
      allocated_.erase(where);
    }

    ::UnmapViewOfFile(ptr);
    ::CloseHandle(hMapFile);
  }

 private:
  std::map<void*, HANDLE> allocated_;
  std::mutex mtx_;
};

SL LargeMemory& LmAllocator() {
  static LargeMemory __lm;
  return __lm;
}

struct LmAllocator {
  static void* Allocate(int64 size) { return LmAllocator().Allocate(size); }
  static void Deallocate(void* ptr) { LmAllocator().Deallocate(ptr); }
};

#endif

struct StdAllocator {
  static void* Allocate(int64 size) { return new char[size]; }
  static void Deallocate(void* ptr) { delete[] reinterpret_cast<char*>(ptr); }
};
}  // namespace pe
#endif
