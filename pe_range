#ifndef PE_RANGE_
#define PE_RANGE_

#include "pe_base"
#include "pe_type_traits"
#include "pe_mod"

namespace pe {
// range utility
namespace ru {
template <typename T = int64, typename U = T>
struct Reducer {
  using VT = T;
  using IT = U;

  Reducer(VT init_value, const std::function<void(VT&, IT)>& accumulator,
          const std::function<void(VT&, VT)>& combiner)
      : init_value_(init_value),
        accumulator_(accumulator),
        combiner_(combiner) {}

  Reducer(VT init_value, const std::function<void(VT&, IT)>& accumulator)
      : init_value_(init_value),
        accumulator_(accumulator),
        combiner_(accumulator) {}

  VT GetInitValue() const { return init_value_; }

  void Accumulate(VT& v, IT a) const { accumulator_(v, a); }
  void Combine(VT& v, VT a) const { combiner_(v, a); }

  VT init_value_;
  std::function<void(VT&, IT)> accumulator_;
  std::function<void(VT&, VT)> combiner_;
};

template <typename T, typename U>
SL T IdMap(U a) {
  return a;
}

template <typename T = int64, typename U = T>
struct Add {
  using VT = T;
  using IT = U;

  Add(const std::function<VT(IT)>& mapper = IdMap<VT, IT>) : mapper_(mapper) {}

  VT GetInitValue() const { return 0; }

  void Accumulate(VT& v, const IT& a) const { v += mapper_(a); }

  void Combine(VT& v, VT a) const { v += a; }

  std::function<VT(IT)> mapper_;
};

template <typename T = int64, typename U = T>
struct AddMod {
  using VT = T;
  using IT = U;

  AddMod(VT mod, const std::function<VT(IT)>& mapper = IdMap<VT, IT>)
      : mod_(mod), mapper_(mapper) {}

  VT GetInitValue() const { return 0; }

  void Accumulate(VT& v, const IT& a) const {
    v = pe::AddMod<VT>(v, mapper_(a) % mod_, mod_);
  }

  void Combine(VT& v, VT a) const { v = pe::AddMod<VT>(v, a, mod_); }

  const VT mod_;
  std::function<VT(IT)> mapper_;
};

template <typename T = int64, typename U = T>
struct Mul {
  using VT = T;
  using IT = U;

  Mul(const std::function<VT(IT)>& mapper = IdMap<VT, IT>) : mapper_(mapper) {}

  VT GetInitValue() const { return 1; }

  void Accumulate(VT& v, const IT& a) const { v *= mapper_(a); }

  void Combine(VT& v, VT a) const { v *= a; }

  std::function<VT(IT)> mapper_;
};

template <typename T = int64, typename U = T>
struct MulMod {
  using VT = T;
  using IT = U;

  MulMod(VT mod, const std::function<VT(IT)>& mapper = IdMap<VT, IT>)
      : mod_(mod), mapper_(mapper) {}

  VT GetInitValue() const { return 1; }

  void Accumulate(VT& v, const IT& a) const {
    v = pe::MulModEx<VT>(v, mapper_(a) % mod_, mod_);
  }

  void Combine(VT& v, VT a) const { v = pe::MulModEx<VT>(v, a, mod_); }

  const VT mod_;
  std::function<VT(IT)> mapper_;
};
}  // namespace ru

template <typename IT>
struct ContainerRange;

template <typename IT>
struct FilterRange;

template <typename IT, typename ET>
struct MappedRange;

template <typename ET>
struct VectorRange;

constexpr int kDefaultThreadNumber = 8;
constexpr int64 kDefaultPartitionSize = 0;

template <typename DERIVED, typename IT>
struct RangeBase {
  using self_type = RangeBase<DERIVED, IT>;
  using value_type = typename IT::value_type;
  using reference = typename IT::reference;
  using arg_type = typename IT::arg_type;

  int64 CalculateDefaultPartitionSize(const int64 size, const int thread_number,
                                      const int64 partition_size) const {
    return partition_size == 0 ? std::max<int64>(size / thread_number / 2, 1)
                               : partition_size;
  }

  // Filter

  FilterRange<IT> Filter(const std::function<int(arg_type)>& filter) const {
    return FilterRange<IT>{static_cast<const DERIVED&>(*this).begin(),
                           static_cast<const DERIVED&>(*this).end(), filter};
  }

  VectorRange<value_type> PFilter(const std::function<int(arg_type)>& filter,
                                  const int thread_number,
                                  int64 partition_size = 0) const {
    auto data = ToVector();
    const int size = sz(data);
    if (size == 0) {
      return std::vector<value_type>{};
    }

    partition_size =
        CalculateDefaultPartitionSize(size, thread_number, partition_size);

    std::vector<std::vector<value_type>> tmp(thread_number);
    std::vector<value_type> vec;
#if ENABLE_OPENMP
#pragma omp parallel for schedule(dynamic, partition_size) \
    num_threads(thread_number)
    for (int i = 0; i < size; ++i) {
      if (filter(data[i])) {
        const auto id = omp_get_thread_num();
        tmp[id].push_back(std::move(data[i]));
      }
    }
    int64 new_size = 0;
    for (int i = 0; i < thread_number; ++i) {
      new_size += tmp[i].size();
    }
    vec.reserve(new_size);
    for (int i = 0; i < thread_number; ++i) {
      for (auto& iter : tmp[i]) {
        vec.push_back(std::move(iter));
      }
    }
#else
    for (int i = 0; i < size; ++i) {
      if (filter(data[i])) {
        vec.push_back(std::move(data[i]));
      }
    }
#endif
    return VectorRange<value_type>(std::move(vec));
  }

  template <int TN = kDefaultThreadNumber, int64 PS = kDefaultPartitionSize>
  VectorRange<value_type> PFilterT(const std::function<int(arg_type)>& filter) {
    return PFilter(filter, TN, PS);
  }

  // Reduce: reducer versions

  template <typename T>
  auto Reduce(const T& reducer) const -> typename T::VT {
    using VT = typename T::VT;
    VT ret = reducer.GetInitValue();
    auto now = static_cast<const DERIVED&>(*this).begin();
    auto x = static_cast<const DERIVED&>(*this).end();
    while (now != x) {
      reducer.Accumulate(ret, *now++);
    }
    return ret;
  }

  template <typename T>
  auto PReduce(const T& reducer, const int thread_number = kDefaultThreadNumber,
               int64 partition_size = kDefaultPartitionSize) const ->
      typename T::VT {
#if ENABLE_OPENMP
    using VT = typename T::VT;
    auto data = ToVector();
    const int64 size = sz(data);
    if (size == 0) {
      return reducer.GetInitValue();
    }

    partition_size =
        CalculateDefaultPartitionSize(size, thread_number, partition_size);

    std::vector<VT> tmp(thread_number, reducer.GetInitValue());
#pragma omp parallel for schedule(dynamic, partition_size) \
    num_threads(thread_number)
    for (int i = 0; i < size; ++i) {
      const auto id = omp_get_thread_num();
      reducer.Accumulate(tmp[id], std::move(data[i]));
    }

    VT ret = tmp[0];
    for (int i = 1; i < thread_number; ++i) {
      reducer.Combine(ret, std::move(tmp[i]));
    }
    return ret;
#else
    return Reduce(reducer);
#endif
  }

  // Reduce: accumulator versions

  template <typename VT, typename AT>
  VT Reduce(const VT& v, const AT& accumulator) const {
    VT ret = v;
    auto now = static_cast<const DERIVED&>(*this).begin();
    auto x = static_cast<const DERIVED&>(*this).end();
    while (now != x) {
      accumulator(ret, *now++);
    }
    return ret;
  }

  template <typename VT, typename AT>
  VT PReduce(const VT& v, const AT& accumulator,
             const int thread_number = kDefaultThreadNumber,
             int64 partition_size = kDefaultPartitionSize) const {
#if ENABLE_OPENMP
    auto data = ToVector();
    const int size = sz(data);
    if (size == 0) {
      return v;
    }

    partition_size =
        CalculateDefaultPartitionSize(size, thread_number, partition_size);

    std::vector<VT> tmp(thread_number, v);
#pragma omp parallel for schedule(dynamic, partition_size) \
    num_threads(thread_number)
    for (int i = 0; i < size; ++i) {
      const auto id = omp_get_thread_num();
      accumulator(tmp[id], data[i]);
    }

    VT ret = tmp[0];
    for (int i = 1; i < thread_number; ++i) {
      accumulator(ret, std::move(tmp[i]));
    }
    return ret;
#else
    return Reduce(v, accumulator);
#endif
  }

  // Reduce: accumulator and combiner versions

  template <typename VT, typename AT, typename CT>
  VT PReduce(const VT& v, const AT& accumulator, const CT& combiner,
             const int thread_number = kDefaultThreadNumber,
             int64 partition_size = kDefaultPartitionSize) const {
#if ENABLE_OPENMP
    auto data = ToVector();
    const int size = sz(data);
    if (size == 0) {
      return v;
    }

    partition_size =
        CalculateDefaultPartitionSize(size, thread_number, partition_size);

    std::vector<VT> tmp(thread_number, v);
#pragma omp parallel for schedule(dynamic, partition_size) \
    num_threads(thread_number)
    for (int i = 0; i < size; ++i) {
      const auto id = omp_get_thread_num();
      accumulator(tmp[id], data[i]);
    }

    VT ret = tmp[0];
    for (int i = 1; i < thread_number; ++i) {
      combiner(ret, std::move(tmp[i]));
    }
    return ret;
#else
    return Reduce(v, accumulator);
#endif
  }

  template <typename TT>
  MappedRange<IT, TT> Map(const std::function<TT(arg_type)>& mapper) const {
    return MappedRange<IT, TT>{static_cast<const DERIVED&>(*this).begin(),
                               static_cast<const DERIVED&>(*this).end(),
                               mapper};
  }

  template <typename TT>
  VectorRange<TT> PMap(const std::function<TT(arg_type)>& mapper,
                       const int thread_number = kDefaultThreadNumber,
                       int64 partition_size = kDefaultPartitionSize) const {
    auto data = ToVector();
    const int size = sz(data);
    if (size == 0) {
      return std::vector<TT>{};
    }

    partition_size =
        CalculateDefaultPartitionSize(size, thread_number, partition_size);

    std::vector<TT> vec(size);
#if ENABLE_OPENMP
#pragma omp parallel for schedule(dynamic, partition_size) \
    num_threads(thread_number)
#endif
    for (int i = 0; i < size; ++i) {
      vec[i] = mapper(std::move(data[i]));
    }

    return VectorRange<TT>(std::move(vec));
  }

  template <typename TT, int TN = kDefaultThreadNumber,
            int PS = kDefaultPartitionSize>
  VectorRange<TT> PMapT(const std::function<TT(arg_type)>& mapper) const {
    return PMap(mapper, TN, PS);
  }

  template <typename T>
  self_type& ForEach(const T& action) {
    auto now = static_cast<const DERIVED&>(*this).begin();
    auto x = static_cast<const DERIVED&>(*this).end();
    while (now != x) {
      action(*now++);
    }
    return *this;
  }

  template <typename T>
  self_type& PForEach(const T& action,
                      const int thread_number = kDefaultThreadNumber,
                      int64 partition_size = kDefaultPartitionSize) {
#if ENABLE_OPENMP
    auto data = ToVector();
    const int size = sz(data);
    if (size == 0) {
      return *this;
    }

    partition_size =
        CalculateDefaultPartitionSize(size, thread_number, partition_size);

#pragma omp parallel for schedule(dynamic, partition_size) \
    num_threads(thread_number)
    for (int i = 0; i < size; ++i) {
      action(std::move(data[i]));
    }

    return *this;
#else
    return ForEach(action);
#endif
  }

  template <typename VT = int64>
  VT Sum() const {
    VT ret = 0;
    auto now = static_cast<const DERIVED&>(*this).begin();
    auto x = static_cast<const DERIVED&>(*this).end();
    while (now != x) {
      ret += *now++;
    }
    return ret;
  }

  template <typename VT = int64>
  VT SumMod(VT mod) const {
    VT ret = 0;
    auto now = static_cast<const DERIVED&>(*this).begin();
    auto x = static_cast<const DERIVED&>(*this).end();
    while (now != x) {
      ret = pe::AddMod(ret, pe::RegulateMod(*now++, mod), mod);
    }
    return ret;
  }

  template <typename VT = int64>
  VT Prod() const {
    VT ret = 1;
    auto now = static_cast<const DERIVED&>(*this).begin();
    auto x = static_cast<const DERIVED&>(*this).end();
    while (now != x) {
      ret *= *now++;
    }
    return ret;
  }

  template <typename VT = int64>
  VT ProdMod(VT mod) const {
    VT ret = 1;
    auto now = static_cast<const DERIVED&>(*this).begin();
    auto x = static_cast<const DERIVED&>(*this).end();
    while (now != x) {
      ret = pe::MulModEx(ret, pe::RegulateMod(*now++, mod), mod);
    }
    return ret;
  }

  int IsEmpty() const {
    auto now = static_cast<const DERIVED&>(*this).begin();
    auto x = static_cast<const DERIVED&>(*this).end();
    return now == x ? 1 : 0;
  }

  int64 Count() const { return static_cast<const DERIVED&>(*this).CountImpl(); }

  int64 CountImpl() const {
    int64 ret = 0;
    auto now = static_cast<const DERIVED&>(*this).begin();
    auto x = static_cast<const DERIVED&>(*this).end();
    while (now != x) {
      ++now;
      ++ret;
    }
    return ret;
  }

  std::optional<value_type> Max() const {
    auto now = static_cast<const DERIVED&>(*this).begin();
    auto x = static_cast<const DERIVED&>(*this).end();
    if (now == x) {
      return {};
    }
    value_type r = *now++;
    while (now != x) {
      r = std::max(r, *now++);
    }
    return r;
  }

  std::optional<value_type> Min() const {
    auto now = static_cast<const DERIVED&>(*this).begin();
    auto x = static_cast<const DERIVED&>(*this).end();
    if (now == x) {
      return {};
    }
    value_type r = *now++;
    while (now != x) {
      r = std::min(r, *now++);
    }
    return r;
  }

  VectorRange<value_type> Sort() const {
    auto data = ToVector();
    std::sort(data.begin(), data.end());
    return VectorRange<value_type>(std::move(data));
  }

  VectorRange<value_type> Distinct() const {
    auto data = ToVector();
    std::sort(data.begin(), data.end());
    data.resize(std::unique(data.begin(), data.end()) - data.begin());
    return VectorRange<value_type>(std::move(data));
  }

  VectorRange<value_type> Reverse() const {
    auto data = ToVector();
    std::reverse(data.begin(), data.end());
    return VectorRange<value_type>(std::move(data));
  }

  VectorRange<value_type> Skip(int64 n) const {
    auto now = static_cast<const DERIVED&>(*this).begin();
    auto x = static_cast<const DERIVED&>(*this).end();
    while (n > 0 && now != x) {
      --n;
      ++now;
    }

    std::vector<value_type> data;
    while (now != x) {
      data.emplace_back(*now++);
    }
    return VectorRange<value_type>(std::move(data));
  }

  VectorRange<value_type> Limit(int64 n) const {
    auto now = static_cast<const DERIVED&>(*this).begin();
    auto x = static_cast<const DERIVED&>(*this).end();
    std::vector<value_type> data;
    while (n > 0 && now != x) {
      --n;
      data.emplace_back(*now++);
    }
    return VectorRange<value_type>(std::move(data));
  }

  int AnyMatch(const std::function<int(arg_type)>& filter) const {
    auto now = static_cast<const DERIVED&>(*this).begin();
    auto x = static_cast<const DERIVED&>(*this).end();
    while (now != x) {
      if (filter(*now++)) {
        return 1;
      }
    }
    return 0;
  }

  int AllMatch(const std::function<int(arg_type)>& filter) const {
    auto now = static_cast<const DERIVED&>(*this).begin();
    auto x = static_cast<const DERIVED&>(*this).end();
    while (now != x) {
      if (!filter(*now++)) {
        return 0;
      }
    }
    return 1;
  }

  int NoneMatch(const std::function<int(arg_type)>& filter) const {
    auto now = static_cast<const DERIVED&>(*this).begin();
    auto x = static_cast<const DERIVED&>(*this).end();
    while (now != x) {
      if (filter(*now++)) {
        return 0;
      }
    }
    return 1;
  }

  template <typename T>
  void Fill(T iter) const {
    auto now = static_cast<const DERIVED&>(*this).begin();
    auto x = static_cast<const DERIVED&>(*this).end();
    while (now != x) {
      *iter++ = *now++;
    }
  }

  std::vector<value_type> ToVector() const {
    std::vector<value_type> ret;
    auto now = static_cast<const DERIVED&>(*this).begin();
    auto x = static_cast<const DERIVED&>(*this).end();
    while (now != x) {
      ret.emplace_back(*now++);
    }
    return std::move(ret);
  }

  std::set<value_type> ToSet() const {
    std::set<value_type> ret;
    auto now = static_cast<const DERIVED&>(*this).begin();
    auto x = static_cast<const DERIVED&>(*this).end();
    while (now != x) {
      ret.insert(*now++);
    }
    return std::move(ret);
  }
};

template <typename ET>
struct NumberIter {
  using value_type = typename std::remove_cvref<ET>::type;
  using reference = value_type;
  using arg_type = const value_type;

  reference operator*() const { return i_; }

  int operator==(const NumberIter& o) const { return i_ == o.i_; }

  int operator!=(const NumberIter& o) const { return !(this->operator==(o)); }

  NumberIter& operator++() {
    ++i_;
    return *this;
  }

  NumberIter operator++(int) { return NumberIter{i_++}; }

  NumberIter& operator--() {
    --i_;
    return *this;
  }

  NumberIter operator--(int) { return NumberIter{i_--}; }

  value_type i_;
};

template <typename ET>
struct NumberRange : public RangeBase<NumberRange<ET>, NumberIter<ET>> {
  using iterator = NumberIter<ET>;
  using const_iterator = iterator;
  using value_type = typename iterator::value_type;
  using arg_type = typename iterator::arg_type;

  NumberRange(value_type b, value_type e) : b_(b), e_(e) {}

  NumberIter<ET> begin() const { return NumberIter<ET>{b_}; }
  NumberIter<ET> end() const { return NumberIter<ET>{e_}; }

  int64 CountImpl() const { return static_cast<int64>(e_ - b_); }

  VectorRange<value_type> PFilter(const std::function<int(value_type)>& filter,
                                  const int thread_number,
                                  int64 partition_size = 0) const {
    const int64 size = e_ - b_;
    if (size == 0) {
      return std::vector<value_type>{};
    }
    partition_size = RangeBase<NumberRange<ET>, NumberIter<ET>>::
        CalculateDefaultPartitionSize(size, thread_number, partition_size);

    std::vector<std::vector<value_type>> tmp(thread_number);
    std::vector<value_type> vec;
#if ENABLE_OPENMP
#pragma omp parallel for schedule(dynamic, partition_size) \
    num_threads(thread_number)
    for (value_type i = b_; i < e_; ++i) {
      if (filter(i)) {
        const auto id = omp_get_thread_num();
        tmp[id].push_back(i);
      }
    }
    int64 new_size = 0;
    for (int i = 0; i < thread_number; ++i) {
      new_size += tmp[i].size();
    }
    vec.reserve(new_size);
    for (int i = 0; i < thread_number; ++i) {
      for (auto& iter : tmp[i]) {
        vec.push_back(iter);
      }
    }
#else
    for (value_type i = b_; i < e_; ++i) {
      if (filter(i)) {
        vec.push_back(i);
      }
    }
#endif
    return VectorRange<value_type>(std::move(vec));
  }

  template <int TN = kDefaultThreadNumber, int PS = kDefaultPartitionSize>
  VectorRange<value_type> PFilterT(
      const std::function<int(value_type)>& filter) {
    return PFilter(filter, TN, PS);
  }

  template <typename T>
  auto PReduce(const T& reducer, const int thread_number = kDefaultThreadNumber,
               int64 partition_size = kDefaultPartitionSize) const ->
      typename T::VT {
    const int64 size = e_ - b_;
    if (size == 0) {
      return reducer.GetInitValue();
    }
#if ENABLE_OPENMP
    using VT = typename T::VT;

    partition_size = RangeBase<NumberRange<ET>, NumberIter<ET>>::
        CalculateDefaultPartitionSize(size, thread_number, partition_size);

    std::vector<VT> tmp(thread_number, reducer.GetInitValue());
#pragma omp parallel for schedule(dynamic, partition_size) \
    num_threads(thread_number)
    for (value_type i = b_; i < e_; ++i) {
      const auto id = omp_get_thread_num();
      reducer.Accumulate(tmp[id], i);
    }

    VT ret = tmp[0];
    for (int i = 1; i < thread_number; ++i) {
      reducer.Combine(ret, std::move(tmp[i]));
    }
    return ret;
#else
    return RangeBase<NumberRange<ET>, NumberIter<ET>>::Reduce(reducer);
#endif
  }

  template <typename VT, typename AT>
  VT PReduce(const VT& v, const AT& accumulator,
             const int thread_number = kDefaultThreadNumber,
             int64 partition_size = kDefaultPartitionSize) const {
    const int64 size = e_ - b_;
    if (size == 0) {
      return v;
    }

#if ENABLE_OPENMP
    partition_size = RangeBase<NumberRange<ET>, NumberIter<ET>>::
        CalculateDefaultPartitionSize(size, thread_number, partition_size);

    std::vector<VT> tmp(thread_number, v);
#pragma omp parallel for schedule(dynamic, partition_size) \
    num_threads(thread_number)
    for (value_type i = b_; i < e_; ++i) {
      const auto id = omp_get_thread_num();
      accumulator(tmp[id], i);
    }

    VT ret = tmp[0];
    for (int i = 1; i < thread_number; ++i) {
      accumulator(ret, std::move(tmp[i]));
    }
    return ret;
#else
    return RangeBase<NumberRange<ET>, NumberIter<ET>>::Reduce(v, accumulator);
#endif
  }

  template <typename VT, typename AT, typename CT>
  VT PReduce(const VT& v, const AT& accumulator, const CT& combiner,
             const int thread_number = kDefaultThreadNumber,
             int64 partition_size = kDefaultPartitionSize) const {
    const int64 size = e_ - b_;
    if (size == 0) {
      return v;
    }

#if ENABLE_OPENMP
    partition_size = RangeBase<NumberRange<ET>, NumberIter<ET>>::
        CalculateDefaultPartitionSize(size, thread_number, partition_size);

    std::vector<VT> tmp(thread_number, v);
#pragma omp parallel for schedule(dynamic, partition_size) \
    num_threads(thread_number)
    for (value_type i = b_; i < e_; ++i) {
      const auto id = omp_get_thread_num();
      accumulator(tmp[id], i);
    }

    VT ret = tmp[0];
    for (int i = 1; i < thread_number; ++i) {
      combiner(ret, std::move(tmp[i]));
    }
    return ret;
#else
    return RangeBase<NumberRange<ET>, NumberIter<ET>>::Reduce(v, accumulator);
#endif
  }

  template <typename TT>
  VectorRange<TT> PMap(const std::function<TT(value_type)>& mapper,
                       const int thread_number = kDefaultThreadNumber,
                       int64 partition_size = kDefaultPartitionSize) const {
    const int64 size = e_ - b_;
    if (size == 0) {
      return std::vector<TT>{};
    }
    partition_size = RangeBase<NumberRange<ET>, NumberIter<ET>>::
        CalculateDefaultPartitionSize(size, thread_number, partition_size);

    std::vector<TT> vec(size);
#if ENABLE_OPENMP
#pragma omp parallel for schedule(dynamic, partition_size) \
    num_threads(thread_number)
#endif
    for (value_type i = b_; i < e_; ++i) {
      vec[i - b_] = mapper(i);
    }
    return VectorRange<TT>(std::move(vec));
  }

  template <typename TT, int TN = kDefaultThreadNumber,
            int PS = kDefaultPartitionSize>
  VectorRange<TT> PMapT(const std::function<TT(value_type)>& mapper) const {
    return PMap(mapper, TN, PS);
  }

  const value_type b_;
  const value_type e_;
};

template <typename ET>
struct NumberIterD {
  using value_type = typename std::remove_cvref<ET>::type;
  using reference = value_type;
  using arg_type = const value_type;

  reference operator*() const { return i_; }

  int operator==(const NumberIterD& o) const { return i_ == o.i_; }

  int operator!=(const NumberIterD& o) const { return !(this->operator==(o)); }

  NumberIterD& operator++() {
    i_ += delta_;
    return *this;
  }

  NumberIterD operator++(int) {
    value_type x = i_;
    i_ += delta_;
    return NumberIterD{x, e_, delta_};
  }

  NumberIterD& operator--() {
    i_ -= delta_;
    return *this;
  }

  NumberIterD operator--(int) {
    value_type x = i_;
    i_ -= delta_;
    return NumberIterD{x, e_, delta_};
  }

  value_type i_;
  const value_type e_;
  const value_type delta_;
};

template <typename ET>
struct NumberRangeD : public RangeBase<NumberRangeD<ET>, NumberIterD<ET>> {
  using iterator = NumberIterD<ET>;
  using const_iterator = iterator;
  using value_type = typename iterator::value_type;

  NumberRangeD(value_type b, value_type n, value_type delta)
      : b_(b), e_(n), n_(n), delta_(delta) {
    value_type d = std::abs(delta_);
    value_type r = std::abs(n - b);
    value_type s = r / d;
    e_ = b + s * delta_;
    if (r % d) {
      e_ += delta_;
    }
  }

  NumberIterD<ET> begin() const { return NumberIterD<ET>{b_, e_, delta_}; }
  NumberIterD<ET> end() const { return NumberIterD<ET>{e_, e_, delta_}; }

  int64 CountImpl() const {
    return e_ == b_ ? 0LL : static_cast<int64>((e_ - b_) / delta_);
  }

  value_type b_;
  value_type e_;
  const value_type delta_;
  const value_type n_;
};

template <typename T>
SL REQUIRES((is_native_integer<T>::value)) RETURN(NumberRange<int64>)
    Range(T s, T e) {
  PE_ASSERT(s <= e);
  return NumberRange<int64>{s, e};
}

template <typename T>
SL REQUIRES((is_native_integer<T>::value)) RETURN(NumberRange<int64>)
    XRange(T s, T e) {
  return NumberRange<int64>{s, e + 1};
}

template <typename T>
SL REQUIRES((is_native_integer<T>::value)) RETURN(NumberRangeD<int64>)
    Range(T s, T e, T delta) {
  if (s < e) {
    PE_ASSERT(delta > 0);
  } else if (s > e) {
    PE_ASSERT(delta < 0);
  }
  return NumberRangeD<int64>{s, e, delta};
}

template <typename T>
SL REQUIRES((is_native_integer<T>::value)) RETURN(NumberRangeD<int64>)
    XRange(T s, T e, T delta) {
  if (s < e) {
    PE_ASSERT(delta > 0);
  } else if (s > e) {
    PE_ASSERT(delta < 0);
  } else {
    PE_ASSERT(delta != 0);
  }
  T off_by_one = delta >= 0 ? 1 : -1;
  return NumberRangeD<int64>{s, e + off_by_one, delta};
}

template <typename IT>
struct ContainerRangeIter {
  using value_type = typename std::remove_cvref<typename IT::value_type>::type;
  using reference = typename IT::reference;
  using arg_type = typename make_const_arg_type<value_type>::type;

  reference operator*() { return *iter_; }

  int operator==(const ContainerRangeIter& o) const { return iter_ == o.iter_; }

  int operator!=(const ContainerRangeIter& o) const {
    return !(this->operator==(o));
  }

  ContainerRangeIter& operator++() {
    ++iter_;
    return *this;
  }

  ContainerRangeIter operator++(int) { return ContainerRangeIter{iter_++}; }

  ContainerRangeIter& operator--() {
    --iter_;
    return *this;
  }

  ContainerRangeIter operator--(int) { return ContainerRangeIter{iter_--}; }

  IT iter_;
};

template <typename IT>
struct ContainerRange
    : public RangeBase<ContainerRange<IT>, ContainerRangeIter<IT>> {
  using iterator = ContainerRangeIter<IT>;
  using const_iterator = iterator;
  using value_type = typename iterator::value_type;

  ContainerRange(IT b, IT e) : b_(b), e_(e) {}

  ContainerRangeIter<IT> begin() const { return ContainerRangeIter<IT>{b_}; }
  ContainerRangeIter<IT> end() const { return ContainerRangeIter<IT>{e_}; }

  IT b_;
  IT e_;
};

template <typename ET>
struct VectorRange
    : public RangeBase<
          VectorRange<ET>,
          ContainerRangeIter<typename std::vector<ET>::const_iterator>> {
  using IT = typename std::vector<ET>::const_iterator;
  using iterator = ContainerRangeIter<IT>;
  using const_iterator = iterator;
  using value_type = typename iterator::value_type;

  VectorRange(const std::vector<ET>& vec) : vec_(vec) {}

  VectorRange(std::vector<ET>&& vec) : vec_(std::move(vec)) {}

  ContainerRangeIter<IT> begin() const {
    return ContainerRangeIter<IT>{vec_.begin()};
  }
  ContainerRangeIter<IT> end() const {
    return ContainerRangeIter<IT>{vec_.end()};
  }

  int64 CountImpl() const { return static_cast<int64>(vec_.size()); }

  std::vector<ET> vec_;
};

template <typename CT>
SL auto Range(CT& v) -> ContainerRange<typename CT::iterator> {
  return ContainerRange<typename CT::iterator>{v.begin(), v.end()};
}

template <typename CT>
SL auto Range(const CT& v) -> ContainerRange<typename CT::const_iterator> {
  return ContainerRange<typename CT::const_iterator>{v.begin(), v.end()};
}

template <typename T>
SL REQUIRES(!is_native_integer<T>::value) RETURN(ContainerRange<T>)
    Range(T s, T e) {
  return ContainerRange<T>{s, e};
}

template <typename ET>
struct ArrayRangeIter {
  using value_type = typename std::remove_cvref<ET>::type;
  using reference = const value_type&;
  using arg_type = typename make_const_arg_type<value_type>::type;

  reference operator*() { return *iter_; }

  int operator==(const ArrayRangeIter& o) const { return iter_ == o.iter_; }

  int operator!=(const ArrayRangeIter& o) const {
    return !(this->operator==(o));
  }

  ArrayRangeIter& operator++() {
    ++iter_;
    return *this;
  }

  ArrayRangeIter operator++(int) { return ArrayRangeIter{iter_++}; }

  ArrayRangeIter& operator--() {
    --iter_;
    return *this;
  }

  ArrayRangeIter operator--(int) { return ArrayRangeIter{iter_--}; }

  const value_type* iter_;
};

template <typename ET>
struct ArrayRange : public RangeBase<ArrayRange<ET>, ArrayRangeIter<ET>> {
  using iterator = ArrayRangeIter<ET>;
  using const_iterator = iterator;
  using value_type = typename iterator::value_type;

  ArrayRange(const value_type* b, const value_type* e) : b_(b), e_(e) {}

  ArrayRangeIter<ET> begin() const { return ArrayRangeIter<ET>{b_}; }
  ArrayRangeIter<ET> end() const { return ArrayRangeIter<ET>{e_}; }

  int64 CountImpl() const { return static_cast<int64>(e_ - b_); }

  const value_type* b_;
  const value_type* e_;
};

template <typename T>
SL ArrayRange<T> Range(T* s, T* e) {
  PE_ASSERT(s <= e);
  return ArrayRange<T>{s, e};
}

template <typename T>
SL ArrayRange<const T> Range(const T* s, const T* e) {
  PE_ASSERT(s <= e);
  return ArrayRange<const T>{s, e};
}

template <typename T, int N>
SL ArrayRange<T> Range(T (&a)[N]) {
  return ArrayRange<T>{a, a + N};
}

// IT: iterator type of source
// TT: type of the mapped result
template <typename IT, typename TT>
struct MappedRangeIter {
  using value_type = typename std::remove_cvref<TT>::type;
  using reference = value_type;
  using arg_type = typename make_const_arg_type<value_type>::type;
  using src_arg_type = typename IT::arg_type;

  reference operator*() { return mapper_(*iter_); }

  int operator==(const MappedRangeIter& o) const { return iter_ == o.iter_; }

  int operator!=(const MappedRangeIter& o) const {
    return !(this->operator==(o));
  }

  MappedRangeIter& operator++() {
    ++iter_;
    return *this;
  }

  MappedRangeIter operator++(int) { return MappedRangeIter{iter_++, mapper_}; }

  MappedRangeIter& operator--() {
    --iter_;
    return *this;
  }

  MappedRangeIter operator--(int) { return MappedRangeIter{iter_--, mapper_}; }

  IT iter_;
  const std::function<TT(src_arg_type)>& mapper_;
};

template <typename IT, typename TT>
struct MappedRange
    : public RangeBase<MappedRange<IT, TT>, MappedRangeIter<IT, TT>> {
  using iterator = MappedRangeIter<IT, TT>;
  using const_iterator = iterator;
  using value_type = typename iterator::value_type;

  MappedRange(IT b, IT e,
              const std::function<TT(typename iterator::src_arg_type)>& mapper)
      : b_(b), e_(e), mapper_(mapper) {}

  MappedRangeIter<IT, TT> begin() const {
    return MappedRangeIter<IT, TT>{b_, mapper_};
  }
  MappedRangeIter<IT, TT> end() const {
    return MappedRangeIter<IT, TT>{e_, mapper_};
  }

  IT b_;
  IT e_;
  const std::function<TT(typename iterator::src_arg_type)> mapper_;
};

template <typename IT>
struct FilterRangeIter {
  using value_type = typename IT::value_type;
  using reference = typename IT::reference;
  using arg_type = typename IT::arg_type;
  using src_arg_type = typename IT::arg_type;

  reference operator*() { return *iter_; }

  int operator==(const FilterRangeIter& o) const { return iter_ == o.iter_; }

  int operator!=(const FilterRangeIter& o) const {
    return !(this->operator==(o));
  }

  FilterRangeIter& operator++() {
    while (iter_ != e_) {
      ++iter_;
      if (iter_ == e_) break;
      if (filter_(*iter_)) break;
    }
    return *this;
  }

  FilterRangeIter operator++(int) {
    IT x = iter_;
    this->operator++();
    return FilterRangeIter{x, e_, filter_};
  }

  IT iter_;
  IT e_;
  const std::function<int(src_arg_type)>& filter_;
};

template <typename IT>
struct FilterRange : public RangeBase<FilterRange<IT>, FilterRangeIter<IT>> {
  using iterator = FilterRangeIter<IT>;
  using const_iterator = iterator;
  using value_type = typename FilterRangeIter<IT>::value_type;

  FilterRange(IT b, IT e,
              const std::function<int(const typename IT::value_type&)>& filter)
      : b_(b), e_(e), filter_(filter) {}

  FilterRangeIter<IT> begin() const {
    auto now = b_;
    while (now != e_ && !filter_(*now)) ++now;
    return FilterRangeIter<IT>{now, e_, filter_};
  }

  FilterRangeIter<IT> end() const {
    return FilterRangeIter<IT>{e_, e_, filter_};
  }

  IT b_;
  IT e_;
  const std::function<int(typename iterator::src_arg_type)> filter_;
};

// IRange support. i = index.
template <typename IT>
struct ContainerIterI {
  struct ContainerItemI {
    const int64 i;
    typename IT::reference v;
  };

  using value_type = ContainerItemI;
  using reference = ContainerItemI;

  ContainerItemI operator*() { return ContainerItemI{idx_, *iter_}; }

  int operator==(const ContainerIterI& o) const { return iter_ == o.iter_; }

  int operator!=(const ContainerIterI& o) const {
    return !(this->operator==(o));
  }

  ContainerIterI& operator++() {
    ++idx_;
    ++iter_;
    return *this;
  }

  ContainerIterI operator++(int) { return ContainerIterI{iter_++, idx_++}; }

  ContainerIterI& operator--() {
    --idx_;
    --iter_;
    return *this;
  }

  ContainerIterI operator--(int) { return ContainerIterI{iter_--, idx_--}; }

  IT iter_;
  int64 idx_;
};

template <typename IT>
struct ContainerRangeI {
  using iterator = ContainerIterI<IT>;
  using const_iterator = ContainerIterI<IT>;

  ContainerIterI<IT> begin() const { return ContainerIterI<IT>{b_, 0}; }
  ContainerIterI<IT> end() const { return ContainerIterI<IT>{e_, 0}; }

  IT b_;
  IT e_;
};

template <typename T>
struct ArrayIterI {
  struct ContainerItemI {
    const int64 i;
    T& v;
  };

  using value_type = ContainerItemI;
  using reference = ContainerItemI;

  ContainerItemI operator*() { return ContainerItemI{idx_, start_[idx_]}; }

  int operator==(const ArrayIterI& o) const {
    return idx_ == o.idx_ && start_ == o.start_;
  }

  int operator!=(const ArrayIterI& o) const { return !(this->operator==(o)); }

  ArrayIterI& operator++() {
    ++idx_;
    return *this;
  }

  ArrayIterI operator++(int) { return ArrayIterI{start_, idx_++}; }

  ArrayIterI& operator--() {
    --idx_;
    return *this;
  }

  ArrayIterI operator--(int) { return ArrayIterI{start_, idx_--}; }

  T* start_;
  int64 idx_;
};

template <typename T>
struct ArrayRangeI {
  using iterator = ArrayIterI<T>;
  using const_iterator = ArrayIterI<T>;

  ArrayIterI<T> begin() const { return ArrayIterI<T>{start_, 0}; }
  ArrayIterI<T> end() const { return ArrayIterI<T>{start_, cnt_}; }

  T* start_;
  int64 cnt_;
};

template <typename T>
SL ArrayRangeI<T> IRange(std::vector<T>& v) {
  return ArrayRangeI<T>{&v[0], sz(v)};
}

template <typename T>
SL ArrayRangeI<const T> IRange(const std::vector<T>& v) {
  return ArrayRangeI<const T>{&v[0], sz(v)};
}

template <typename T>
SL ArrayRangeI<T> IRange(T* s, T* e) {
  PE_ASSERT(s <= e);
  return ArrayRangeI<T>{s, e - s};
}

template <typename T>
SL ArrayRangeI<const T> IRange(const T* s, const T* e) {
  PE_ASSERT(s <= e);
  return ArrayRangeI<const T>{s, e - s};
}

template <typename T, int N>
SL ArrayRangeI<T> IRange(T (&a)[N]) {
  return ArrayRangeI<T>{a, N};
}

template <typename CT>
SL auto IRange(CT& v) -> ContainerRangeI<typename CT::iterator> {
  return ContainerRangeI<typename CT::iterator>{v.begin(), v.end()};
}

template <typename CT>
SL auto IRange(const CT& v) -> ContainerRangeI<typename CT::const_iterator> {
  return ContainerRangeI<typename CT::const_iterator>{v.begin(), v.end()};
}

SL std::vector<std::pair<int64, int64>> MakeSegment(int64 s, int64 e, int64 b) {
  if (s > e) {
    return std::vector<std::pair<int64, int64>>();
  }
  int64 cnt = (e - s + 1 + b - 1) / b;
  std::vector<std::pair<int64, int64>> ret(cnt);
  int64 x = 0, y = s - 1;
  for (int64 i = 0; i < cnt; ++i) {
    x = y + 1;
    y += b;
    if (y > e) y = e;
    ret[i].first = x;
    ret[i].second = y;
  }
  return ret;
}
}  // namespace pe
#endif