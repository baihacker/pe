#ifndef PE_ALGO_
#define PE_ALGO_

#include "pe_base"
#include "pe_nt"
#include "pe_poly_algo"
#include "pe_tree"
#include "pe_array"
#include "pe_parallel_algo"

/**
 * Compuates n! % p
 * Algorithm source: // https://min-25.hatenablog.com/entry/2017/04/10/215046
 * Complexity is M(p^(1/2))
 */
struct FactModer {
  FactModer(uint64 p) : p_(p) { init(); }

  // Evaluate (x+v*0+1)*(x+v*1+1)*(x+v*2+1)*...*(x+v*(d-1)+1) at 0, 1, 2, ..., d
  void evaluate(int d, uint64* result, uint64 v) {
    if (d == 1) {
      result[0] = 1;
      result[1] = p_ == 2 ? 0 : 2;
      return;
    }

    const int halfD = d >> 1;
    evaluate(halfD, result, v);
    copy(result, result + halfD + 1, &g0_[0]);
#if ENABLE_OPENMP
#pragma omp parallel sections if (d >= 10000)
#endif
    {
#if ENABLE_OPENMP
#pragma omp section
#endif
      poly_offset_evaluate<uint64>(halfD, result, &g1_[0], halfD + 1,
                                   &pre_fact_inv_[0], p_);
#if ENABLE_OPENMP
#pragma omp section
#endif
      poly_offset_evaluate<uint64>(halfD, result, &g2_[0], v * halfD,
                                   &pre_fact_inv_[0], p_);
#if ENABLE_OPENMP
#pragma omp section
#endif
      poly_offset_evaluate<uint64>(halfD, result, &g3_[0], v * halfD + halfD,
                                   &pre_fact_inv_[0], p_);
    }

    for (int i = 0; i <= halfD; ++i) {
      result[i] = mul_mod_ex(g0_[i], g2_[i], p_);
    }
    for (int i = halfD + 1, j = 0; i <= halfD * 2; ++i, ++j) {
      result[i] = mul_mod_ex(g1_[j], g3_[j + 1], p_);
    }

    if (d & 1) {
      uint64 tmp = (v * (d - 1) + 1) % p_;
      for (int i = 0; i <= 2 * halfD; ++i) {
        result[i] = mul_mod_ex(result[i], tmp++, p_);
        if (tmp >= p_) tmp -= p_;
      }
      uint64 t = 1;
      uint64 c = d + 1;
      for (int i = 0; i < d; ++i) {
        t = mul_mod_ex(t, c, p_);
        c += v;
        if (c >= p_) c -= p_;
      }
      result[d] = t;
    }
  }

  int64 cal(uint64 n) {
    if (n >= p_) return 0;
    if (n < q_) return pre_fact_[n];

    uint64 m = static_cast<int64>(sqrt(n));
    uint64 ret = 1;

    for (uint64 i = m * m + 1; i <= n; ++i) {
      ret = mul_mod_ex(ret, i, p_);
    }

    evaluate(static_cast<int>(m), static_cast<uint64*>(&v_[0]), m);

    for (int i = 0; i < m; ++i) {
      ret = mul_mod_ex(ret, v_[i], p_);
    }
    return static_cast<int64>(ret);
  }

  void init() {
    q_ = static_cast<uint64>(sqrt(p_));
    while (q_ * q_ < p_) ++q_;
    q_ <<= 1;
    q_ += 1;
    pre_fact_.resize(q_);
    pre_fact_inv_.resize(q_);
    init_seq_prod2<uint64>(&pre_fact_[0], &pre_fact_inv_[0], 1, q_ - 1, p_);
    g0_.resize(q_);
    g1_.resize(q_);
    g2_.resize(q_);
    g3_.resize(q_);
    v_.resize(q_);
  }

 private:
  uint64 p_;
  uint64 q_;
  vector<uint64> pre_fact_, pre_fact_inv_;
  vector<uint64> g0_, g1_, g2_, g3_;
  vector<uint64> v_;
};

/**
 * Computes (0! + 1! + 2! + ... + n!) % p
 * The complexity is M(p^(1/2))
 * f(4e8)%99999999907 = 16815920030
 */
struct FactSumModer {
  FactSumModer(uint64 p) : p_(p) { init(); }

  int64 cal(uint64 n) {
    if (n >= p_) n = p_ - 1;
    if (n < q_) return preFactSum_[n];

    auto m = static_cast<int64>(sqrt(n));
    uint64 ret = 1;

    // Prepare data for computing P
    vector<uint64> X((m - 1) * 2);
    for (int i = 0; i < m - 1; ++i) {
      X[i * 2] = i + 1;
      X[i * 2 + 1] = m;
    }

    vector<uint64> V(m);
    for (int i = 0; i < m; ++i) {
      V[i] = i;
    }

    // Compute P
    vector<uint64> YQ;
    auto YP = poly_batch_mul_acc(X, 0, static_cast<int>(m - 1), YQ, p_);
    YP[0] = add_mod(YP[0], 1, p_);
    auto P = poly_multipoint_evaluate(YP, V, p_);

    // Prepare data for computing Q
    // YQ *= (m + xm)
    YQ.resize(m + 1);
    YQ[m] = YQ[m - 1];
    for (int i = static_cast<int>(m - 1); i >= 1; --i)
      YQ[i] = add_mod(YQ[i], YQ[i - 1], p_);
    for (auto& i : YQ) i = mul_mod_ex(i, m, p_);

    // V.extend(m)
    V.push_back(m);

    // Compute Q
    auto Q = poly_multipoint_evaluate(YQ, V, p_);
    for (int i = 1; i <= m; ++i) {
      Q[i] = mul_mod_ex(Q[i], Q[i - 1], p_);
    }

    // Compute P
    X.resize((m - 1) * 2);
    V.resize(m);
    // deg y = m - 1

    // Compute result
    int64 result = P[0];
    for (int i = 1; i < m; ++i) {
      uint64 t = mul_mod_ex(P[i], Q[i - 1], p_);
      result = add_mod(result, t, p_);
    }

    uint64 last = Q[m - 1];
    for (int64 i = m * m; i <= static_cast<int64>(n); ++i) {
      result = add_mod(result, last, p_);
      last = mul_mod_ex(last, i + 1, p_);
    }
    return result;
  }

  void init() {
    q_ = static_cast<uint64>(sqrt(p_));
    while (q_ * q_ < p_) ++q_;
    q_ <<= 1;
    q_ += 1;
    preFact_.resize(q_);
    preFactSum_.resize(q_);
    init_seq_prod2<uint64>(&preFact_[0], nullptr, q_ - 1, p_);
    preFactSum_[0] = preFact_[0];
    for (int i = 1; i < q_; ++i) {
      preFactSum_[i] = add_mod(preFactSum_[i - 1], preFact_[i], p_);
    }
  }

 private:
  uint64 p_;
  uint64 q_;
  vector<uint64> preFact_;
  vector<uint64> preFactSum_;
};

/**
 * Calculates C(n, m) % P where P is prime
 * Deprecated
 */
template <int64 P, int64 F = P>
struct comb_moder {
  static_assert(P <= PE_SOI63, "P <= PE_SOI63");
  static_assert(F > 0, "F > 0");
  comb_moder() { init(); }
  static int64 inv(int64 x) {
    int64 result = 1;
    int n = P - 2;
    x %= P;
    for (; n; n >>= 1, x = x * x % P)
      if (n & 1) result = result * x % P;
    return result;
  }
  static int64* fac_;
  static void init() {
    if (fac_ == nullptr) {
      fac_ = new int64[F];
      fac_[0] = 1;
      for (int i = 1; i < F; ++i) fac_[i] = fac_[i - 1] * i % P;
    }
  }
  static void destroy_fac() {
    delete[] fac_;
    fac_ = nullptr;
  }
  static int64 s(int64 x) { return x & 1 ? -1 : 1; }
  static int64 comb(int64 m, int64 n) {
    PE_ASSERT(fac_);

    if (m < 0 || n > m) return 0;

    int64 pp = 0;
    int64 dist = m - n;

    for (int64 mm = m / P, nn = n / P, dd = dist / P; mm;
         mm /= P, nn /= P, dd /= P) {
      pp += mm - nn - dd;
    }
    if (pp) return 0;
    int64 l = 1, r = 1;
    for (int64 x = m; x; x /= P) {
      PE_ASSERT(x % P < F);
      l = l * s(x / P) * fac_[x % P] % P;
    }
    for (int64 x = n; x; x /= P) {
      PE_ASSERT(x % P < F);
      r = r * s(x / P) * fac_[x % P] % P;
    }
    for (int64 x = dist; x; x /= P) {
      PE_ASSERT(x % P < F);
      r = r * s(x / P) * fac_[x % P] % P;
    }
    l = (l + P) % P;
    r = (r + P) % P;
    int64 t = (inv(r) * l % P + P) % P;
    return t;
  }
};
template <int64 P, int64 F>
int64* comb_moder<P, F>::fac_;

/**
 * Calculates C(n, m) % P where P is prime
 */
struct CombModer {
  CombModer(uint64 p, uint64 f = 0) : p_(p), f_(f == 0 ? p : f) {
    init(this->f_);
  }

  ~CombModer() = default;

  void init(uint64 F) {
    this->f_ = F;

    vector<uint64>(F).swap(fac_);
    fac_[0] = 1;
    for (int i = 1; i < F; ++i) {
      fac_[i] = mul_mod_ex(fac_[i - 1], i, p_);
    }
  }

  uint64 s(int64 x) { return x & 1 ? p_ - 1 : 1; }
  uint64 comb(int64 m, int64 n) {
    if (m < 0 || n > m) return 0;
    if (n == m || n == 0) return 1;
    if (n == 1 || n == m - 1) return m % p_;

    int64 pp = 0;
    int64 dist = m - n;

    for (uint64 mm = m / p_, nn = n / p_, dd = dist / p_; mm;
         mm /= p_, nn /= p_, dd /= p_) {
      pp += mm - nn - dd;
    }
    if (pp) return 0;
    uint64 l = 1, r = 1;
    for (uint64 x = m; x; x /= p_) {
      l = mul_mod_ex(l, s(x / p_), p_);
      l = mul_mod_ex(l, fac_[x % p_], p_);
    }
    for (uint64 x = n; x; x /= p_) {
      r = mul_mod_ex(r, s(x / p_), p_);
      r = mul_mod_ex(r, fac_[x % p_], p_);
    }
    for (uint64 x = dist; x; x /= p_) {
      r = mul_mod_ex(r, s(x / p_), p_);
      r = mul_mod_ex(r, fac_[x % p_], p_);
    }
    return mul_mod_ex(inv_of(r, p_), l, p_);
  }

 private:
  uint64 p_, f_;
  vector<uint64> fac_;
};

int64 short_comb_mod(int64 n, int64 m, int64 mod) {
  if (m > n || m < 0) return 0;
  if (n - m < m) m = n - m;
  vector<int64> data;
  for (int64 i = n; i >= n - m + 1; --i) data.push_back(i);
  const int size = static_cast<int>(data.size());
  for (int i = 2; i <= m; ++i) {
    int64 a = i;
    for (int j = 0; j < size && a > 1; ++j) {
      for (;;) {
        int64 t = gcd(a, data[j]);
        if (t == 1) break;
        a /= t;
        data[j] /= t;
      }
    }
  }
  int64 ret = 1;
  for (int i = 0; i < size; ++i) ret = mul_mod_ex(ret, data[i], mod);
  return ret;
}

/**
 * Calculates C(n, m) % p where p is a large prime.
 * The complexity is log(m) M(p^(1/2))
 */
struct CombModerEx {
  CombModerEx(uint64 p) : p_(p), fmoder_(p) {}
  int64 s(int64 x) { return x & 1 ? p_ - 1 : 1; }
  int64 comb(int64 m, int64 n) {
    if (m < 0 || n > m) return 0;
    if (n == m || n == 0) return 1;
    if (n == 1 || n == m - 1) return m % p_;

    int64 pp = 0;
    int64 dist = m - n;

    for (int64 mm = m / p_, nn = n / p_, dd = dist / p_; mm;
         mm /= p_, nn /= p_, dd /= p_) {
      pp += mm - nn - dd;
    }
    if (pp) return 0;
    int64 l = 1, r = 1;
    for (int64 x = m; x; x /= p_) {
      l = mul_mod_ex(l, s(x / p_), p_);
      l = mul_mod_ex(l, fmoder_.cal(x % p_), p_);
    }
    for (int64 x = n; x; x /= p_) {
      r = mul_mod_ex(r, s(x / p_), p_);
      r = mul_mod_ex(r, fmoder_.cal(x % p_), p_);
    }
    for (int64 x = dist; x; x /= p_) {
      r = mul_mod_ex(r, s(x / p_), p_);
      r = mul_mod_ex(r, fmoder_.cal(x % p_), p_);
    }

    return mul_mod_ex(inv_of(r, p_), l, p_);
  }

 private:
  uint64 p_;
  FactModer fmoder_;
};

/**
 * Computes 1^k + 2^k + ... n^k based on Bernoulli number.
 * It uses O(k^2) to initialize Bernoulli number.
 * It is recommended to use PowerSumModerB or PowerSumModerB1 to support larger
 * k.
 */
struct PowerSumModer {
  PowerSumModer(int64 mod, int maxk = 128) : mod_(mod), maxk_(maxk) {
    init(maxk);
  }

  ~PowerSumModer() = default;

  void init(int maxk = 128) {
    this->maxk_ = maxk;

    vector<vector<int64>>(maxk + 1).swap(p_);
    for (int i = 0; i <= maxk; ++i) {
      vector<int64>(maxk + 1).swap(p_[i]);
    }

    vector<int64>(maxk + 2).swap(invs_);

    init_inv(&invs_[0], maxk + 1, mod_);
    for (int i = 0; i <= maxk; ++i)
      for (int j = 0; j <= maxk; ++j) {
        p_[i][j] = 0;
      }
    for (int i = 0; i <= maxk; ++i) p_[i][1] = 1;
    for (int i = 1; i <= maxk; ++i) {
      for (int j = 1; j < i; ++j) {
        int64 t = p_[i - 1][j - 1] + p_[i - 1][j];
        if (t >= mod_) t -= mod_;
        p_[i][j] = mul_mod_ex(j, t, mod_);
      }
      p_[i][i] = 1;
      for (int j = 1; j <= i; ++j) {
        p_[i][i] = mul_mod_ex(p_[i][i], j, mod_);
      }
    }
  }

  // n + 1, n, ..., n-k+1 is not divisible by mod
  // 2,3,...k+1 is not divisible by mod
  int64 cal(int64 n, int64 k) {
    PE_ASSERT(k <= maxk_);

    int64 ret = 0;
    int64 c = (n + 1) % mod_;
    for (int i = 1; i <= k; ++i) {
      // ret += P[k][i] * short_comb_mod(n + 1, i + 1, mod) % mod;
      c = mul_mod_ex(c, regulate_mod(n + 1 - i, mod_), mod_);
      c = mul_mod_ex(c, invs_[i + 1], mod_);
      if (c == 0) {
        break;
      }
      ret += mul_mod_ex(p_[k][i], c, mod_);
      if (ret >= mod_) ret -= mod_;
    }
    return ret % mod_;
  }

  int64 cal_safe(int64 n, int64 k) {
    PE_ASSERT(k <= maxk_);

    int64 A, B;
    tie(A, B) = extract_factor(n + 1, mod_);

    int64 ret = 0;
    int64 c = A;
    int64 d = B;
    for (int i = 1; i <= k; ++i) {
      // ret += P[k][i] * short_comb_mod(n + 1, i + 1, mod) % mod;
      tie(A, B) = extract_factor(n + 1 - i, mod_);
      d += B;
      c = mul_mod_ex(c, regulate_mod(A, mod_), mod_);

      tie(A, B) = extract_factor(i + 1, mod_);
      d -= B;
      c = mul_mod_ex(c, invs_[A], mod_);

      if (c == 0) {
        break;
      }

      if (d == 0) {
        ret += mul_mod_ex(p_[k][i], c, mod_);
        if (ret >= mod_) ret -= mod_;
      }
    }
    return ret % mod_;
  }

 private:
  int64 mod_;
  int maxk_;
  vector<vector<int64>> p_;
  vector<int64> invs_;
};

/**
 * Computes 1^k + 2^k + ... n^k based on Bernoulli number
 * See
 * https://en.wikipedia.org/wiki/Bernoulli_number#Sum_of_powers
 * https://blog.csdn.net/acdreamers/article/details/38929067
 */
struct PowerSumModerB {
  PowerSumModerB(int64 mod, int64 maxk = 128) : mod_(mod), maxk_(maxk) {
    init(maxk);
  }

  ~PowerSumModerB() = default;

  void init(int64 maxk = 128) {
    this->maxk_ = maxk;

    this->maxk_ = maxk;

    vector<int64>(maxk + 1).swap(bnl_);
    vector<int64>(maxk + 2).swap(invs_);

    init_inv(&invs_[0], maxk + 1, mod_);
    init_bernoulli_number(&bnl_[0], maxk + 1, &invs_[0], mod_);

    bnl_[1] = mod_ - bnl_[1];
  }

  // n + 1, n, ..., n-k+1 is not divisible by mod
  // 2,3,...k+1 is not divisible by mod
  int64 cal(int64 n, int64 k) {
    PE_ASSERT(k <= maxk_);

    int64 ret = 0;

    int64 invn = power_mod_ex(n % mod_, mod_ - 2, mod_);
    int64 c = power_mod_ex(n % mod_, k + 1, mod_);

    for (int64 i = 0; i <= k; ++i) {
      if (i > 0) {
        c = mul_mod_ex(c, regulate_mod(k + 2 - i, mod_), mod_);
        c = mul_mod_ex(c, invs_[i], mod_);
        c = mul_mod_ex(c, invn, mod_);
      }

      if (c == 0) {
        break;
      }

      ret += mul_mod_ex(c, bnl_[i], mod_);
      if (ret >= mod_) ret -= mod_;
    }
    ret = mul_mod_ex(ret, invs_[k + 1], mod_);
    return ret;
  }

  int64 cal_safe(int64 n, int64 k) {
    PE_ASSERT(k <= maxk_);

    int64 ret = 0;

    int64 invn = power_mod_ex(n % mod_, mod_ - 2, mod_);
    int64 c = power_mod_ex(n % mod_, k + 1, mod_);

    int64 d = 0;
    for (int64 i = 0; i <= k; ++i) {
      if (i > 0) {
        int64 A, B;

        tie(A, B) = extract_factor(k + 2 - i, mod_);
        d += B;
        c = mul_mod_ex(c, regulate_mod(A, mod_), mod_);

        tie(A, B) = extract_factor(i, mod_);
        d -= B;
        c = mul_mod_ex(c, invs_[A], mod_);

        c = mul_mod_ex(c, invn, mod_);
      }
      if (c == 0) {
        break;
      }
      if (d == 0) {
        ret += mul_mod_ex(c, bnl_[i], mod_);
        if (ret >= mod_) ret -= mod_;
      }
    }
    ret = mul_mod_ex(ret, invs_[k + 1], mod_);
    return ret;
  }

 private:
  int64 mod_;
  int64 maxk_;
  vector<int64> bnl_;
  vector<int64> invs_;
};

/**
 * Computes 1^k + 2^k + ... n^k based on Bernoulli number
 * See
 * https://en.wikipedia.org/wiki/Bernoulli_number#Sum_of_powers
 * https://blog.csdn.net/acdreamers/article/details/38929067
 */
struct PowerSumModerB1 {
  PowerSumModerB1(int64 mod, int64 maxk = 128) : mod_(mod), maxk_(maxk) {
    init(maxk);
  }

  ~PowerSumModerB1() = default;

  void init(int64 maxk = 128) {
    this->maxk_ = maxk;

    this->maxk_ = maxk;

    vector<int64>(maxk + 1).swap(bnl_);
    vector<int64>(maxk + 2).swap(invs_);

    init_inv(&invs_[0], maxk + 1, mod_);
    init_bernoulli_number(&bnl_[0], maxk + 1, &invs_[0], mod_);
  }

  // n + 1, n, ..., n-k+1 is not divisible by mod
  // 2,3,...k+1 is not divisible by mod
  int64 cal(int64 n, int64 k) {
    PE_ASSERT(k <= maxk_);

    const int64 n1 = (n + 1) % mod_;
    const int64 k1 = k + 1;

    int64 ret = 0;

    int64 c = 1 % mod_;
    for (int64 i = 1; i <= k1; ++i) {
      c = mul_mod_ex(c, regulate_mod(k1 - i + 1, mod_), mod_);
      c = mul_mod_ex(c, invs_[i], mod_);
      c = mul_mod_ex(c, n1, mod_);

      if (c == 0) {
        break;
      }

      ret += mul_mod_ex(c, bnl_[k1 - i], mod_);
      if (ret >= mod_) ret -= mod_;
    }
    ret = mul_mod_ex(ret, invs_[k1], mod_);
    return ret;
  }

  int64 cal_safe(int64 n, int64 k) {
    PE_ASSERT(k <= maxk_);

    const int64 n1 = (n + 1) % mod_;
    const int64 k1 = k + 1;

    int64 ret = 0;

    int64 c = 1 % mod_;
    int64 d = 0;
    for (int64 i = 1; i <= k1; ++i) {
      int64 A, B;

      tie(A, B) = extract_factor(k1 - i + 1, mod_);
      d += B;
      c = mul_mod_ex(c, regulate_mod(A, mod_), mod_);

      tie(A, B) = extract_factor(i, mod_);
      d -= B;
      c = mul_mod_ex(c, invs_[A], mod_);

      c = mul_mod_ex(c, n1, mod_);

      if (c == 0) {
        break;
      }
      if (d == 0) {
        ret += mul_mod_ex(c, bnl_[k1 - i], mod_);
        if (ret >= mod_) ret -= mod_;
      }
    }
    ret = mul_mod_ex(ret, invs_[k1], mod_);
    return ret;
  }

 private:
  int64 mod_;
  int64 maxk_;
  vector<int64> bnl_;
  vector<int64> invs_;
};

SL int64 power_sum(int64 n, int64 k, int64 mod) {
  return PowerSumModerB(mod, k).cal(n, k);
}

SL int64 power_sum_safe(int64 n, int64 k, int64 mod) {
  return PowerSumModerB(mod, k).cal_safe(n, k);
}

/**
 * Computes (1^k+2^k+...+n^k)%mod and store it in result[k].
 * comb[i][j] is Binomial coefficient.
 * Complex: O(k^2)
 */
template <typename T, int D>
SL void init_power_sum_mod(int64 n, const int maxk, int* result, T (*comb)[D],
                           const int64 mod) {
  PE_ASSERT(maxk < D);
  result[0] = n % mod;
  for (int i = 1; i <= maxk; ++i) {
    int64 tmp = power_mod_ex(n, i + 1, mod);
    for (int j = 1; j <= i + 1; ++j) {
      if (j & 1) {
        tmp = sub_mod(tmp, mul_mod_ex(comb[i + 1][j], result[i + 1 - j], mod),
                      mod);
      } else {
        tmp = add_mod(tmp, mul_mod_ex(comb[i + 1][j], result[i + 1 - j], mod),
                      mod);
      }
    }
    result[i] = tmp * inv_of(comb[i + 1][1], mod) % mod;
  }
}

// Sum of 1 + 2 + 3 + ... + n
SL int64 ap_sum_mod(int64 n, int64 mod) {
  if (n == 0) return 0;
  if (n < 0) return regulate_mod(-ap_sum_mod(-n, mod), mod);
  return n & 1 ? mul_mod_ex(((n + 1) >> 1) % mod, n % mod, mod)
               : mul_mod_ex((n >> 1) % mod, (n + 1) % mod, mod);
}

// Sum of arithmetic progression
// a <= a, a + delta, a + 2 delta, ..., a + maxk detla <= b for delta >= 0 or
// a >= a, a + delta, a + 2 delta, ..., a + maxk delta >= b for delta < 0
SL int64 ap_sum_mod(int64 a, int64 b, int64 mod, int64 delta = 1) {
  if (delta == 0) {
    PE_ASSERT(a == b);
    return a;
  }
  if (delta > 0 && a > b) return 0;
  if (delta < 0 && a < b) return 0;
  const int64 maxk = (b - a) / delta;
  PE_ASSERT(maxk >= 0);
  const int64 t0 = mul_mod_ex((maxk + 1) % mod, regulate_mod(a, mod), mod);
  // delta, 2 delta, maxk delta
  const int64 t1 =
      mul_mod_ex(regulate_mod(delta, mod), ap_sum_mod(maxk, mod), mod);
  return add_mod(t0, t1, mod);
}

// Sum of 1^2 + 2^2 + 3^2 + ... + n^2
// Assume no overflow for 2 * n + 1
SL int64 square_sum_mod(int64 n, int64 mod) {
  if (n <= 0) return 0;
  // n*(n + 1)*(2 n + 1)/6
  int64 a = n, b = n + 1, c = 2 * n + 1;
  switch (n % 6) {
    case 0:
      a /= 6;
      break;
    case 1:
      b >>= 1, c /= 3;
      break;
    case 2:
      a >>= 1, b /= 3;
      break;
    case 3:
      a /= 3, b >>= 1;
      break;
    case 4:
      a >>= 1, c /= 3;
      break;
    case 5:
      b /= 6;
      break;
  }
  return mul_mod_ex(a % mod, mul_mod_ex(b % mod, c % mod, mod), mod);
}

// Sum of 1^3 + 2^3 + 3^3 + ... + n^3
SL int64 cube_sum_mod(int64 n, int64 mod) {
  if (n <= 0) return 0;
  // (n*(n + 1)/2)^2
  const int64 a = ap_sum_mod(n, mod);
  return mul_mod_ex(a, a, mod);
}

// Sum of 1^4 + 2^4 + 3^4 + ... + n^4
// Assume no overflow for 2 * n
SL int64 quad_sum_mod(int64 n, int64 mod) {
  if (n <= 0) return 0;
  // (3*n*(n + 1) - 1)*(2*n + 1)*(n + 1)*n/30
  // Handle (2*n + 1)*(n + 1)*n/6
  int64 a = n, b = n + 1, c = 2 * n + 1;
  switch (n % 6) {
    case 0:
      a /= 6;
      break;
    case 1:
      b >>= 1, c /= 3;
      break;
    case 2:
      a >>= 1, b /= 3;
      break;
    case 3:
      a /= 3, b >>= 1;
      break;
    case 4:
      a >>= 1, c /= 3;
      break;
    case 5:
      b /= 6;
      break;
  }
  int done = 0;
  if (!done && a % 5 == 0) a /= 5, done = 1;
  if (!done && b % 5 == 0) b /= 5, done = 1;
  if (!done && c % 5 == 0) c /= 5, done = 1;
  const int64 d = mul_mod_ex(a % mod, mul_mod_ex(b % mod, c % mod, mod), mod);
  if (done) {
    const int64 t0 = mul_mod_ex(n % mod, (n + 1) % mod, mod);
    const int64 t1 = sub_mod(mul_mod_ex(3LL, t0, mod), 1, mod);
    return mul_mod_ex(d, t1, mod);
  }
  // Handle (3*n*n + 3*n - 1)/5
  switch (n % 5) {
    // 3*n*n + 3*n - 1 =
    // 3*(n - 1)*(n - 1) + 5*n + 4*(n - 1)
    // (n - 1)*(3*(n - 1) + 4) + 5*n
    // (n - 1)*(3 n + 1) + 5*n
    case 1: {
      const int64 t0 = add_mod(mul_mod_ex(3LL, n, mod), 1, mod);
      const int64 t1 =
          add_mod(mul_mod_ex((n - 1) / 5 % mod, t0, mod), n % mod, mod);
      return mul_mod_ex(d, t1, mod);
    }
    // 3*n*n + 3*n - 1 =
    // 3*(n - 3)*(n - 3) + 7*(3*n - 4)
    // 3*(n - 3)*(n - 3) + 7*(3*(n - 3) + 5)
    // 3*(n - 3)*(n - 3) + 7*3*(n - 3) + 35
    // 3*(n - 3)*(n + 4) + 35
    case 3: {
      const int64 t0 = mul_mod_ex(
          3LL, mul_mod_ex((n - 3) / 5 % mod, (n + 4) % mod, mod), mod);
      const int64 t1 = add_mod(t0, 7, mod);
      return mul_mod_ex(d, t1, mod);
    }
    default:
      PE_ASSERT(0);
  }
  return 0;
}

// Sum of 1^5 + 2^5 + 3^5 + ... + n^5
// Assume no overflow for 2 * n
SL int64 pent_sum_mod(int64 n, int64 mod) {
  if (n <= 0) return 0;
  // n^2*(n + 1)^2*(2*n^2 + 2*n - 1)/12
  // Handle (n (n + 1))^2/4
  int64 a = n, b = n, c = n + 1, d = n + 1;
  if (n % 2 == 0) {
    a >>= 1, b >>= 1;
  } else {
    c >>= 1, d >>= 1;
  }
  int done = 0;
  if (!done && a % 3 == 0) a /= 3, done = 1;
  if (!done && c % 3 == 0) c /= 3, done = 1;
  const int64 e = mul_mod_ex(mul_mod_ex(a % mod, b % mod, mod),
                             mul_mod_ex(c % mod, d % mod, mod), mod);
  if (done) {
    const int64 t0 = add_mod(n, n, mod);
    const int64 t1 = mul_mod_ex(t0, n, mod);
    const int64 t2 = sub_mod(add_mod(t0, t1, mod), 1, mod);
    return mul_mod_ex(e, t2, mod);
  }
  // Handle (2*n^2 + 2*n - 1)/3
  // We have n%3 = 1
  // 2*n^2 + 2*n - 1 = 2*(n-1)^2 + 6n - 3
  const int64 t0 = mul_mod_ex((n - 1) / 3 % mod, (n - 1) % mod, mod);
  const int64 t1 = add_mod(add_mod(t0, t0, mod), (2 * n - 1) % mod, mod);
  return mul_mod_ex(e, t1, mod);
}

// Sum of 1^6 + 2^6 + 3^6 + ... + n^6
// Assume no overflow for 2 * n
SL int64 hexa_sum_mod(int64 n, int64 mod) {
  if (n <= 0) return 0;
  // n*(1 + n)*(1 + 2*n)*(1 - 3*n + 6*n^3 + 3*n^4)/42
  // Handle n*(1 + n)*(1 + 2*n)/6
  // n*(n + 1)*(2*n + 1)/6
  int64 a = n, b = n + 1, c = 2 * n + 1;
  switch (n % 6) {
    case 0:
      a /= 6;
      break;
    case 1:
      b >>= 1, c /= 3;
      break;
    case 2:
      a >>= 1, b /= 3;
      break;
    case 3:
      a /= 3, b >>= 1;
      break;
    case 4:
      a >>= 1, c /= 3;
      break;
    case 5:
      b /= 6;
      break;
  }
  int done = 0;
  if (!done && a % 7 == 0) a /= 7, done = 1;
  if (!done && b % 7 == 0) b /= 7, done = 1;
  if (!done && c % 7 == 0) c /= 7, done = 1;
  const int64 d = mul_mod_ex(a % mod, mul_mod_ex(b % mod, c % mod, mod), mod);
  if (done) {
    const int64 n1 = n % mod;
    const int64 n2 = mul_mod_ex(n1, n1, mod);
    const int64 n3 = mul_mod_ex(n1, n2, mod);
    const int64 n4 = mul_mod_ex(n2, n2, mod);
    const int64 t0 = sub_mod(add_mod(n4, 2 * n3 % mod, mod), n1, mod);
    const int64 t1 = add_mod(mul_mod_ex(3, t0, mod), 1, mod);
    return mul_mod_ex(d, t1, mod);
  }
  // Handle (1 - 3*n + 6*n^3 + 3*n^4)/7
  const int64 n1 = n % mod;
  const int64 n2 = mul_mod_ex(n1, n1, mod);
  const int64 n3 = mul_mod_ex(n1, n2, mod);
  switch (n % 7) {
    // 3*(2 + 3*n + 3*n^2 + n^3)*(n - 1) + 7
    case 1: {
      const int64 t0 = add_mod(2LL, mul_mod_ex(3LL, n1, mod), mod);
      const int64 t1 = add_mod(mul_mod_ex(3LL, n2, mod), n3, mod);
      const int64 t2 = mul_mod_ex(mul_mod_ex(3LL, add_mod(t0, t1, mod), mod),
                                  (n - 1) / 7 % mod, mod);
      const int64 t3 = add_mod(t2, 1, mod);
      return mul_mod_ex(d, t3, mod);
    }
    // 3*(15 + 8*n + 4*n^2 + n^3)*(n - 2) + 91
    case 2: {
      const int64 t0 = add_mod(15LL, mul_mod_ex(8LL, n1, mod), mod);
      const int64 t1 = add_mod(mul_mod_ex(4LL, n2, mod), n3, mod);
      const int64 t2 = mul_mod_ex(mul_mod_ex(3LL, add_mod(t0, t1, mod), mod),
                                  (n - 2) / 7 % mod, mod);
      const int64 t3 = add_mod(t2, 13LL, mod);
      return mul_mod_ex(d, t3, mod);
    }
    // 3*(-10 + 3 n - n^2 + n^3)*(n + 3) + 91
    case 4: {
      const int64 t0 = sub_mod(mul_mod_ex(3LL, n1, mod), 10LL, mod);
      const int64 t1 = sub_mod(n3, n2, mod);
      const int64 t2 = mul_mod_ex(mul_mod_ex(3LL, add_mod(t0, t1, mod), mod),
                                  (n + 3) / 7 % mod, mod);
      const int64 t3 = add_mod(t2, 13LL, mod);
      return mul_mod_ex(d, t3, mod);
    }
    // 3*(-1 + n^3)*(n + 2) + 7
    case 5: {
      const int64 t0 = mul_mod_ex(3LL, sub_mod(n3, 1LL, mod), mod);
      const int64 t1 = mul_mod_ex(t0, (n + 2) / 7 % mod, mod);
      const int64 t2 = add_mod(t1, 1LL, mod);
      return mul_mod_ex(d, t2, mod);
    }
    default:
      PE_ASSERT(0);
  }
  return 0;
}

// Sum of 1^7 + 2^7 + 3^7 + ... + n^7
// Assume no overflow for 2 * n
SL int64 hept_sum_mod(int64 n, int64 mod) {
  if (n <= 0) return 0;
  // n^2 * (1 + n)^2 * (2 - 4 n - n^2 + 6 n^3 + 3 n^4)/24
  // Handle (n (n + 1))^2/4
  int64 a = n, b = n, c = n + 1, d = n + 1;
  if (n % 2 == 0) {
    a >>= 1, b >>= 1;
  } else {
    c >>= 1, d >>= 1;
  }
  int done3 = 0;
  if (!done3 && a % 3 == 0) a /= 3, done3 = 1;
  if (!done3 && c % 3 == 0) c /= 3, done3 = 1;
  // Handle (2 - 4 n - n^2 + 6 n^3 + 3 n^4)/6
  // Expand[1/6 (2 - 4 n - n^2 + 6 n^3 + 3 n^4) /. {n -> 6 k + f}]
  // 1/3 - (2 f)/3 - f^2/6 + f^3 + f^4/2 - 4 k - 2 f k + 18 f^2 k +
  // 12 f^3 k - 6 k^2 + 108 f k^2 + 108 f^2 k^2 + 216 k^3 + 432 f k^3 +
  // 648 k^4
  const int64 k = n / 6;
  const int64 k1 = k % mod;
  const int64 k2 = mul_mod_ex(k1, k1, mod);
  const int64 k3 = mul_mod_ex(k2, k1, mod);
  const int64 k4 = mul_mod_ex(k2, k2, mod);
  const int64 f1 = n % 6;
  const int64 f2 = f1 * f1;
  const int64 f3 = f2 * f1;
  const int64 f4 = f2 * f2;
  int64 t0 = sub_mod(0LL, mul_mod_ex(4LL, k1, mod), mod);
  t0 = sub_mod(t0, mul_mod_ex(2LL, mul_mod_ex(f1, k1, mod), mod), mod);
  t0 = add_mod(t0, mul_mod_ex(18LL, mul_mod_ex(f2, k1, mod), mod), mod);
  t0 = add_mod(t0, mul_mod_ex(12LL, mul_mod_ex(f3, k1, mod), mod), mod);
  t0 = sub_mod(t0, mul_mod_ex(6LL, k2, mod), mod);
  t0 = add_mod(t0, mul_mod_ex(108LL, mul_mod_ex(f1, k2, mod), mod), mod);
  t0 = add_mod(t0, mul_mod_ex(108LL, mul_mod_ex(f2, k2, mod), mod), mod);
  t0 = add_mod(t0, mul_mod_ex(216LL, k3, mod), mod);
  t0 = add_mod(t0, mul_mod_ex(432LL, mul_mod_ex(f1, k3, mod), mod), mod);
  t0 = add_mod(t0, mul_mod_ex(648LL, k4, mod), mod);
  if (done3) {
    t0 = mul_mod_ex(3LL, t0, mod);
  }
  const int64 t1 = (3 * f4 + 6 * f3 - f2 - 4 * f1 + 2) / (done3 ? 2 : 6) % mod;
  const int64 t2 = mul_mod_ex(mul_mod_ex(a % mod, b % mod, mod),
                              mul_mod_ex(c % mod, d % mod, mod), mod);
  return mul_mod_ex(add_mod(t0, t1, mod), t2, mod);
}

#define p1_sum_mod ap_sum_mod
#define p2_sum_mod square_sum_mod
#define p3_sum_mod cube_sum_mod
#define p4_sum_mod quad_sum_mod
#define p5_sum_mod pent_sum_mod
#define p6_sum_mod hexa_sum_mod
#define p7_sum_mod hept_sum_mod

#if 0
// Sum of geometric progression
// (x^a+x^(a+1)+x^(a+2)+...+x^b) % mod
// a >= 0
// zeroPzero: 0^0
// if b < a: return 0
SL int64 gp_sum_mod(int64 x, int64 a, int64 b, int64 mod, int64 zeroPzero = 1) {
  if (mod == 1) return 0;
  if (b < a) return 0;
  x %= mod;
  if (a > 0 || x > 0) {
    if (x == 0) return 0;
    if (x == 1) return (b - a + 1) % mod;
    // (x^(b+1)-x^a) / (x - 1)
    const int64 u = power_mod_ex(x, b + 1, mod);
    const int64 v = power_mod_ex(x, a, mod);
    const int64 w = sub_mod(u, v, mod);
    const int64 t = inv_of(sub_mod(x, 1, mod), mod);
    return mul_mod_ex(w, t, mod);
  }
  // a == 0 and x == 0
  return zeroPzero % mod;
}

SL int64 gp_sum_mod_ivx1(int64 x, int64 invXSub1, int64 a, int64 b, int64 mod,
                         int64 zeroPzero = 1) {
  if (mod == 1) return 0;
  if (b < a) return 0;
  x %= mod;
  if (a > 0 || x > 0) {
    if (x == 0) return 0;
    if (x == 1) return (b - a + 1) % mod;
    // (x^(b+1)-x^a) / (x - 1)
    const int64 u = power_mod_ex(x, b + 1, mod);
    const int64 v = power_mod_ex(x, a, mod);
    const int64 w = sub_mod(u, v, mod);
    return mul_mod_ex(w, invXSub1, mod);
  }
  // a == 0 and x == 0
  return zeroPzero % mod;
}

// Sum of geometric progression
// (x^a+x^(a+1)+x^(a+2)+...+x^b) % mod
// a >= 0
// zeroPzero: 0^0
// if b < a: return 0
SL int64 gp_sum_mod(int64 x, int64 a, int64 b, int64 mod,
                    int64 zero_p_zero = 1) {
  if (mod == 1 || b < a) return 0;
  if (b < a) return 0;
  x %= mod;
  // |x 0|^(b-a) x^a
  // |x 1|       x^a
  int64 data[3][2][2] = {0};
  auto* m = data[0];
  auto* r = data[1];
  auto* t = data[2];
  m[0][0] = x;
  m[1][0] = x;
  m[1][1] = 1;
  r[0][0] = a == 0 && x == 0 ? zero_p_zero : power_mod_ex(x, a, mod);
  r[1][0] = r[0][0];
  for (int64 n = b - a; n > 0; n >>= 1) {
    if (n & 1) {
      for (int i = 0; i < 2; ++i) {
        int64 s = 0;
        for (int k = 0; k < 2; ++k) {
          s = add_mod(s, mul_mod_ex(m[i][k], r[k][0], mod), mod);
        }
        t[i][0] = s;
      }
      swap(t, r);
    }
    if (n > 1) {
      for (int i = 0; i < 2; ++i)
        for (int j = 0; j < 2; ++j) {
          int64 s = 0;
          for (int k = 0; k < 2; ++k) {
            s = add_mod(s, mul_mod_ex(m[i][k], m[k][j], mod), mod);
          }
          t[i][j] = s;
        }
      swap(t, m);
    }
  }
  return r[1][0];
}
#endif

// Sum of geometric progression
// (x^a+x^(a+1)+x^(a+2)+...+x^b) % mod
// a >= 0
// zero_p_zero: 0^0
// if b < a: return 0
SL int64 gp_sum_mod(int64 x, int64 a, int64 b, int64 mod,
                    int64 zero_p_zero = 1) {
  if (mod == 1 || b < a) return 0;
  if (b < a) return 0;
  x %= mod;
  // |x 0|^(b-a) x^a
  // |x 1|       x^a
  int64 u = x;
  int64 w = x;
  int64 v1 = a == 0 && x == 0 ? zero_p_zero : power_mod_ex(x, a, mod);
  int64 v2 = v1;
  for (int64 n = b - a; n > 0; n >>= 1) {
    if (n & 1) {
      v2 = add_mod(mul_mod_ex(w, v1, mod), v2, mod);
      v1 = mul_mod_ex(u, v1, mod);
    }
    if (n > 1) {
      w = add_mod(mul_mod_ex(w, u, mod), w, mod);
      u = mul_mod_ex(u, u, mod);
    }
  }
  return v2;
}

/**
 * Counts the number of square free number no more than n.
 * If n is no more than pivot, use a pre-computed table.
 */
struct SFCounter {
  SFCounter(int64 pivot_ = ::maxp) : pivot_(pivot_) {
    if (::maxp > 0) {
      init(pivot_);
    }
  }

  ~SFCounter() = default;

  void init(int64 pivot_ = ::maxp) {
    this->pivot_ = pivot_;
    pre_.resize(pivot_ + 1);
    pre_[0] = 0;
    for (int64 i = 1; i <= pivot_; ++i) {
      pre_[i] = pre_[i - 1] + is_square_free(i);
    }
  }

  int64 get(int64 n) {
    if (n <= pivot_) return pre_[n];
    auto where = mem_.find(n);
    if (where != mem_.end()) return where->second;
    int64 ret = n;
    for (int64 i = 2;; ++i) {
      int64 i2 = i * i;
      if (i2 > n) break;
      ret -= get(n / i2);
    }
    return mem_[n] = ret;
  }

 private:
  int64 pivot_;
  vector<int64> pre_;
  unordered_map<int64, int64> mem_;
};

template <typename T = int64>
struct MuSummer {
  MuSummer(int64 pivot_ = ::maxp) : pivot_(pivot_) {
    if (::maxp > 0) {
      init(pivot_);
    }
  }

  ~MuSummer() = default;

  void init(int64 pivot_ = ::maxp) {
    this->pivot_ = pivot_;

    PE_ASSERT(pivot_ <= ::maxp);

    pre_.resize(pivot_ + 1);
    pre_[0] = 0;
    for (int i = 1; i <= pivot_; ++i) {
      pre_[i] = ::mu[i] + pre_[i - 1];
    }
  }

  T get(const int64 n) {
    if (n <= pivot_) return pre_[n];

    auto where = mem_.find(n);
    if (where != mem_.end()) return where->second;

    T ret = 1;
    for (int64 i = 2; i <= n;) {
      int64 v = n / i;
      int64 maxi = n / v;
      ret -= (maxi - i + 1) * get(v);
      i = maxi + 1;
    }
    return mem_[n] = ret;
  }

 private:
  int64 pivot_;
  vector<T> pre_;
  unordered_map<int64, T> mem_;
};

template <typename T = int64>
struct MuPhiSummer {
  MuPhiSummer(int64 pivot_ = ::maxp) : pivot_(pivot_) {
    if (::maxp > 0) {
      init(pivot_);
    }
  }

  ~MuPhiSummer() = default;

  void init(int64 pivot_ = ::maxp) {
    this->pivot_ = pivot_;

    PE_ASSERT(pivot_ <= ::maxp);

    pre_sum_mu_.resize(pivot_ + 1);
    pre_sum_phi_.resize(pivot_ + 1);
    pre_sum_mu_[0] = pre_sum_phi_[0] = 0;
    for (int i = 1; i <= pivot_; ++i) {
      pre_sum_mu_[i] = ::mu[i] + pre_sum_mu_[i - 1];
      pre_sum_phi_[i] = ::phi[i] + pre_sum_phi_[i - 1];
    }
  }

  T get_sum_mu(const int64 n) {
    if (n <= pivot_) return pre_sum_mu_[n];

    auto where = mem_sum_mu_.find(n);
    if (where != mem_sum_mu_.end()) return where->second;

    T ret = 1;
    for (int64 i = 2; i <= n;) {
      int64 v = n / i;
      int64 maxi = n / v;
      int64 d = maxi - i + 1;
      ret -= d * get_sum_mu(v);
      i = maxi + 1;
    }
    return mem_sum_mu_[n] = ret;
  }

  T get_sum_phi(int64 n) {
    if (n <= pivot_) return pre_sum_phi_[n];

    auto where = mem_sum_phi_.find(n);
    if (where != mem_sum_phi_.end()) return where->second;

    T ret = 0;
    T last = 0;
    for (int64 k = 1; k <= n;) {
      int64 v = n / k;
      int64 maxk = n / v;
      T now = get_sum_mu(maxk);

      T x = now - last;
      last = now;

      T s = 0;
      if (v & 1) {
        s = T(v + 1 >> 1) * v;
      } else {
        s = T(v >> 1) * (v + 1);
      }
      ret += s * x;
      k = maxk + 1;
    }
    return mem_sum_phi_[n] = ret;
  }

 private:
  int64 pivot_;

  vector<T> pre_sum_mu_;
  unordered_map<int64, T> mem_sum_mu_;

  vector<T> pre_sum_phi_;
  unordered_map<int64, T> mem_sum_phi_;
};

template <typename T = int64>
struct Sigma0Summer {
  Sigma0Summer(int64 pivot_ = ::maxp) : pivot_(pivot_) {
    if (::maxp > 0) {
      init(pivot_);
    }
  }

  ~Sigma0Summer() = default;

  void init(int64 pivot_ = ::maxp) {
    this->pivot_ = pivot_;

    PE_ASSERT(pivot_ <= ::maxp);

    pre_.resize(pivot_ + 1);
    fill(pre_.begin(), pre_.end(), 0);
    for (int i = 1; i <= pivot_; ++i) {
      for (int j = i; j <= pivot_; j += i) {
        ++pre_[j];
      }
    }
    for (int i = 1; i <= pivot_; ++i) {
      pre_[i] += pre_[i - 1];
    }
  }

  T get(const int64 n) {
    if (n <= pivot_) return pre_[n];

    auto where = mem_.find(n);
    if (where != mem_.end()) return where->second;

    T ret = 0;
    for (int64 i = 1; i * i <= n; ++i) {
      ret += n / i;
    }
    ret += ret;
    const T t = sqrti(n);
    return mem_[n] = ret - t * t;
  }

 private:
  int64 pivot_;

  vector<T> pre_;
  unordered_map<int64, T> mem_;
};

/**
 * Computes (the sum of mu[x] or phi[x]) % mod where x is no more than n.
 * If n is no more than pivot, use a pre-computed table.
 */
struct MuPhiSumModer {
  MuPhiSumModer(int64 mod, int64 pivot_ = ::maxp) : mod_(mod), pivot_(pivot_) {
    if (::maxp > 0) {
      init(pivot_);
    }
  }

  ~MuPhiSumModer() = default;

  void init(int64 pivot_ = ::maxp) {
    this->pivot_ = pivot_;

    PE_ASSERT(pivot_ <= ::maxp);

    pre_sum_mu_.resize(pivot_ + 1);
    pre_sum_phi_.resize(pivot_ + 1);
    pre_sum_mu_[0] = pre_sum_phi_[0] = 0;
    for (int i = 1; i <= pivot_; ++i) {
      pre_sum_mu_[i] = ::mu[i] + pre_sum_mu_[i - 1];
      pre_sum_phi_[i] = (::phi[i] + pre_sum_phi_[i - 1]) % mod_;
      if (pre_sum_mu_[i] < 0)
        pre_sum_mu_[i] += mod_;
      else if (pre_sum_mu_[i] >= mod_)
        pre_sum_mu_[i] -= mod_;
    }
  }

  int64 get_sum_mu(const int64 n) {
    if (n <= pivot_) return pre_sum_mu_[n];

    auto where = mem_sum_mu_.find(n);
    if (where != mem_sum_mu_.end()) return where->second;

    int64 ret = 1;
    for (int64 i = 2; i <= n;) {
      int64 v = n / i;
      int64 maxi = n / v;
      ret = sub_mod(ret, mul_mod_ex((maxi - i + 1) % mod_, get_sum_mu(v), mod_),
                    mod_);
      i = maxi + 1;
    }
    return mem_sum_mu_[n] = ret;
  }

  int64 get_sum_phi(int64 n) {
    if (n <= pivot_) return pre_sum_phi_[n];

    auto where = mem_sum_phi_.find(n);
    if (where != mem_sum_phi_.end()) return where->second;

    int64 ret = 0;
    int64 last = 0;
    for (int64 k = 1; k <= n;) {
      int64 v = n / k;
      int64 maxk = n / v;
      int64 now = get_sum_mu(maxk);

      int64 x = sub_mod(now, last, mod_);
      last = now;

      int64 s = 0;
      if (v & 1) {
        s = mul_mod_ex((v + 1) / 2 % mod_, v % mod_, mod_);
      } else {
        s = mul_mod_ex(v / 2 % mod_, (v + 1) % mod_, mod_);
      }
      ret = add_mod(ret, mul_mod_ex(s, x, mod_), mod_);
      k = maxk + 1;
    }
    return mem_sum_phi_[n] = ret;
  }

 private:
  int64 mod_;
  int64 pivot_;

  vector<int64> pre_sum_mu_;
  unordered_map<int64, int64> mem_sum_mu_;

  vector<int64> pre_sum_phi_;
  unordered_map<int64, int64> mem_sum_phi_;
};

struct Sigma0SumModer {
  Sigma0SumModer(int64 mod, int64 pivot = ::maxp) : mod_(mod), pivot_(pivot) {
    if (::maxp > 0) {
      init(pivot_);
    }
  }

  ~Sigma0SumModer() = default;

  void init(int64 pivot_ = ::maxp) {
    this->pivot_ = pivot_;

    PE_ASSERT(pivot_ <= ::maxp);

    pre_.resize(pivot_ + 1);
    fill(pre_.begin(), pre_.end(), 0);
    for (int i = 1; i <= pivot_; ++i) {
      for (int j = i; j <= pivot_; j += i) {
        ++pre_[j];
      }
    }
    for (int i = 1; i <= pivot_; ++i) {
      pre_[i] = add_mod(pre_[i] % mod_, pre_[i - 1], mod_);
    }
  }

  int64 get(const int64 n) {
    if (n <= pivot_) return pre_[n];

    auto where = mem_.find(n);
    if (where != mem_.end()) return where->second;

    int64 ret = 0;
    for (int64 i = 1; i * i <= n; ++i) {
      ret += n / i;
      if (ret >= mod_) {
        ret -= mod_;
      }
    }
    ret <<= 1;
    if (ret >= mod_) {
      ret -= mod_;
    }
    const int64 t = sqrti(n) % mod_;
    return mem_[n] = sub_mod(ret, mul_mod_ex(t, t, mod_), mod_);
  }

 private:
  int64 mod_;
  int64 pivot_;

  vector<int64> pre_;
  unordered_map<int64, int64> mem_;
};

template <typename T>
class DVA {
 public:
  template <typename IT>
  struct DVARange {
    IT first;
    IT last;
    DVARange(IT first, IT last) : first(first), last(last) {}
    IT begin() { return first; }
    IT end() { return last; }
  };

  template <typename IT>
  DVARange<IT> makeRange(IT first, IT last) const {
    return DVARange<IT>(first, last);
  }

  struct DVAItem {
    T value;
    int64 key;
    int idx;
  };

  struct DVAIteratorBase {
    using reference = DVAItem;
    using value_type = DVAItem;
    const std::vector<int64>& keys;
    const std::vector<T>& values;
    int idx;
    const int keySize;

    DVAIteratorBase(const std::vector<int64>& keys,
                    const std::vector<T>& values, int idx, int keySize)
        : keys(keys), values(values), idx(idx), keySize(keySize) {}

    DVAItem operator*() { return DVAItem{values[idx], keys[idx], idx}; }

    int operator==(const DVAIteratorBase& o) const {
      return idx == o.idx && keySize == o.keySize;
    }

    int operator!=(const DVAIteratorBase& o) const {
      return !(this->operator==(o));
    }
  };

  struct DVAIterator : public DVAIteratorBase {
    using reference = DVAItem;
    using value_type = DVAItem;
    using DVAIteratorBase::DVAIteratorBase;

    DVAIterator& operator++() {
      ++DVAIteratorBase::idx;
      return *this;
    }

    DVAIterator operator++(int) {
      return DVAIterator(DVAIteratorBase::keys, DVAIteratorBase::values,
                         DVAIteratorBase::idx++, DVAIteratorBase::keySize);
    }

    DVAIterator& operator--() {
      --DVAIteratorBase::idx;
      return *this;
    }

    DVAIterator operator--(int) {
      return DVAIterator(DVAIteratorBase::keys, DVAIteratorBase::values,
                         DVAIteratorBase::idx--, DVAIteratorBase::keySize);
    }
  };

  struct DVARIterator : public DVAIteratorBase {
    using reference = DVAItem;
    using value_type = DVAItem;
    using DVAIteratorBase::DVAIteratorBase;

    DVARIterator& operator++() {
      --DVAIteratorBase::idx;
      return *this;
    }

    DVARIterator operator++(int) {
      return DVARIterator(DVAIteratorBase::keys, DVAIteratorBase::values,
                          DVAIteratorBase::idx--, DVAIteratorBase::keySize);
    }

    DVARIterator& operator--() {
      ++DVAIteratorBase::idx;
      return *this;
    }

    DVARIterator operator--(int) {
      return DVARIterator(DVAIteratorBase::keys, DVAIteratorBase::values,
                          DVAIteratorBase::idx++, DVAIteratorBase::keySize);
    }
  };

 public:
  int64 n;
  int64 m;
  int is_perfect_square;

  std::vector<int64> keys;
  std::vector<T> values;
  int key_size;

  DVA(int64 n, T element = 0)
      : n(n), m(sqrti(n)), is_perfect_square(m * m == n) {
    keys.push_back(0);

    for (int64 i = 1; i <= m; ++i) {
      keys.push_back(i);
    }
    for (int64 i = n / m > m ? m : m - 1; i >= 1; --i) {
      keys.push_back(n / i);
    }
    key_size = (int)keys.size();
    values.resize(keys.size());
    fill(values.begin(), values.end(), element);
  }

  DVA(const DVA& other) = default;
  DVA(DVA&& other) noexcept = default;
  DVA& operator=(const DVA& other) = default;
  DVA& operator=(DVA&& other) noexcept = default;

  int idxOfValue(int64 v) const { return (int)(v <= m ? v : key_size - n / v); }

  T& operator[](int64 v) { return values[idxOfValue(v)]; }

  T operator[](int64 v) const { return values[idxOfValue(v)]; }

  DVARange<std::vector<int64>::const_iterator> fKeys() const {
    return makeRange(keys.begin() + 1, keys.end());
  }

  DVARange<std::vector<int64>::const_reverse_iterator> bKeys() const {
    return makeRange(keys.rbegin(), keys.rend() - 1);
  }

  DVARange<DVAIterator> fItems() const { return makeRange(begin(), end()); }

  DVARange<DVARIterator> bItems() const { return makeRange(rbegin(), rend()); }

  DVAIterator begin() const { return DVAIterator(keys, values, 1, key_size); }
  DVAIterator end() const {
    return DVAIterator(keys, values, key_size, key_size);
  }

  DVARIterator rbegin() const {
    return DVARIterator(keys, values, key_size - 1, key_size);
  }
  DVARIterator rend() const { return DVARIterator(keys, values, 0, key_size); }
};

template <typename T>
SL DVA<T> prime_s0(const int64 n) {
  PE_ASSERT(n >= 1);
  DVA<T> dva(n);

  for (auto& key : dva.fKeys()) dva[key] = key - 1;

  for (int64 p = 2; p <= dva.m; ++p)
    if (dva[p] != dva[p - 1]) {
      const auto pcnt = dva[p - 1];
      const int64 p2 = p * p;
      for (auto& key : dva.bKeys()) {
        if (key < p2) break;
        dva[key] -= dva[key / p] - pcnt;
      }
    }
  return dva;
}

template <typename T, int TN = 8>
SL DVA<T> prime_s0_parallel(const int64 n) {
  PE_ASSERT(n >= 1);
  DVA<T> dva(n);

  const int64 ks = dva.key_size;
  auto* keys = &dva.keys[0];
  auto* values = &dva.values[0];
  vector<T> tmpdata(ks);
  auto* tmp = &tmpdata[0];

  for (auto& key : dva.fKeys()) dva[key] = key - 1;

  int idx = 0;
  for (int64 p = 2; p <= dva.m; ++p)
    if (dva[p] != dva[p - 1]) {
      const auto pcnt = dva[p - 1];
      const int64 p2 = p * p;
      while (idx + 1 < ks && keys[idx + 1] < p2) ++idx;
#if ENABLE_OPENMP
      if (ks - idx > 400000) {
#pragma omp parallel for schedule(dynamic, 100000) num_threads(TN)
        for (int j = idx + 1; j < ks; ++j) {
          const int64 v = keys[j] / p;
          tmp[j] = values[j] - values[v <= dva.m ? v : ks - n / v] + pcnt;
        }
#pragma omp parallel for schedule(dynamic, 100000) num_threads(TN)
        for (int j = idx + 1; j < ks; ++j) {
          values[j] = tmp[j];
        }
      } else {
#endif
        for (int j = ks - 1; j > idx; --j) {
          const int64 v = keys[j] / p;
          values[j] -= values[v <= dva.m ? v : ks - n / v] - pcnt;
        }
#if ENABLE_OPENMP
      }
#endif
    }
  return dva;
}

#define prime_pi prime_s0

template <typename T>
SL DVA<T> prime_s1(const int64 n) {
  PE_ASSERT(n >= 1);
  DVA<T> dva(n);
  for (auto& key : dva.fKeys()) {
    if (key & 1) {
      T v((key + 1) >> 1);
      dva[key] = v * key - 1;
    } else {
      T v(key >> 1);
      dva[key] = v * (key + 1) - 1;
    }
  }

  for (int64 p = 2; p <= dva.m; ++p)
    if (dva[p] != dva[p - 1]) {
      const auto psum = dva[p - 1];
      const int64 p2 = p * p;
      for (auto& key : dva.bKeys()) {
        if (key < p2) break;
        dva[key] -= (dva[key / p] - psum) * p;
      }
    }
  return dva;
}

template <typename T, int TN = 8>
SL DVA<T> prime_s1_parallel(const int64 n) {
  PE_ASSERT(n >= 1);
  DVA<T> dva(n);

  const int64 ks = dva.key_size;
  auto* keys = &dva.keys[0];
  auto* values = &dva.values[0];
  vector<T> tmpdata(ks);
  auto* tmp = &tmpdata[0];

  for (auto& key : dva.fKeys()) {
    if (key & 1) {
      T v((key + 1) >> 1);
      dva[key] = v * key - 1;
    } else {
      T v(key >> 1);
      dva[key] = v * (key + 1) - 1;
    }
  }

  int idx = 0;
  for (int64 p = 2; p <= dva.m; ++p)
    if (dva[p] != dva[p - 1]) {
      const auto psum = dva[p - 1];
      const int64 p2 = p * p;
      while (idx + 1 < ks && keys[idx + 1] < p2) ++idx;
#if ENABLE_OPENMP
      if (ks - idx > 400000) {
#pragma omp parallel for schedule(dynamic, 100000) num_threads(TN)
        for (int j = idx + 1; j < ks; ++j) {
          const int64 v = keys[j] / p;
          tmp[j] = values[j] - (values[v <= dva.m ? v : ks - n / v] - psum) * p;
        }
#pragma omp parallel for schedule(dynamic, 100000) num_threads(TN)
        for (int j = idx + 1; j < ks; ++j) {
          values[j] = tmp[j];
        }
      } else {
#endif
        for (int j = ks - 1; j > idx; --j) {
          const int64 v = keys[j] / p;
          values[j] -= (values[v <= dva.m ? v : ks - n / v] - psum) * p;
        }
#if ENABLE_OPENMP
      }
#endif
    }
  return dva;
}

#define prime_sum prime_s1

template <typename T>
SL DVA<T> prime_s0_ex(const int64 n) {
  PE_ASSERT(n >= 1);
  DVA<T> dva(n);

  const int keySize = dva.key_size;
  RUBit<T> tree(keySize);

  for (auto& key : dva.fKeys()) {
    const int id = dva.idxOfValue(key);
    tree.update(id, id, key - 1);
  }

  for (int64 p = 2; p <= dva.m; ++p)
    if (is_prime(p)) {
      const auto pcnt = tree.query(static_cast<int>(p - 1));
      const int64 p2 = p * p;
      const int a = keySize - 1;
      const int b = dva.idxOfValue(p2);
      for (int i = a; i >= b;) {
        const auto delta = tree.query(dva.idxOfValue(dva.keys[i] / p)) - pcnt;
        const int mini = max(dva.idxOfValue(dva.keys[i] / p * p), b);
        tree.update(mini, i, -delta);
        i = mini - 1;
      }
    }
  for (int i = 1; i < keySize; ++i) dva[dva.keys[i]] = tree.query(i);
  return dva;
}

template <typename T>
SL DVA<T> prime_s1_ex(const int64 n) {
  PE_ASSERT(n >= 1);
  DVA<T> dva(n);

  const int keySize = dva.key_size;
  RUBit<T> tree(keySize);

  for (auto& key : dva.fKeys()) {
    const int id = dva.idxOfValue(key);

    if (key & 1) {
      T v((key + 1) >> 1);
      tree.update(id, id, v * key - 1);
    } else {
      T v(key >> 1);
      tree.update(id, id, v * (key + 1) - 1);
    }
  }

  for (int64 p = 2; p <= dva.m; ++p)
    if (is_prime(p)) {
      const auto psum = tree.query(static_cast<int>(p - 1));
      const int64 p2 = p * p;
      const int a = keySize - 1;
      const int b = dva.idxOfValue(p2);
      for (int i = a; i >= b;) {
        const auto delta = tree.query(dva.idxOfValue(dva.keys[i] / p)) - psum;
        const int mini = max(dva.idxOfValue(dva.keys[i] / p * p), b);
        tree.update(mini, i, -delta * p);
        i = mini - 1;
      }
    }

  for (int i = 1; i < keySize; ++i) dva[dva.keys[i]] = tree.query(i);
  return dva;
}

template <typename TreeType>
SL void prime_sk_ex_impl(const int64 /*n*/, int /*k*/, int64* PK,
                         TreeType& tree, DVA<int64>& dva, int64 mod) {
  const int keySize = dva.key_size;
  int pid = 0;
  for (int64 p = 2; p <= dva.m; ++p)
    if (is_prime(p)) {
      const auto psum = tree.query(static_cast<int>(p - 1)).value();
      const int64 p2 = p * p;
      const int a = keySize - 1;
      const int b = dva.idxOfValue(p2);
      for (int i = a; i >= b;) {
        const auto delta = sub_mod(
            tree.query(dva.idxOfValue(dva.keys[i] / p)).value(), psum, mod);
        const int mini = max(dva.idxOfValue(dva.keys[i] / p * p), b);
        tree.update(mini, i, sub_mod(0, mul_mod_ex(delta, PK[pid], mod), mod));
        i = mini - 1;
      }
      ++pid;
    }

  for (int i = 1; i < keySize; ++i) dva[dva.keys[i]] = tree.query(i).value();
}

SL DVA<int64> prime_sk_ex(const int64 n, int k, int64* PK, int64 mod) {
  PowerSumModerB psm(mod);

  PE_ASSERT(DefaultMod::mod() != 1);
  PE_ASSERT(n >= 1);
  DVA<int64> dva(n);

  const int keySize = dva.key_size;
  RUBit<NModNumber<DefaultMod>> tree(keySize);

  for (auto& key : dva.fKeys()) {
    const int id = dva.idxOfValue(key);
    const int64 val = sub_mod(psm.cal(key, k), 1, mod);
    tree.update(id, id, val);
  }

  prime_sk_ex_impl(n, k, PK, tree, dva, mod);

  return dva;
}

template <int64 mod>
SL DVA<int64> prime_sk_ex(const int64 n, int k, int64* PK) {
  PowerSumModerB psm(mod);

  PE_ASSERT(n >= 1);
  DVA<int64> dva(n);

  const int keySize = dva.key_size;
  RUBit<NModNumber<CCMod64<mod>>> tree(keySize);

  for (auto& key : dva.fKeys()) {
    const int id = dva.idxOfValue(key);
    const int64 val = sub_mod(psm.cal(key, k), 1, mod);
    tree.update(id, id, val);
  }

  prime_sk_ex_impl(n, k, PK, tree, dva, mod);

  return dva;
}

template <typename TreeType>
SL void prime_sk_ex_impl(const int64 /*n*/, int k, TreeType& tree,
                         DVA<int64>& dva, int64 mod) {
  const int keySize = dva.key_size;

  for (int64 p = 2; p <= dva.m; ++p)
    if (is_prime(p)) {
      const int64 pk = power_mod_ex(p, k, mod);
      const auto psum = tree.query(static_cast<int>(p - 1)).value();
      const int64 p2 = p * p;
      const int a = keySize - 1;
      const int b = dva.idxOfValue(p2);
      for (int i = a; i >= b;) {
        const auto delta = sub_mod(
            tree.query(dva.idxOfValue(dva.keys[i] / p)).value(), psum, mod);
        const int mini = max(dva.idxOfValue(dva.keys[i] / p * p), b);
        tree.update(mini, i, sub_mod(0, mul_mod_ex(delta, pk, mod), mod));
        i = mini - 1;
      }
    }

  for (int i = 1; i < keySize; ++i) dva[dva.keys[i]] = tree.query(i).value();
}

SL DVA<int64> prime_sk_ex(const int64 n, int k, int64 mod) {
  PowerSumModerB psm(mod);

  PE_ASSERT(n >= 1);
  DVA<int64> dva(n);

  const int keySize = dva.key_size;
  RUBit<NModNumber<DefaultMod>> tree(keySize);

  for (auto& key : dva.fKeys()) {
    const int id = dva.idxOfValue(key);
    const int64 val = sub_mod(psm.cal(key, k), 1, mod);
    tree.update(id, id, val);
  }

  prime_sk_ex_impl(n, k, tree, dva, mod);

  return dva;
}

template <int64 mod>
SL DVA<int64> prime_sk_ex(const int64 n, int k) {
  PowerSumModerB psm(mod);

  PE_ASSERT(n >= 1);
  DVA<int64> dva(n);

  const int keySize = dva.key_size;
  RUBit<NModNumber<CCMod64<mod>>> tree(keySize);

  for (auto& key : dva.fKeys()) {
    const int id = dva.idxOfValue(key);
    const int64 val = sub_mod(psm.cal(key, k), 1, mod);
    tree.update(id, id, val);
  }

  prime_sk_ex_impl(n, k, tree, dva, mod);

  return dva;
}

template <typename T>
SL vector<DVA<T>> prime_s0_pmod_even(int64 n, int pmod) {
  vector<DVA<T>> result;
  result.reserve(pmod);
  for (int i = 0; i < pmod; ++i) result.emplace_back(n);

  for (int i = 1; i < pmod; i += 2) {
    auto& target = result[i];
    const int dec = i == 1;
    for (auto key : result[0].fKeys())
      target[key] = (key + pmod - i) / pmod - dec;
  }
  for (int i = 1;; ++i) {
    const int64 p = plist[i];
    const int64 p2 = p * p;
    if (p2 > n) break;
    for (auto key : result[0].bKeys()) {
      if (key < p2) break;
      const int rp = p % pmod;
      for (int j = 1; j < pmod; j += 2) {
        const int next = rp * j % pmod;
        result[next][key] -= result[j][key / p] - result[j][p - 1];
      }
    }
  }

  auto& target = result[2 % pmod];
  for (auto key : result[0].fKeys()) {
    target[key] += key >= 2 ? 1 : 0;
  }
  return result;
}

template <typename T>
SL vector<DVA<T>> prime_s0_pmod_odd(int64 n, int pmod) {
  vector<DVA<T>> result;
  result.reserve(pmod);
  for (int i = 0; i < pmod; ++i) result.emplace_back(n);

  for (int i = 0; i < pmod; ++i) {
    const int dec = (i == 1 % pmod) + (i == 0);
    for (auto key : result[0].fKeys())
      result[i][key] = (key + pmod - i) / pmod - dec;
  }
  for (int i = 0;; ++i) {
    const int64 p = plist[i];
    const int64 p2 = p * p;
    if (p2 > n) break;
    for (auto key : result[0].bKeys()) {
      if (key < p2) break;
      const int rp = p % pmod;
      for (int j = 0; j < pmod; ++j) {
        const int next = rp * j % pmod;
        result[next][key] -= result[j][key / p] - result[j][p - 1];
      }
    }
  }
  return result;
}

template <typename T>
SL vector<DVA<T>> prime_s0_pmod(int64 n, int pmod) {
  return pmod & 1 ? prime_s0_pmod_odd<T>(n, pmod)
                  : prime_s0_pmod_even<T>(n, pmod);
}

template <typename T>
SL vector<DVA<T>> prime_s1_pmod_even(int64 n, int pmod) {
  vector<DVA<T>> result;
  for (int i = 0; i < pmod; ++i) result.emplace_back(n);

  for (int i = 1; i < pmod; i += 2) {
    auto& target = result[i];
    const int dec = i == 1;
    for (auto key : result[0].fKeys()) {
#if PE_HAS_INT128
      const int128 c = (key + pmod - i) / pmod;
#else
      const int64 c = (key + pmod - i) / pmod;
#endif
      target[key] = c * (c - 1) / 2 * pmod + c * i - dec;
    }
  }
  for (int i = 1;; ++i) {
    const int64 p = plist[i];
    const int64 p2 = p * p;
    if (p2 > n) break;
    for (auto key : result[0].bKeys()) {
      if (key < p2) break;
      const int rp = p % pmod;
      for (int j = 1; j < pmod; j += 2) {
        const int next = rp * j % pmod;
        result[next][key] -= (result[j][key / p] - result[j][p - 1]) * p;
      }
    }
  }

  auto& target = result[2 % pmod];
  for (auto key : result[0].fKeys()) {
    target[key] += key >= 2 ? 2 : 0;
  }
  return result;
}

template <typename T>
SL vector<DVA<T>> prime_s1_pmod_odd(int64 n, int pmod) {
  vector<DVA<T>> result;
  for (int i = 0; i < pmod; ++i) result.emplace_back(n);

  for (int i = 0; i < pmod; ++i) {
    auto& target = result[i];
    const int dec = i == 1 % pmod;
    for (auto key : result[0].fKeys()) {
#if PE_HAS_INT128
      const int128 c = (key + pmod - i) / pmod;
#else
      const int64 c = (key + pmod - i) / pmod;
#endif
      target[key] = c * (c - 1) / 2 * pmod + c * i - dec;
    }
  }

  for (int i = 0;; ++i) {
    const int64 p = plist[i];
    const int64 p2 = p * p;
    if (p2 > n) break;
    for (auto key : result[0].bKeys()) {
      if (key < p2) break;
      const int rp = p % pmod;
      for (int j = 0; j < pmod; ++j) {
        const int next = rp * j % pmod;
        result[next][key] -= (result[j][key / p] - result[j][p - 1]) * p;
      }
    }
  }

  return result;
}

template <typename T>
SL vector<DVA<T>> prime_s1_pmod(int64 n, int pmod) {
  return pmod & 1 ? prime_s1_pmod_odd<T>(n, pmod)
                  : prime_s1_pmod_even<T>(n, pmod);
}

template <int64 mod>
SL vector<DVA<NModNumber<CCMod64<mod>>>> prime_sk_pmod(const int64 n, int k,
                                                       int pmod) {
  using MT = NModNumber<CCMod64<mod>>;
  vector<DVA<MT>> result;
  for (int i = 0; i < pmod; ++i) result.emplace_back(n);

  PowerSumModerB psm(mod);

  PE_ASSERT(n >= 1);
  DVA<int64> dva(n);

  const int keySize = dva.key_size;
  RUBit<MT> tree(keySize);

  vector<int64> vec;
  MT powerPmod = 1;
  // Expand (pmod * x + i) ^ k
  for (int c = 0; c <= k; ++c, powerPmod *= pmod) {
    // C(k, c) (pmod * x)^c i^(k - c)
    MT coe = 1;
    if (c > 0) {
      vec.push_back(k - c + 1);
      int64 it = c;
      const int size = vec.size();
      for (int i = 0; i < size; ++i) {
        if (it > 1 && vec[i] > 1) {
          auto t = gcd(it, vec[i]);
          vec[i] /= t;
          it /= t;
        }
        if (vec[i] > 1) {
          coe *= vec[i];
        }
      }
    }
    for (int i = 1; i < pmod; ++i) {
      auto t = coe * powerPmod * power_mod_ex(i, k - c, mod);
      // psm.cal() doesn't count x == 0, i.e x^c is 0.
      // If c = 0, we need i^k, so 1 is added.
      // If c > 0, the behavior is expected.
      const int inc = c == 0;
      for (auto& key : dva.fKeys()) {
        if (key >= i) {
          result[i][key] += t * (psm.cal((key - i) / pmod, c) + inc);
        }
      }
    }
  }
  MT y = power_mod_ex(pmod, k, mod);
  for (auto& key : dva.fKeys()) {
    result[0][key] += y * psm.cal(key / pmod, k);
  }
  for (int i = 0; i < pmod; ++i) {
    if (1 % pmod == i) {
      for (auto& key : dva.fKeys()) {
        result[i][key] -= 1;
      }
      break;
    }
  }

  for (int i = 0;; ++i) {
    const int64 p = plist[i];
    const int64 p2 = p * p;
    if (p2 > n) break;
    for (auto key : result[0].bKeys()) {
      if (key < p2) break;
      const int64 coe = power_mod_ex(p, k, mod);
      const int rp = p % pmod;
      for (int j = 0; j < pmod; ++j) {
        const int next = rp * j % pmod;
        result[next][key] -= (result[j][key / p] - result[j][p - 1]) * coe;
      }
    }
  }

  return result;
}

struct CachedPi {
  CachedPi(int pivot_ = ::maxp) : pivot_(pivot_) { init(pivot_); }

  ~CachedPi() { release(); }

  void release() {
    if (prepi_ != nullptr) {
      delete[] prepi_;
      prepi_ = nullptr;
    }
  }

  void init(int pivot) {
    release();
    pivot_ = pivot;
    prepi_ = new int[pivot_ + 1];
    prepi_[0] = 0;
    for (int i = 1; i <= pivot_; ++i) {
      prepi_[i] = prepi_[i - 1] + is_prime(i);
    }
  }

  int64 cal(int64 n) {
    if (n <= pivot_) return prepi_[n];
    auto where = pi_cache_.find(n);
    if (where != pi_cache_.end()) return where->second;
    return pi_cache_[n] = prime_s0_ex<int64>(n)[n];
  }

  int64 operator()(int64 n) { return cal(n); }

 private:
  int* prepi_{nullptr};
  int pivot_;
  unordered_map<int64, int64> pi_cache_;
};

#if PE_HAS_INT128
/**
 * Counts the number in the pattern of p1^e1 p2^e2 p3^e3... no more than given
 * n.
 */
struct PatternNumberCounter {
  PatternNumberCounter() = default;

  ~PatternNumberCounter() { release(); }

  void release() {
    if (is_prime_used_ != nullptr) {
      delete[] is_prime_used_;
      is_prime_used_ = nullptr;
    }
  }

  // primeCnt: int a given pattern, we only consider the first primeCnt primes.
  // piPivot: when computing the number of prime no more than m, if m <=
  // piPivot, use pre-computed results in an array.
  void init(int prime_cnt_, int piPivot = 0) {
    PE_ASSERT(prime_cnt_ > 0);
    release();

    this->prime_cnt_ = prime_cnt_;
    is_prime_used_ = new char[prime_cnt_];
    if (piPivot == 0) {
      piPivot = plist[prime_cnt_ - 1];
    }
    cached_pi_.init(piPivot);
  }

  int128 dfs_pattern(const int start, const int id, const int patternLength,
                     const vi& pattern, const int128 remain) {
    int128 ret = 0;
    if (id == patternLength - 1) {
      const int64 t = nrooti(remain, pattern[patternLength - 1]);
      const int64 how_many = cached_pi_(t);
      const int64 idx = how_many - 1;
      if (idx < start) return 0;
      int64 have = idx - start + 1;
      for (int i = 0; i < top_; ++i)
        if (used_prime_idx_[i] >= start && used_prime_idx_[i] <= idx) {
          --have;
        }
      return have > 0 ? have : 0;
    }

    int e = pattern[id];
    for (int j = id + 1; j < patternLength; ++j)
      if (pattern[j] == pattern[id])
        e += pattern[id];
      else
        break;

    for (int i = start;; ++i)
      if (is_prime_used_[i] == 0) {
        int128 tmp = remain;
        for (int j = 0; j < e; ++j) tmp /= plist[i];
        if (tmp == 0) break;

        is_prime_used_[i] = 1;
        used_prime_idx_[top_++] = i;
        const int128 v = power<int128>(plist[i], pattern[id]);
        ret += dfs_pattern(pattern[id + 1] == pattern[id] ? i + 1 : 0, id + 1,
                           patternLength, pattern, remain / v);
        --top_;
        is_prime_used_[i] = 0;
      }
    return ret;
  }

  int128 cal(vi pattern, int128 n) {
    sort(all(pattern));
    reverse(all(pattern));

    top_ = 0;
    return dfs_pattern(0, 0, sz(pattern), pattern, n);
  }

  int prime_cnt_;
  int used_prime_idx_[1024];      // the index of used primes.
  char* is_prime_used_{nullptr};  // is the ith prime used
  int top_;
  CachedPi cached_pi_;
};
#endif

struct MVVHistory {
  int64 p;  // value of a prime factor.
  int ip;   // index of a prime factor.
  int e;    // exponential of a prime rfactor.
};

/**
 * Visit all values of x / (max primer factor of x) for x no more than n.
 * auto compute = [&](int64 val, int imp, int64 vmp, MVVHistory* his,
 *                    int top) -> int64 { return 1; };
 */
template <typename T = int64>
struct MValueVisitor {
  using VisitorType = std::function<T(int64, int, int64, MVVHistory*, int)>;

  MValueVisitor(const VisitorType& visitor) : visitor_(visitor), top_(0) {}

  T dfs(int limit, int64 n, int64 val, int imp, int64 vmp) {
    T ret = visitor_(val, imp, vmp, history_, top_);
    for (int i = 0; i < limit; ++i) {
      const int64 p = plist[i];
      const int nextimp = imp == -1 ? i : imp;
      const int64 nextvmp = imp == -1 ? p : vmp;
      const int64 valLimit = n / p / nextvmp;
      if (val > valLimit) break;
      history_[top_].ip = i;
      history_[top_].p = p;
      history_[top_].e = 1;
      int& e = history_[top_++].e;
      for (int64 nextval = val * p;; ++e) {
        ret += dfs(i, n, nextval, nextimp, nextvmp);
        if (nextval > valLimit) break;
        nextval *= p;
      }
      --top_;
    }
    return ret;
  }

  T run(int64 n) { return dfs(find_prime_idx_sg(n), n, 1, -1, 0); }

 private:
  VisitorType visitor_;
  MVVHistory history_[128];
  int top_;
};

template <typename T>
T for_m_values(
    int64 n,
    const std::function<T(int64, int, int64, MVVHistory*, int)>& visitor) {
  return MValueVisitor<T>(visitor).run(n);
}

/**
DVA<int64> dva(1);
using RT = int64;
struct Solver : public MValueBaseTP<Solver, RT, 8> {
  RT batch(int64 n, int64 val, int imp, int64 vmp, int emp, RT now) {
    RT ret = 0;
    int64 remain = n / val;
    // we have remain >= vmp
    // handle val * q where q > vmp
    if (remain > vmp) {
      ret += now * (dva[remain] - (imp + 1)) * 2;
    }
    if (val > 1) {
      // handle val * vmp
      ret += now / tmp[omp_get_thread_num()] * each(vmp, emp + 1);
    } else {
      // handle f(1)
      ret += 1;
    }
    return ret;
  }
  RT each(int64 p, int e) { return e + 1; }
  void visitMaxPrime(int64 vmp, int emp, RT now) {
    tmp[omp_get_thread_num()] = each(vmp, emp);
  }
  RT tmp[64];
};

MVVHistory history_[128];
int top_;
RT dfs(int limit, int64 n, int64 val, int imp, int64 vmp, int emp, RT now) {
  RT ret = 0;{
    int64 remain = n / val;
    // we have remain >= vmp
    // handle val * q where q > vmp
    if (remain > vmp) {
      ret += now * (dva[remain] - (imp + 1)) * 2;
    }
    if (val > 1) {
      // handle val * vmp
      ret += now / (history_[0].e + 1) * (emp + 2);
    } else {
      // handle f(1)
      ret += 1;
    }
  }
  for (int i = 0; i < limit; ++i) {
    const int64 p = plist[i];
    const int nextimp = imp == -1 ? i : imp;
    const int64 nextvmp = imp == -1 ? p : vmp;
    const int64 valLimit = n / p / nextvmp;
    if (val > valLimit) break;
    history_[top_].ip = i;
    history_[top_].p = p;
    history_[top_].e = 1;
    int& e = history_[top_++].e;
    for (int64 nextval = val * p;; ++e) {
      RT tmp = now * (e + 1);
      ret += dfs(i, n, nextval, nextimp, nextvmp, imp == -1 ? e : emp, tmp);
      if (nextval > valLimit) break;
      nextval *= p;
    }
    --top_;
  }
  return ret;
}
dfs(pcnt, n, 1, -1, 1, 0, 1)
*/

template <typename D, typename T = int64>
struct MValueBaseT {
  T dfs(int limit, int64 n, int64 val, int imp, int64 vmp, int emp, T now) {
    T ret = static_cast<D&>(*this).batch(n, val, imp, vmp, emp, now);
    for (int i = 0; i < limit; ++i) {
      const int64 p = plist[i];
      const int nextimp = imp == -1 ? i : imp;
      const int64 nextvmp = imp == -1 ? p : vmp;
      const int64 valLimit = n / p / nextvmp;
      if (val > valLimit) break;
      history_[top_].ip = i;
      history_[top_].p = p;
      history_[top_].e = 1;
      int& e = history_[top_++].e;
      for (int64 nextval = val * p;; ++e) {
        T tmp = now * static_cast<D&>(*this).each(p, e);
        if (imp == -1) {
          static_cast<D&>(*this).visitMaxPrime(nextvmp, e, tmp);
        }
        ret += dfs(i, n, nextval, nextimp, nextvmp, imp == -1 ? e : emp, tmp);
        if (nextval > valLimit) break;
        nextval *= p;
      }
      --top_;
    }
    return ret;
  }

  void visitMaxPrime(int64 vmp, int emp, T now) {}

  T solve(int64 n) {
    top_ = 0;
    return dfs(find_prime_idx_sg(n), n, 1, -1, 1, 0, 1);
  }

 private:
  MVVHistory history_[128];
  int top_;
};

template <typename D, typename T = int64, int TN = 1>
struct MValueBaseTP {
  T dfs(int limit, int64 n, int64 val, int imp, int64 vmp, int emp, T now) {
    T ret = static_cast<D&>(*this).batch(n, val, imp, vmp, emp, now);
#if ENABLE_OPENMP
    if (val == 1 && TN > 1) {
      PSum<T> sumHelper;
#pragma omp parallel for schedule(dynamic, 1) num_threads(TN)
      for (int i = 0; i < limit; ++i) {
        const int64 p = plist[i];
        const int nextimp = imp == -1 ? i : imp;
        const int64 nextvmp = imp == -1 ? p : vmp;
        const int64 valLimit = n / p / nextvmp;
        int e = 1;
        for (int64 nextval = val * p;; ++e) {
          T tmp = now * static_cast<D&>(*this).each(p, e);
          if (imp == -1) {
            static_cast<D&>(*this).visitMaxPrime(nextvmp, e, tmp);
          }
          sumHelper +=
              dfs(i, n, nextval, nextimp, nextvmp, imp == -1 ? e : emp, tmp);
          if (nextval > valLimit) break;
          nextval *= p;
        }
      }
      ret += sumHelper.value();
    } else {
#endif
      for (int i = 0; i < limit; ++i) {
        const int64 p = plist[i];
        const int nextimp = imp == -1 ? i : imp;
        const int64 nextvmp = imp == -1 ? p : vmp;
        const int64 valLimit = n / p / nextvmp;
        if (val > valLimit) break;
        int e = 1;
        for (int64 nextval = val * p;; ++e) {
          T tmp = now * static_cast<D&>(*this).each(p, e);
          if (imp == -1) {
            static_cast<D&>(*this).visitMaxPrime(nextvmp, e, tmp);
          }
          ret += dfs(i, n, nextval, nextimp, nextvmp, imp == -1 ? e : emp, tmp);
          if (nextval > valLimit) break;
          nextval *= p;
        }
      }
#if ENABLE_OPENMP
    }
#endif
    return ret;
  }

  void visitMaxPrime(int64 vmp, int emp, T now) {}
  T solve(int64 n) { return dfs(find_prime_idx_sg(n), n, 1, -1, 1, 0, 1); }
};

// Returns the number of integer solutions of
// x^2+y^2=z^2 where 0 < x < y, 0 < z <= n.
// See https://oeis.org/A101930
int64 count_pythagorean_triple(int64 n) {
  // f(i) = 4 prod(e_i + 1, p_i%4==1) #(write i as sum of two squares)
  // s = sum(f(i^2), i=1..n)
  // return (s - 4 * n) / 8
  auto _ = prime_s0_pmod<int64>(n, 4);
  auto ps1 = _[1];
  auto ps3 = _[3];
  auto compute = [&](int64 val, int /*imp*/, int64 vmp, MVVHistory* his,
                     int top_) -> int64 {
    if (val == 1) {
      return 3 * ps1[n] + ps3[n] + 2;  // 2 is for 1 and 2.
    }
    int64 ret = 0;
    int64 t = 1;
    for (int i = 0; i < top_; ++i) {
      if (his[i].p % 4 == 1) t *= 2 * his[i].e + 1;
    }
    if (his[0].p % 4 == 1) {
      ret += t / (2 * his[0].e + 1) * (2 * his[0].e + 3);
    } else {
      ret += t;
    }
    ret += (ps1[n / val] - ps1[vmp]) * t * 3;
    ret += (ps3[n / val] - ps3[vmp]) * t;
    return ret;
  };

  return (for_m_values<int64>(n, compute) - n) >> 1;
}

int64 count_pythagorean_triple_ex(int64 n) {
  auto _ = prime_s0_pmod<int64>(n, 4);
  auto ps1 = _[1];
  auto ps3 = _[3];
  function<int64(int, int64, int64, int64, int, int64)> dfs =
      [&](int limit, int64 n, int64 val, int64 c, int evmp,
          int64 vmp) -> int64 {
    int64 ret = 0;
    if (val == 1) {
      ret = 3 * ps1[n] + ps3[n] + 2;  // 2 is for 1 and 2.
    } else {
      ret += (ps1[n / val] - ps1[vmp]) * c * 3;
      ret += (ps3[n / val] - ps3[vmp]) * c;
      if (vmp % 4 == 1) {
        ret += c / (2 * evmp + 1) * (2 * evmp + 3);
      } else {
        ret += c;
      }
    }
    for (int i = 0; i < limit; ++i) {
      const int64 p = plist[i];
      const int64 nextvmp = vmp == 0 ? p : vmp;
      const int64 valLimit = n / p / nextvmp;
      if (val > valLimit) break;
      int e = 1;
      int should = p % 4 == 1;
      for (int64 nextval = val * p;; ++e) {
        ret += dfs(i, n, nextval, should ? c * (2 * e + 1) : c,
                   nextvmp == p ? e : evmp, nextvmp);
        if (nextval > valLimit) break;
        nextval *= p;
      }
    }
    return ret;
  };
  return (dfs(pcnt, n, 1, 1, 0, 0) - n) >> 1;
}

template <typename T>
struct PerfectPowerCounter {
  PerfectPowerCounter(int pivot = 1000000) : pivot_(pivot) { init(); }

  ~PerfectPowerCounter() { delete[] pre_; }

  void init() {
    PE_ASSERT(pivot_ < (1 << 20));
    pre_ = new int[pivot_][20];
    fill(pre_[0], pre_[0] + 20, 0);
    pre_[0][0] = 1;
    for (int i = 2; i <= pivot_; ++i) {
      auto f = factorize(i);
      int d = 0;
      for (auto& iter : f) d = gcd(d, iter.second);
      for (int j = 0; j <= 19; ++j) pre_[i][j] = pre_[i - 1][j];
      pre_[i][d]++;
    }
  }

  // Use f(x) to denote gcd of exponention of x.
  // i.e if x=p1^e1 * p2^e2 * pe^e3, f(x) = gcd(e1, e2, e3).
  // f(1) = 0
  // This method returns # {x | f(x) = d, x >= 1, x <= n}
  // n < 2^128, d >= 0
  T cal(T n, int d) {
    if (n <= pivot_) {
      if (d < 20)
        return pre_[n][d];
      else
        return 0;
    }
    if (d == 0) return n >= 1 ? 1 : 0;
    if (d > 128) return 0;

    pair<T, int> key{n, d};
    auto where = mem_.find(key);
    if (where != mem_.end()) return where->second;

    if (d == 1) {
      T ret = n - 1;
      for (int i = 2; i < 128; ++i) {
        ret -= cal(n, i);
      }
      return mem_[key] = ret;
    }

    return mem_[key] = cal(nrooti<T>(n, d), 1);
  }

 private:
  int pivot_;
  int (*pre_)[20];
  map<pair<T, int>, T> mem_;
};

// See pe466, Lucy_Hedgehog's post.
template <typename T>
struct NotDivCounter {
  T notDivCoprimeImpl(T n, const vector<int64>& L, int i) {
    T ret = n;
    for (int j = 0; j < i; ++j) {
      const auto x = L[j];
      if (x > n) break;
      ret -= notDivCoprimeImpl(n / x, L, j);
    }
    return ret;
  }

  // Returns the number of integers in the range of 1..n not
  // divisible by any integer in L.
  // The intergers in L must be pairwise coprime.
  T notDivCoprime(T n, const vector<int64>& L) {
    const int size = sz(L);
    if (size == 0) return n;
    if (checkSorted(L)) return notDivCoprimeImpl(n, L, size);

    vector<int64> LL(L);
    sort(LL.begin(), LL.end());
    return notDivCoprimeImpl(n, LL, size);
  }

  T notDivImpl(T n, const vector<int64>& L) {
    const int size = sz(L);
    if (size == 0) return n;

    vector<int> flag(size, 0);
    for (int i = 0; i < size; ++i)
      for (int j = i + 1; j < size; ++j)
        if (L[j] % L[i] == 0) flag[j] = 1;
    vector<int64> R;
    for (int i = 0; i < size; ++i)
      if (flag[i] == 0) R.push_back(L[i]);

    for (int i = 0; i < pcnt; ++i) {
      const int64 p = plist[i];
      if (p > L[size - 1]) break;

      vector<int64> D;
      for (auto& iter : R)
        if (iter % p == 0) D.push_back(iter);
      if (sz(D) < 2) continue;
      vector<int64> C;
      for (auto& iter : R)
        if (iter % p) C.push_back(iter);
      vector<int64> B(C);
      for (auto& iter : D) B.push_back(iter / p);
      sort(B.begin(), B.end());
      return notDivImpl(n, C) - notDivImpl(n / p, C) + notDivImpl(n / p, B);
    }

    pair<T, vector<int64>> key{n, R};
    auto where = mem_.find(key);
    if (where != mem_.end()) return where->second;
    return mem_[key] = notDivCoprime(n, R);
  }

  // Returns the number of inters in the range of 1..n not
  // divisible by any integer in L.
  T notDiv(T n, const vector<int64>& L) {
    const int size = sz(L);
    if (size == 0) return n;
    if (checkSorted(L)) return notDivImpl(n, L);

    vector<int64> LL(L);
    sort(LL.begin(), LL.end());
    return notDivImpl(n, LL);
  }

  int checkSorted(const vector<int64>& L) {
    const int size = sz(L);
    for (int i = 0; i + 1 < size; ++i)
      if (L[i] > L[i + 1]) {
        return 0;
      }
    return 1;
  }

 private:
  map<pair<T, vector<int64>>, T> mem_;
};

/**
 * DfaCounter<Count type> dc;
 * dc.init(state count, transCount, max len)[.setCountEachLen(1)];
 * dc.addTrans(src, dig, dest);
 * dc.markAsCount(state);
 * [optional] dc.prepare();
 * dc.count(upper bound);
 * dc.findKth(k, upper bound);
 */
template <typename CT>
struct DfaCounter {
  DfaCounter& setCountEachLen(int count_each_len) {
    this->count_each_len_ = count_each_len;
    return *this;
  }

  DfaCounter& init(int state_count, int trans_count, int max_len) {
    this->state_count_ = state_count;
    this->trans_count_ = trans_count;
    this->max_len_ = max_len;

    dfa_.reset({state_count, trans_count});

    dp_.reset({max_len + 1, state_count});

    to_count_.resize(state_count);
    fill(to_count_.begin(), to_count_.end(), 0);

    prepared_ = 0;

    return *this;
  }

  DfaCounter& addTrans(int s, int d, int t) {
    dfa_[s][d] = t;
    return *this;
  }

  DfaCounter& markAsCount(int s, int v = 1) {
    to_count_[s] = v;
    return *this;
  }

  void prepare() {
    for (int i = 0; i < state_count_; ++i) {
      dp_[0][i] = to_count_[i];
    }
    for (int i = 1; i <= max_len_; ++i)
      for (int j = 0; j < state_count_; ++j) {
        auto to = dfa_[j];
        for (int k = 0; k < trans_count_; ++k) dp_[i][j] += dp_[i - 1][to[k]];
      }
    prepared_ = 1;
  }

  template <typename U>
  CT count(U n) {
    if (prepared_ == 0) {
      prepare();
      prepared_ = 1;
    }

    vector<int> dig;
    for (auto x = n; !is_zero(x); x /= 10) dig.push_back(to_int<int>(x % 10));
    const int len = dig.size();
    PE_ASSERT(len <= max_len_);

    CT result = 0;
    if (count_each_len_) {
      for (int i = 1; i < len; ++i) result += dp_[i][0];
    }

    int state = 0;
    for (int curr = len - 1; curr >= 0; --curr) {
      const int me = dig[curr];
      for (int i = 0; i < me; ++i) {
        result += dp_[curr][dfa_[state][i]];
      }
      state = dfa_[state][me];
    }
    if (to_count_[state]) {
      result += 1;
    }
    return result;
  }

  template <typename U>
  CT findKth(CT k, U max_v) {
    U l = 1, r = max_v;
    while (l <= r) {
      U mid = (l + r) / 2;
      if (count(mid) >= k)
        r = mid - 1;
      else
        l = mid + 1;
    }
    return l;
  }

 private:
  int count_each_len_ = 0;
  int state_count_ = 0;
  int trans_count_ = 0;
  int prepared_ = 0;
  int max_len_ = 0;
  DArray<int, 2> dfa_;
  DArray<CT, 2> dp_;
  vector<int> to_count_;
};
#endif