#ifndef PE_VECTOR_
#define PE_VECTOR_

#include "pe_base"

namespace pe {

template <typename T>
SL std::vector<T> VectorAdd(const std::vector<T>& a, const std::vector<T>& b) {
  std::vector<T> c(std::size(a));
  for (int i = 0; i < std::size(a); ++i) c[i] = a[i] + b[i];
  return c;
}

template <typename T>
SL std::vector<T> VectorSub(const std::vector<T>& a, const std::vector<T>& b) {
  std::vector<T> c(std::size(a));
  for (int i = 0; i < std::size(a); ++i) c[i] = a[i] - b[i];
  return c;
}

template <typename T>
SL std::vector<T> VectorScale(T t, const std::vector<T>& b) {
  std::vector<T> c(std::size(b));
  for (int i = 0; i < std::size(b); ++i) c[i] = t * b[i];
  return c;
}

template <typename T>
SL std::vector<T> VectorScale(const std::vector<T>& b, T t) {
  std::vector<T> c(std::size(b));
  for (int i = 0; i < std::size(b); ++i) c[i] = t * b[i];
  return c;
}

template <typename T>
SL T VectorDotProduct(const std::vector<T>& a, const std::vector<T>& b) {
  T ret = 0;
  for (int i = 0; i < std::size(a); ++i) ret += a[i] * b[i];
  return ret;
}
}  // namespace pe
#endif